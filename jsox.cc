#define JSON_PARSER_MAIN_SOURCE
#define NO_OPEN_MACRO
#define __NO_MMAP__
#define __STATIC__
#define __NO_OPTIONS__
#define __NO_ODBC__
#define NO_FILEOP_ALIAS
#define SACK_BAG_EXPORTS
#define __STATIC_GLOBALS__
//#define TYPELIB_SOURCE
#define __NO_INTERFACE_SUPPORT__
#include <stdio.h>
#include <stdarg.h>
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#if _XOPEN_SOURCE < 500
#  undef _XOPEN_SOURCE
#  define _XOPEN_SOURCE 500
#endif
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#ifndef _WIN32
#  ifndef __LINUX__
#    define __LINUX__
#  endif
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
                  // Macros min(a,b) and max(a,b)
#  define NOMINMAX
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
#  if _MSC_VER > 1500
#    define mkdir _mkdir
#    define fileno _fileno
#    define stricmp _stricmp
#    define strdup _strdup
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ "(" STRSYM(__LINE__) ") Would DebugBreak here..." ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      ifdef __EMSCRIPTEN__
#        define DebugBreak()
#      else
#        define DebugBreak()  __asm__("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
#ifndef SACK_PRIMITIVE_TYPES_INCLUDED
#define SACK_PRIMITIVE_TYPES_INCLUDED
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __declspec(thread)
#  define DeclareThreadVar __declspec(thread)
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __thread
#  define DeclareThreadVar __thread
#else
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#if !defined( _WIN32 ) && !defined( __MAC__ )
#  include <syscall.h>
#elif defined( __MAC__ )
#  include <sys/syscall.h>
#endif
#ifndef MY_TYPES_INCLUDED
#  define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#  include <limits.h>
 // typelib requires this
#  ifdef _MSC_VER
#    ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#      include <intrin.h>
#    endif
#  endif
 // typelib requires this
#  include <string.h>
#  if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#    include <dlfcn.h>
#  endif
#  if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#    define EMPTY_STRUCT struct { char nothing[]; }
#  endif
#  if defined( __WATCOMC__ )
#     define EMPTY_STRUCT char
#  endif
#  ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#    define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#  else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END
#  endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#  define CPROC
#  ifdef SACK_BAG_EXPORTS
#    ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#      define EXPORT_METHOD [DllImport(LibName)] public
#    else
#      ifdef __cplusplus_cli
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
#          define EXPORT_METHOD __declspec(dllexport)
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#      else
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#          define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#      endif
#    endif
#  else
#  if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#    if defined( __LINUX__ ) || defined( __STATIC__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#      define LITERAL_LIB_EXPORT_METHOD
#      define LITERAL_LIB_IMPORT_METHOD extern
#    else
#      define EXPORT_METHOD __declspec(dllexport)
#      define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#    endif
#  endif
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( "Library Enter" );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( "Library Enter" );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) #n
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) "(" TEXT(STRSYM(__LINE__))" : ")
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , __FILE__, __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     __FILE__, __LINE__
//#define FILELINE_LEADSRC     __FILE__, __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_NULL        , NULL, 0
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT "%s(%" _32f "): "
#define FILELINE_FILELINEFMT_MIN "%s(%" _32f ")"
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = __FILE__; uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
	  in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL        FILELINE_NULL
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists
	 (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of int32_t (LONG)
 */
typedef int  SBIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get
// padded as normal; this is appended to a strcture
// and is ued on GCC comiplers for __attribute__((packed))
#ifndef PACKED
#  define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   "u"
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   "x"
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   "X"
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   "d"
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   "u"
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   "x"
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   "X"
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   "d"
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   PRIu32
#  define _32fx    PRIx32
#  define _32fX    PRIX32
#  define _32fs    PRId32
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   "u"
#  define _32fx   "x"
#  define _32fX   "X"
#  define _32fs   "d"
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#  define _cstring_f "s"
#  define _string_f "s"
#  define _ustring_f "S"
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu64
#      define _size_fx    PRIx64
#      define _size_fX    PRIX64
#      define _size_fs    PRId64
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu32
#      define _size_fx    PRIx32
#      define _size_fX    PRIX32
#      define _size_fs    PRId32
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf "p"
#define _PTRSZVALf "p"
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    "llu"
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   "llx"
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   "llX"
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   "lld"
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 )
#  define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#  define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#  ifdef __MAC__
#    define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)( syscall(SYS_thread_selfid) ) ) )
#  else
#    ifndef GETPID_RETURNS_PPID
#      define GETPID_RETURNS_PPID
#    endif
#    ifdef GETPID_RETURNS_PPID
#      ifdef __ANDROID__
#        define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#      else
#        if defined( __EMSCRIPTEN__ )
#          define GetMyThreadID()  ( (uint64_t)(pthread_self()) )
#        else
#          define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(syscall(SYS_gettid)) ) )
#        endif
#      endif
#    else
#      define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#    endif
#  endif
#  define _GetMyThreadID GetMyThreadID
#endif
//---------------------- Declare Link; 'single and a half'ly-linked lists -----------------------
// Thse macros are for linking and unlininking things in a linked list.
// The list is basically a singly-linked list, but also references the pointer that
// is pointing at the current node.  This simplifies insert/remove operations, because
// the specific list that the node is in, is not required.
// List heads will always be updated correctly.
//
// A few 'tricks' are available, such as
//     0) These are deemed dangerous; and uncomprehendable by anyone but the maintainer.
//        use at your own time and expense required to explain WHY these work.
//     1) when declaring a root node, include another node before it, and it's
//        simple to make this a circularly linked list.
//     2) defining DeclareLink at the start of the strcture, the 'me' pointer
//        also happens to be 'prior', so you can step through the list in both
//        directions.
//
//
//
// struct my_node {
//    DeclareLink( struct my_node );
//    // ...
// };
//
// that declares
//      struct my_node *next;  // the next node in list.
//      struct my_node **me;   // address of the pointer pointing to 'me';
//
//
//  struct my_node *root; // a root of a list of my_node.  It should be initialized to NULL.
//
//  struct my_node *newNode = (struct my_node*)malloc( sizeof( *newNode ) );
//     // does not require next or me to be initiialized.
//  LinkThing( root, newNode );
//     // now newNode is in the list.
//
//  to remove from a list
//
//  struct my_node *someNode; // this should be a pointer to some valid node.
//  UnlinkThing( someNode );
//     The new node is now not in the list.
//
//  To move one node from one list to another
//
//   struct my_node *rootAvail;  // available nodes
//   struct my_node *rootUsed;   // nodes in use
//
//   struct my_node *someNode; // some node in a list
//   someNode = rootAvail; // get first available.
//   if( !someNode ) ; // create a new one or abort
//   RelinkThing( rootUsed, someNode );
//      'someNode' is removed from its existing list, and added to the 'rootUsed' list.
//
// For Declaring the link structure members for lists
#define DeclareLink( type )  type *next; type **me
/* Link a new node into the list.
   Example
   struct mynode
   {
       DeclareLink( struct mynode );
   } *node;
	struct mynode *list;
   // node allocation not shown.
	LinkThing( list_root, node );
*/
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. LinkThing() inserts the new
 node as the new head of the list.
 this has to scan the list to find the end, so it is a O(n) operation.
 All other linked list operations are O(1)
 */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
// inserts 'node' after Thing
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
// similar to LinkThingAfter but puts the new 'thing'
// before the 'node' specified.
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
// move a list from one list to another.
// unlinks node from where it was, inserts at the head of another.
// this can also be use to reproiritize within the same list.
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink
 safe iterator macro that tests if node is valid, which returns
 the next item in the list, else returns NULL
 */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//----------- FLAG SETS (single bit fields) -----------------
/* the default type to use for flag sets - flag sets are arrays of bits
 which can be set/read with/as integer values an index.
 All of the fields in a maskset are the same width */
#define FLAGSETTYPE uintmax_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) )),1)
// clear a single flag index
#define RESETFLAG(v,n) ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) ),0)
// test if a flags is set
//  result is 0 or not; the value returned is the bit shifted within the word, and not always '1'
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
// return value is undefined... and is a whole bunch of flags from some offset...
// if you want ot toggle and flag and test the result, use TESTGOGGLEFLAG() instead.
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ))
// Toggle a bit, return the state of the bit after toggling.
#define TESTTOGGLEFLAG(v,n)  ( TOGGLEFLAG(v,n), TESTFLAG(v,n) )
//----------- MASK SETS -----------------
//  MASK Sets are arrays of bit-fields of some bit-width (5, 3, ... )
//  they are set/returned as integer values.
//  They are stored-in/accessed via a uint8_t which gives byte-offset calculations.
// they return their value as uintmax_t from the offset memory address directly;
//   Some platforms(Arm) may SIGBUS because of wide offset accesses spanning word boundaries.
//   This issue may be fixed by rounding, grabbing the word aligned values and shifting manually
// Declarataion/Instantiation of a mask set is done with MASKSET macro below
// 32 bits max for range on mask
#define MASK_MAX_LENGTH (sizeof(MASKSET_READTYPE)*CHAR_BIT)
/* gives a 32 bit mask possible from flagset..
 - updated; return max int possible; but only the low N bits will be set
 - mask sets are meant for small values, but could be used for like 21 bit fields. (another form of unicode encoding I suppose)
 */
#define MASKSET_READTYPE uintmax_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length)) & (sizeof(MASKSET_READTYPE) - 1) ) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set.
 MASKSET( maskVariableName
        , 32 //number of items
		  , 5 // number of bits per field
		  );
   declares
	uint8_t maskVariableName[ (32*5 +(CHAR_BIT-1))/CHAR_BIT ];  //data array used for storage.
   const int askVariableName_mask_size = 5;  // used aautomatically by macros
*/
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
/* set a field index to a value
    SETMASK( askVariableName, 3, 13 );  // set set member 3 to the value '13'
 */
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
/* get the value of a field
     GETMASK( maskVariableName, 3 );   // returns '13' given the SETMASK() example code.
 */
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
/* LIST is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX index) { return GetLink( &list, index ); }
} *piList;
#  endif
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
 //		namespace list;
	}
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
 //		namespace link_stack {
		}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
}
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
// this THis defines/initializes the data part of a PTEXT/TEXT structure.
// used with DECLTEXTSZTYPE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1  ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
#  include <strings.h>
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#  define stricmp strcasecmp
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a piece of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.
     allows +/- leadin ([-*]|[+*])*
     supports 0x### (hex), 0b#### (binary), 0o#### (octal), 0### (octal)
	 decimal 1-9[0-9]*
	 buggy implementation supports +/- inline continue number and are either ignored(+)
	 or changes the overall sign of the number(-).  A Decimal definatly ends the number.
	 And octal/binary digits aren't checked for range, so 8/9 will over-flow in octal,
	 and 2-9 overflow to upper bits in octal...
	    0b901090 // would be like   0b 10100110    0b1001 +  010 + 1001<<3 + 0
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Converts a text to the longest precision signed integer
   value.  Does the work of IntCreateFromText.
   IntCreateFromTextRef updates the pointer passed by reference so
   the pointer ends at the first character after the returned number.
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromTextRef( CTEXTSTR *p_ );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space " \t"
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history; negative indexes are recalled commands.
	int nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   int total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
}
 // namespace sack
}
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
//#include <construct.h> // pronounced 'kahn-struct'
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END } }
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//  returns the millisecond of the day (since UNIX Epoch) * 256 ( << 8 )
// the lowest 8 bits are the timezone / 15.
// The effect of the low [7/]8 bits being the time zone is that within the same millisecond
// UTC +0 sorts first, followed by +1, +2, ... etc until -14, -13, -12,... -1
// the low [7/]8 bits are the signed timezone
// (timezone could have been either be hr*60 + min (ISO TZ format)
// or in minutes (hr*60+mn) this would only take 7 bits
// one would think 8 bit shifts would be slightly more efficient than 7 bits.
// and sign extension for 8 bits already exists.
// - REVISION - timezone with hr*100 does not divide by 15 cleanly.
//     The timezone is ( hour*60 + min ) / 15 which is a range from -56 to 48
//     minimal representation is 7 bits (0 - 127 or -64 - 63)
//     still keeping 8 bits for shifting, so the effective range is only -56 to 48 of -128 to 127
// struct time_of_day {
//    uint64_t epoch_milliseconds : 56;
//    int64_t timezone : 8; divided by 15... hours * 60 / 15
// }
SYSLOG_PROC  int64_t SYSLOG_API GetTimeOfDay( void );
// binary little endian order; somewhat
typedef struct sack_expanded_time_tag
{
	uint16_t ms;
	uint8_t sc,mn,hr,dy,mo;
	uint16_t yr;
	int8_t zhr, zmn;
} SACK_TIME;
typedef struct sack_expanded_time_tag *PSACK_TIME;
// convert a integer time value to an expanded structure.
SYSLOG_PROC void     SYSLOG_API ConvertTickToTime( int64_t, PSACK_TIME st );
// convert a expanded time structure to a integer value.
SYSLOG_PROC int64_t SYSLOG_API ConvertTimeToTick( PSACK_TIME st );
// returns timezone as hours*100 + minutes.
// result is often negated?
SYSLOG_PROC  int SYSLOG_API GetTimeZone(void);
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  DefineRegistryMethod("SACK",_OnLibraryLoad,"system/library","load_event",name "_LoadEvent",void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#if defined( __MAC__ )
#  define strdup(s) StrDup(s)
#  define strdup_free(s) Release(s)
#else
#  define strdup_free(s) free(s)
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
	// these are not included without a special compile flag
	// only required by low level deveopers who may be against
   // undefined behavior.
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
}
 // namespace sack
}
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( "Picture Memory", "Picture.mem", 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, uintptr_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, uintptr_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,sizeof(type)*(count)))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( volatile uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( volatile uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( "look in this string", "in" );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( "look in this string" );
   TEXTCHAR *found = StrStr( writable_string, "in" );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
}
 // namespace sack
}
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifdef __LINUX__
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ )
#  if defined( __ANDROID__ ) || defined( EMSCRIPTEN ) || defined( __MAC__ )
// android > 21 can use pthread_mutex_timedop
#    define USE_PIPE_SEMS
#  else
//   Default behavior is to use pthread_mutex_timedlock for wakeable sleeps.
// no semtimedop; no semctl, etc
//#    include <sys/sem.h>
//originally used semctl; but that consumes system resources that are not
//cleaned up when the process exits.
#endif
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* Releases resources associated with a PTHREAD. For purposes of
   waking a thread, and providing a wakeable point for the
   thread, a system blocking event object is allocated, named
   with the THREAD_ID so it can be referenced by other
   processes. This is only allowed to be done by the thread
   itself.
   Parameters
   Param1 :  \Description
   Param2 :  \Description
   Example
   <code lang="c++">
   int main( void )
   {
       PTHREAD myself = MakeThread();
       // create threads, do stuff...
       UnmakeThread();
       At this point the pointer in 'myself' is invalid, and should be cleared.
       myself = NULL;
   }
   </code>                                                                      */
TIMER_PROC( void, UnmakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _WIN32
#  ifdef CONSOLE_SHELL
 // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#    define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#    define EndSaneWinMain() } }
#  else
#    define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#    define EndSaneWinMain() } }
#  endif
#else
#  if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#    define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#    define EndSaneWinMain()
#  else
#    define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#    define EndSaneWinMain() } }
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define snprintf _snprintf
#    define vsnprintf _vsnprintf
#    if defined( _UNICODE )
#      define tnprintf _snwprintf
#      define vtnprintf _vsnwprintf
#    else
#      define tnprintf _snprintf
#      define vtnprintf _vsnprintf
#    endif
#    define snwprintf _snwprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
#ifdef __cplusplus
namespace sack {
   namespace logging {
#endif
      INDEX real_lprintf( char const* f,... ) { va_list va; int n; va_start(va,f); n = vprintf(f ,va); puts(""); return n; }
      INDEX null_lprintf( char const* f,... ) { return 0; }
      RealLogFunction _xlprintf(uint32_t level DBG_PASS) { return real_lprintf; };
      void SystemLog( char const* f ) { puts( f ); puts( "ZZZZ\n" ); }
#ifdef __cplusplus
   }
}
#endif
/***************************************************************
 * JSOX Parser
 *
 * Parses JSOX (github.com/d3x0r/jsox)
 *
 * This function is meant for a simple utility to just take a known completed packet,
 * and get the values from it.  There may be mulitple top level values, although
 * the JSON standard will only supply a single object or array as the first value.
 * jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1, &pdlMessage );
 *
 *
 * Example :
 // call to parse a message... and iterate through each value.
 {
parse_message
    PDATALIST pdlMessage;
    LOGICAL gotMessage;
	 if( jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1, &pdlMessage ) ) {
		  int index;
        struct jsox_value_container *value;
		  DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value ) {
           // for each value in the result.... the first layer will
           // always be just one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
           // then for each value->contains (as a datalist like above), process each of those values.
		  }
        jsox_dispose_mesage( &pdlMessage );
    }
 }
 *
 *  This is a streaming setup, where a data block can be added,
 *  and the stream of objects can be returned from it....
 *
 *  Example 2:
 // allocate a parser to keep track of the parsing state...
 struct jsox_parse_state *parser = jsox_begin_parse();
 // at some point later, add some data to it...
 jsox_parse_add_data( parser, "utf8-data", sizeof( "utf8-data" ) - 1 );
 // and then get any objects that have been parsed from the stream so far...
 {
    PDATALIST pdlMessage;
	 pdlMessage = jsox_parse_get_data( parser );
    if( pdlMessage )
	 {
        int index;
        struct jsox_value_container *value;
        DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value ) {
           // for each value in the result.... the first layer will
           // always be just one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
           // then for each value->contains (as a datalist like above), process each of those values.
        }
        jsox_dispose_mesage( &pdlMessage );
		  jsox_parse_add_data( parser, NULL, 0 ); // trigger parsing next message.
	 }
 }
 *
 ***************************************************************/
#ifndef JSOX_PARSER_HEADER_INCLUDED
#define JSOX_PARSER_HEADER_INCLUDED
// include types to get namespace, and, well PDATALIST types
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#if _XOPEN_SOURCE < 500
#  undef _XOPEN_SOURCE
#  define _XOPEN_SOURCE 500
#endif
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#ifndef _WIN32
#  ifndef __LINUX__
#    define __LINUX__
#  endif
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
                  // Macros min(a,b) and max(a,b)
#  define NOMINMAX
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
#  if _MSC_VER > 1500
#    define mkdir _mkdir
#    define fileno _fileno
#    define stricmp _stricmp
#    define strdup _strdup
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ "(" STRSYM(__LINE__) ") Would DebugBreak here..." ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      ifdef __EMSCRIPTEN__
#        define DebugBreak()
#      else
#        define DebugBreak()  __asm__("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
#ifndef SACK_PRIMITIVE_TYPES_INCLUDED
#define SACK_PRIMITIVE_TYPES_INCLUDED
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __declspec(thread)
#  define DeclareThreadVar __declspec(thread)
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __thread
#  define DeclareThreadVar __thread
#else
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#if !defined( _WIN32 ) && !defined( __MAC__ )
#  include <syscall.h>
#elif defined( __MAC__ )
#  include <sys/syscall.h>
#endif
#ifndef MY_TYPES_INCLUDED
#  define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#  include <limits.h>
 // typelib requires this
#  include <stdarg.h>
#  ifdef _MSC_VER
#    ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#      include <intrin.h>
#    endif
#  endif
 // typelib requires this
#  include <string.h>
#  if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#    include <dlfcn.h>
#  endif
#  if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#    define EMPTY_STRUCT struct { char nothing[]; }
#  endif
#  if defined( __WATCOMC__ )
#     define EMPTY_STRUCT char
#  endif
#  ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#    define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#  else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END
#  endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#  define CPROC
#  ifdef SACK_BAG_EXPORTS
#    ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#      define EXPORT_METHOD [DllImport(LibName)] public
#    else
#      ifdef __cplusplus_cli
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
#          define EXPORT_METHOD __declspec(dllexport)
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#      else
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#          define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#      endif
#    endif
#  else
#  if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#    if defined( __LINUX__ ) || defined( __STATIC__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#      define LITERAL_LIB_EXPORT_METHOD
#      define LITERAL_LIB_IMPORT_METHOD extern
#    else
#      define EXPORT_METHOD __declspec(dllexport)
#      define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#    endif
#  endif
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( "Library Enter" );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( "Library Enter" );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) #n
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) "(" TEXT(STRSYM(__LINE__))" : ")
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , __FILE__, __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     __FILE__, __LINE__
//#define FILELINE_LEADSRC     __FILE__, __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_NULL        , NULL, 0
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT "%s(%" _32f "): "
#define FILELINE_FILELINEFMT_MIN "%s(%" _32f ")"
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = __FILE__; uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
	  in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL        FILELINE_NULL
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists
	 (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of int32_t (LONG)
 */
typedef int  SBIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get
// padded as normal; this is appended to a strcture
// and is ued on GCC comiplers for __attribute__((packed))
#ifndef PACKED
#  define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   "u"
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   "x"
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   "X"
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   "d"
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   "u"
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   "x"
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   "X"
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   "d"
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   PRIu32
#  define _32fx    PRIx32
#  define _32fX    PRIX32
#  define _32fs    PRId32
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   "u"
#  define _32fx   "x"
#  define _32fX   "X"
#  define _32fs   "d"
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#  define _cstring_f "s"
#  define _string_f "s"
#  define _ustring_f "S"
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu64
#      define _size_fx    PRIx64
#      define _size_fX    PRIX64
#      define _size_fs    PRId64
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu32
#      define _size_fx    PRIx32
#      define _size_fX    PRIX32
#      define _size_fs    PRId32
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf "p"
#define _PTRSZVALf "p"
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    "llu"
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   "llx"
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   "llX"
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   "lld"
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 )
#  define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#  define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#  ifdef __MAC__
#    define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)( syscall(SYS_thread_selfid) ) ) )
#  else
#    ifndef GETPID_RETURNS_PPID
#      define GETPID_RETURNS_PPID
#    endif
#    ifdef GETPID_RETURNS_PPID
#      ifdef __ANDROID__
#        define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#      else
#        if defined( __EMSCRIPTEN__ )
#          define GetMyThreadID()  ( (uint64_t)(pthread_self()) )
#        else
#          define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(syscall(SYS_gettid)) ) )
#        endif
#      endif
#    else
#      define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#    endif
#  endif
#  define _GetMyThreadID GetMyThreadID
#endif
//---------------------- Declare Link; 'single and a half'ly-linked lists -----------------------
// Thse macros are for linking and unlininking things in a linked list.
// The list is basically a singly-linked list, but also references the pointer that
// is pointing at the current node.  This simplifies insert/remove operations, because
// the specific list that the node is in, is not required.
// List heads will always be updated correctly.
//
// A few 'tricks' are available, such as
//     0) These are deemed dangerous; and uncomprehendable by anyone but the maintainer.
//        use at your own time and expense required to explain WHY these work.
//     1) when declaring a root node, include another node before it, and it's
//        simple to make this a circularly linked list.
//     2) defining DeclareLink at the start of the strcture, the 'me' pointer
//        also happens to be 'prior', so you can step through the list in both
//        directions.
//
//
//
// struct my_node {
//    DeclareLink( struct my_node );
//    // ...
// };
//
// that declares
//      struct my_node *next;  // the next node in list.
//      struct my_node **me;   // address of the pointer pointing to 'me';
//
//
//  struct my_node *root; // a root of a list of my_node.  It should be initialized to NULL.
//
//  struct my_node *newNode = (struct my_node*)malloc( sizeof( *newNode ) );
//     // does not require next or me to be initiialized.
//  LinkThing( root, newNode );
//     // now newNode is in the list.
//
//  to remove from a list
//
//  struct my_node *someNode; // this should be a pointer to some valid node.
//  UnlinkThing( someNode );
//     The new node is now not in the list.
//
//  To move one node from one list to another
//
//   struct my_node *rootAvail;  // available nodes
//   struct my_node *rootUsed;   // nodes in use
//
//   struct my_node *someNode; // some node in a list
//   someNode = rootAvail; // get first available.
//   if( !someNode ) ; // create a new one or abort
//   RelinkThing( rootUsed, someNode );
//      'someNode' is removed from its existing list, and added to the 'rootUsed' list.
//
// For Declaring the link structure members for lists
#define DeclareLink( type )  type *next; type **me
/* Link a new node into the list.
   Example
   struct mynode
   {
       DeclareLink( struct mynode );
   } *node;
	struct mynode *list;
   // node allocation not shown.
	LinkThing( list_root, node );
*/
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. LinkThing() inserts the new
 node as the new head of the list.
 this has to scan the list to find the end, so it is a O(n) operation.
 All other linked list operations are O(1)
 */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
// inserts 'node' after Thing
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
// similar to LinkThingAfter but puts the new 'thing'
// before the 'node' specified.
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
// move a list from one list to another.
// unlinks node from where it was, inserts at the head of another.
// this can also be use to reproiritize within the same list.
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink
 safe iterator macro that tests if node is valid, which returns
 the next item in the list, else returns NULL
 */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//----------- FLAG SETS (single bit fields) -----------------
/* the default type to use for flag sets - flag sets are arrays of bits
 which can be set/read with/as integer values an index.
 All of the fields in a maskset are the same width */
#define FLAGSETTYPE uintmax_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) )),1)
// clear a single flag index
#define RESETFLAG(v,n) ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) ),0)
// test if a flags is set
//  result is 0 or not; the value returned is the bit shifted within the word, and not always '1'
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
// return value is undefined... and is a whole bunch of flags from some offset...
// if you want ot toggle and flag and test the result, use TESTGOGGLEFLAG() instead.
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ))
// Toggle a bit, return the state of the bit after toggling.
#define TESTTOGGLEFLAG(v,n)  ( TOGGLEFLAG(v,n), TESTFLAG(v,n) )
//----------- MASK SETS -----------------
//  MASK Sets are arrays of bit-fields of some bit-width (5, 3, ... )
//  they are set/returned as integer values.
//  They are stored-in/accessed via a uint8_t which gives byte-offset calculations.
// they return their value as uintmax_t from the offset memory address directly;
//   Some platforms(Arm) may SIGBUS because of wide offset accesses spanning word boundaries.
//   This issue may be fixed by rounding, grabbing the word aligned values and shifting manually
// Declarataion/Instantiation of a mask set is done with MASKSET macro below
// 32 bits max for range on mask
#define MASK_MAX_LENGTH (sizeof(MASKSET_READTYPE)*CHAR_BIT)
/* gives a 32 bit mask possible from flagset..
 - updated; return max int possible; but only the low N bits will be set
 - mask sets are meant for small values, but could be used for like 21 bit fields. (another form of unicode encoding I suppose)
 */
#define MASKSET_READTYPE uintmax_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length)) & (sizeof(MASKSET_READTYPE) - 1) ) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set.
 MASKSET( maskVariableName
        , 32 //number of items
		  , 5 // number of bits per field
		  );
   declares
	uint8_t maskVariableName[ (32*5 +(CHAR_BIT-1))/CHAR_BIT ];  //data array used for storage.
   const int askVariableName_mask_size = 5;  // used aautomatically by macros
*/
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
/* set a field index to a value
    SETMASK( askVariableName, 3, 13 );  // set set member 3 to the value '13'
 */
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
/* get the value of a field
     GETMASK( maskVariableName, 3 );   // returns '13' given the SETMASK() example code.
 */
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
/* LIST is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX index) { return GetLink( &list, index ); }
} *piList;
#  endif
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
 //		namespace list;
	}
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
 //		namespace link_stack {
		}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
}
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
// this THis defines/initializes the data part of a PTEXT/TEXT structure.
// used with DECLTEXTSZTYPE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1  ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
#  include <strings.h>
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#  define stricmp strcasecmp
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a piece of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.
     allows +/- leadin ([-*]|[+*])*
     supports 0x### (hex), 0b#### (binary), 0o#### (octal), 0### (octal)
	 decimal 1-9[0-9]*
	 buggy implementation supports +/- inline continue number and are either ignored(+)
	 or changes the overall sign of the number(-).  A Decimal definatly ends the number.
	 And octal/binary digits aren't checked for range, so 8/9 will over-flow in octal,
	 and 2-9 overflow to upper bits in octal...
	    0b901090 // would be like   0b 10100110    0b1001 +  010 + 1001<<3 + 0
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Converts a text to the longest precision signed integer
   value.  Does the work of IntCreateFromText.
   IntCreateFromTextRef updates the pointer passed by reference so
   the pointer ends at the first character after the returned number.
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromTextRef( CTEXTSTR *p_ );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space " \t"
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history; negative indexes are recalled commands.
	int nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   int total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
}
 // namespace sack
}
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
//#include <construct.h> // pronounced 'kahn-struct'
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END } }
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//  returns the millisecond of the day (since UNIX Epoch) * 256 ( << 8 )
// the lowest 8 bits are the timezone / 15.
// The effect of the low [7/]8 bits being the time zone is that within the same millisecond
// UTC +0 sorts first, followed by +1, +2, ... etc until -14, -13, -12,... -1
// the low [7/]8 bits are the signed timezone
// (timezone could have been either be hr*60 + min (ISO TZ format)
// or in minutes (hr*60+mn) this would only take 7 bits
// one would think 8 bit shifts would be slightly more efficient than 7 bits.
// and sign extension for 8 bits already exists.
// - REVISION - timezone with hr*100 does not divide by 15 cleanly.
//     The timezone is ( hour*60 + min ) / 15 which is a range from -56 to 48
//     minimal representation is 7 bits (0 - 127 or -64 - 63)
//     still keeping 8 bits for shifting, so the effective range is only -56 to 48 of -128 to 127
// struct time_of_day {
//    uint64_t epoch_milliseconds : 56;
//    int64_t timezone : 8; divided by 15... hours * 60 / 15
// }
SYSLOG_PROC  int64_t SYSLOG_API GetTimeOfDay( void );
// binary little endian order; somewhat
typedef struct sack_expanded_time_tag
{
	uint16_t ms;
	uint8_t sc,mn,hr,dy,mo;
	uint16_t yr;
	int8_t zhr, zmn;
} SACK_TIME;
typedef struct sack_expanded_time_tag *PSACK_TIME;
// convert a integer time value to an expanded structure.
SYSLOG_PROC void     SYSLOG_API ConvertTickToTime( int64_t, PSACK_TIME st );
// convert a expanded time structure to a integer value.
SYSLOG_PROC int64_t SYSLOG_API ConvertTimeToTick( PSACK_TIME st );
// returns timezone as hours*100 + minutes.
// result is often negated?
SYSLOG_PROC  int SYSLOG_API GetTimeZone(void);
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  DefineRegistryMethod("SACK",_OnLibraryLoad,"system/library","load_event",name "_LoadEvent",void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#if defined( __MAC__ )
#  define strdup(s) StrDup(s)
#  define strdup_free(s) Release(s)
#else
#  define strdup_free(s) free(s)
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
	// these are not included without a special compile flag
	// only required by low level deveopers who may be against
   // undefined behavior.
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
}
 // namespace sack
}
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( "Picture Memory", "Picture.mem", 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, uintptr_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, uintptr_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,sizeof(type)*(count)))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( volatile uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( volatile uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( "look in this string", "in" );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( "look in this string" );
   TEXTCHAR *found = StrStr( writable_string, "in" );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
}
 // namespace sack
}
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifdef __LINUX__
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ )
#  if defined( __ANDROID__ ) || defined( EMSCRIPTEN ) || defined( __MAC__ )
// android > 21 can use pthread_mutex_timedop
#    define USE_PIPE_SEMS
#  else
//   Default behavior is to use pthread_mutex_timedlock for wakeable sleeps.
// no semtimedop; no semctl, etc
//#    include <sys/sem.h>
//originally used semctl; but that consumes system resources that are not
//cleaned up when the process exits.
#endif
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* Releases resources associated with a PTHREAD. For purposes of
   waking a thread, and providing a wakeable point for the
   thread, a system blocking event object is allocated, named
   with the THREAD_ID so it can be referenced by other
   processes. This is only allowed to be done by the thread
   itself.
   Parameters
   Param1 :  \Description
   Param2 :  \Description
   Example
   <code lang="c++">
   int main( void )
   {
       PTHREAD myself = MakeThread();
       // create threads, do stuff...
       UnmakeThread();
       At this point the pointer in 'myself' is invalid, and should be cleared.
       myself = NULL;
   }
   </code>                                                                      */
TIMER_PROC( void, UnmakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _WIN32
#  ifdef CONSOLE_SHELL
 // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#    define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#    define EndSaneWinMain() } }
#  else
#    define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#    define EndSaneWinMain() } }
#  endif
#else
#  if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#    define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#    define EndSaneWinMain()
#  else
#    define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#    define EndSaneWinMain() } }
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define snprintf _snprintf
#    define vsnprintf _vsnprintf
#    if defined( _UNICODE )
#      define tnprintf _snwprintf
#      define vtnprintf _vsnwprintf
#    else
#      define tnprintf _snprintf
#      define vtnprintf _vsnprintf
#    endif
#    define snwprintf _snwprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network {
	namespace jsox {
#endif
#ifdef JSOX_PARSER_SOURCE
#  define JSOX_PARSER_PROC(type,name) EXPORT_METHOD type name
#else
#  define JSOX_PARSER_PROC(type,name) IMPORT_METHOD type name
#endif
enum jsox_value_types {
	JSOX_VALUE_UNDEFINED = -1
	, JSOX_VALUE_UNSET = 0
 //= 1 no data
	, JSOX_VALUE_NULL
 //= 2 no data
	, JSOX_VALUE_TRUE
 //= 3 no data
	, JSOX_VALUE_FALSE
 //= 4 string
	, JSOX_VALUE_STRING
 //= 5 string + result_d | result_n
	, JSOX_VALUE_NUMBER
 //= 6 contains
	, JSOX_VALUE_OBJECT
 //= 7 contains
	, JSOX_VALUE_ARRAY
	// up to here is supported in JSON
 //= 8 no data
	, JSOX_VALUE_NEG_NAN
 //= 9 no data
	, JSOX_VALUE_NAN
 //= 10 no data
	, JSOX_VALUE_NEG_INFINITY
 //= 11 no data
	, JSOX_VALUE_INFINITY
  // = 12 comes in as a number, string is data.
	, JSOX_VALUE_DATE
 // = 13 string data, needs bigint library to process...
	, JSOX_VALUE_BIGINT
 // = 14 no data; used in [,,,] as place holder of empty
	, JSOX_VALUE_EMPTY
  // = 15 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY
  // = 14 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY_MAX = JSOX_VALUE_TYPED_ARRAY +12
};
struct jsox_value_container {
  // name of this value (if it's contained in an object)
	char * name;
	size_t nameLen;
 // value from above indiciating the type of this value
	enum jsox_value_types value_type;
   // the string value of this value (strings and number types only)
	char *string;
	size_t stringLen;
  // boolean whether to use result_n or result_d
	int float_result;
	union {
		double result_d;
		int64_t result_n;
		//struct json_value_container *nextToken;
	};
  // list of struct json_value_container that this contains.
	PDATALIST contains;
  // acutal source datalist(?)
	PDATALIST *_contains;
  // if VALUE_OBJECT or VALUE_TYPED_ARRAY; this may be non NULL indicating what the class name is.
	char *className;
};
// allocates a JSOX parsing context and is prepared to begin parsing data.
JSOX_PARSER_PROC( struct jsox_parse_state *, jsox_begin_parse )(void);
// clear state; after an error state, this can allow reusing a state.
JSOX_PARSER_PROC( void, jsox_parse_clear_state )( struct jsox_parse_state *state );
// get actual allocated root for a value... allows holding that.
JSOX_PARSER_PROC( const char *, jsox_get_parse_buffer )(struct jsox_parse_state *pState, const char *buf);
// destroy current parse state.
JSOX_PARSER_PROC( void, jsox_parse_dispose_state )(struct jsox_parse_state **ppState);
// return >0 when a completed value/object is available.
// after returning >0, call json_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns 0, then ther is no further object
// to retrieve.  If this return -1 there was an error, and use jsox_parse_get_error() to
// retrieve the error text.
JSOX_PARSER_PROC( int, jsox_parse_add_data )(struct jsox_parse_state *context
	, const char * msg
	, size_t msglen
	);
JSOX_PARSER_PROC( PTEXT, jsox_parse_get_error )(struct jsox_parse_state *state);
JSOX_PARSER_PROC( PDATALIST, jsox_parse_get_data )(struct jsox_parse_state *context);
// single all-in-one parsing of an input buffer.
JSOX_PARSER_PROC( LOGICAL, jsox_parse_message )(const char * msg
	, size_t msglen
	, PDATALIST *msg_data_out
	);
// release all resources of a message from jsox_parse_message or jsox_parse_get_data
JSOX_PARSER_PROC( void, jsox_dispose_message )(PDATALIST *msg_data);
JSOX_PARSER_PROC( struct jsox_parse_state *, jsox_get_messge_parser )(void);
JSOX_PARSER_PROC( char *, jsox_escape_string_length )(const char *string, size_t len, size_t *outlen);
JSOX_PARSER_PROC( char *, jsox_escape_string )(const char *string);
/*
	jsox_get_pared_value()
	takes a parsed message data list as a parameer, and a path.
	A message may have been parsed into multiple parts.  This
	early version will return just the first value in the datalist.
	If there is an optional `path` specified, then that is used to
	step through the JSOX parsed structure to get deeper values.
	Path is specified as a list of fieldnames and array index numbers.
	optional separator characters may be used between members '.', ' ', '/' and '\'.
	Separator characters may be repeated or mixed with other seaprators and are all
	considered a single separation.
	optional bracket characters around an array index may be used     [0]    is often as good as 0.
	Some example paths
		messages[0]from
		messages.0.from
		messages [0] from
		messages [0] lines[0]
	{ messages : [ // array of messages
	    { from : "someone", lines: [ "lines","of","message"] }
	  ]
	}
	jsox_get_parsed_value() returns a value from a PDATALIST
	jsox_get_parsed_object_value() and jsox_get_parsed_array_value() :  returns a value from a value member.
*/
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_value )(PDATALIST pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_object_value )(struct jsox_value_container *pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_array_value )(struct jsox_value_container * pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
#ifdef __cplusplus
} } SACK_NAMESPACE_END
using namespace sack::network::jsox;
#endif
#endif
#define JSOX_PARSER_SOURCE
#define JSOX_PARSER_MAIN_SOURCE
#define DEADSTART_ROOT_OPTION_THING
#ifndef DEADSTART_DEFINED
#define DEADSTART_DEFINED
#ifdef WIN32
//#include <stdhdrs.h>
#endif
 // leach, assuming this will be compiled with this part at least.
#define pastejunk_(a,b) a##b
#define pastejunk(a,b) pastejunk_(a,b)
#ifdef __cplusplus
#define USE_SACK_DEADSTART_NAMESPACE using namespace sack::app::deadstart;
#define SACK_DEADSTART_NAMESPACE   SACK_NAMESPACE namespace app { namespace deadstart {
#define SACK_DEADSTART_NAMESPACE_END    } } SACK_NAMESPACE_END
SACK_NAMESPACE
	namespace app{
/* Application namespace. */
/* These are compiler-platform abstractions to provide a method
   of initialization that allows for creation of threads, and
   transparent (easy to use) method of scheduling routines for
   initialization.
   Example
   This schedules a routine to run at startup. Fill in the
   routine with the code you want, and it will run at
   DEFAULT_PRELOAD_PRIORITY which is the number 69.
   <code lang="c++">
   PRELOAD( MyCustomInit )
   {
       // do something here (do anything here,
       // without limitations that are imposed by DllMain/LibMain.
   }
   </code>
   If you wanted a routine which was guaranteed to run before
   MyCustomInit you might use PRIORITY_PRELOAD whcih allows you
   to specify a priority.
   <code lang="c++">
   PRIORITY_PRELOAD( MyOtherInit, DEFAULT_PRELOAD_PRIORITY-10 )
   {
      // this will run before other things.
   }
   </code>
   Priorities are listed in deadstart.h and exit_priorities.h. The
   priorities are treated backwards, so low number startup
   priorities go first, and higher number shutdown priorities go
   first.
   Remarks
   In some compilers and compile modes this is also fairly easy
   to do. A lot of compilers do not offer priority, and are
   impossible to maintain an order in. Some compilers only
   provide startup priority for C++ mode. This system works as
   \long as there is a way to run a single function at some
   point before main() and after C runtime initializes.
   In Windows, you might think you have this ability with
   DllMain, but there are severe limitations that you would have
   to get around; primary is the inability to create a thread,
   well, you can create it, but it will remain suspended until
   you leave DllMains and all DllMains finish. There is also no
   way to consistantly provide initialization order, like memory
   needs to be initialized before anything else.
                                                                   */
		namespace deadstart {
#else
#define USE_SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE_END
#endif
#ifdef TYPELIB_SOURCE
#define DEADSTART_SOURCE
#endif
/* A macro to specify the call type of schedule routines. This
   can be changed in most projects without affect, it comes into
   play if plugins built by different compilers are used,
   __cdecl is most standard.                                     */
#define DEADSTART_CALLTYPE CPROC
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define DEADSTART_PROC extern
#  elif defined( _TYPELIBRARY_SOURCE )
#    define DEADSTART_PROC EXPORT_METHOD
#  else
/* A definition for how to declare these functions. if the
   source itself is comipling these are _export, otherwise
   external things linking here are _import.               */
#    define DEADSTART_PROC IMPORT_METHOD
#  endif
   /* this is just a global space initializer (shared, named
      region, allows static link plugins to share information)
      Allocates its shared memory global region, so if this library
      is built statically and referenced in multiple plugins
      ConfigScript can share the same symbol tables. This also
      provides sharing between C++ and C.                           */
#define CONFIG_SCRIPT_PRELOAD_PRIORITY    (SQL_PRELOAD_PRIORITY-3)
   // this is just a global space initializer (shared, named region, allows static link plugins to share information)
#define SQL_PRELOAD_PRIORITY    (SYSLOG_PRELOAD_PRIORITY-1)
/* Level at which logging is initialized. Nothing under this
   should be doing logging, if it does, the behavior is not as
   well defined.                                               */
#define SYSLOG_PRELOAD_PRIORITY 35
   // global_init_preload_priority-1 is used by sharemem.. memory needs init before it can register itself
#define GLOBAL_INIT_PRELOAD_PRIORITY 37
 // OS A[bstraction] L[ayer] O[n] T[op] - system lib
#define OSALOT_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
/* Level which names initializes. Names is the process
   registration code. It has a common shared global registered.
   <link sack::app::registry, procreg; aka names.c>             */
#define NAMESPACE_PRELOAD_PRIORITY 39
/* image_preload MUST be after Namespce preload (anything that
   uses RegisterAndCreateGlobal) should init this before vidlib
   (which needs image?)                                         */
#define IMAGE_PRELOAD_PRIORITY  45
/* Level at which the video render library performs its
   initialization; RegisterClass() level code.          */
#define VIDLIB_PRELOAD_PRIORITY 46
/* Initialization level where PSI registers its builtin
   controls.                                            */
#define PSI_PRELOAD_PRIORITY    47
// need to open the queues and threads before the service server can begin...
#define MESSAGE_CLIENT_PRELOAD_PRIORITY 65
/* Level which message core service initializes. During startup
   message services can register themselves also; but not before
   this priority level.                                          */
#define MESSAGE_SERVICE_PRELOAD_PRIORITY 66
/* Routines are scheduled at this priority when the PRELOAD
   function is used.                                        */
#define DEFAULT_PRELOAD_PRIORITY (DEADSTART_PRELOAD_PRIORITY-1)
/* Not sure where this is referenced, this the core routine
   itself is scheduled with this symbol to the compiler if
   appropriate.                                             */
#define DEADSTART_PRELOAD_PRIORITY 70
#define PRIORITY_UNLOAD(proc,priority) PRIORITY_ATEXIT( proc##_unload, priority )
/* Used by PRELOAD and PRIORITY_PRELOAD macros to register a
   startup routine at a specific priority. Lower number
   priorities are scheduled to run before higher number
   priorities*backwards from ATEXIT priorities*. Using this
   scheduling mechanisms, routines which create threads under
   windows are guaranteed to run before main, and are guaranteed
   able to create threads. (They are outside of the loader lock)
   Parameters
   function :  pointer to a function to call at startup.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityStartupProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* Used by ATEXIT and PRIORITY_ATEXIT macros to register a
   shutdown routine at a specific priority. Higher number
   priorities are scheduled to run before lower number
   priorities. *backwards from PRELOAD priorities* This
   registers functions which are run while the program exits if
   it is at all able to run when exiting. calling exit() or
   BAG_Exit() will invoke these.
   Parameters
   function :  pointer to a function to call at shutdown.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityShutdownProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* This routine is used internally when LoadFunction is called.
   After MarkDeadstartComplete is called, any call to a
   RegisterPriorityStartupProc will call the startup routine
   immediately instead of waiting. This function disables the
   auto-running of this function, and instead enques the startup
   to the list of startups. When completed, at some later point,
   call ResumeDeadstart() to dispatched all scheduled routines,
   and release the suspend; however, if initial deastart was not
   dispatched, then ResumeDeadstart does not do the invoke, it
   only releases the suspend.                                    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  SuspendDeadstart ( void );
/* Resumes a suspended deadstart. If root deadstart is
   completed, then ResumeDeadstart will call InvokeDeadstarts
   after resuming deadstart.                                  */
DEADSTART_PROC  void DEADSTART_CALLTYPE  ResumeDeadstart ( void );
/* Not usually used by user code, but this invokes all the
   routines which have been scheduled to run for startup. If
   your compiler doesn't have a method of handling deadstart
   code, this can be manually called. It can also be called if
   you loaded a library yourself without using the LoadFunction
   interface, to invoke startups scheduled in the loaded
   library.                                                     */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeDeadstart (void);
/* This just calls the list of shutdown procedures. This should
   not be used usually from user code, since internally this is
   handled by catching atexit() or with a static destructor.    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeExits (void);
/* This is typically called after the first InvokeDeadstarts
   completes. The code that runs this is usually a routine just
   before main(). So once code in main begins to run, all prior
   initialization has been performed.                           */
DEADSTART_PROC  void DEADSTART_CALLTYPE  MarkRootDeadstartComplete ( void );
/* \returns whether InvokeDeadstarts has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartStarted ( void );
/* \returns whether MarkRootDeadstartComplete has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartComplete ( void );
#if defined( __LINUX__ )
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef DOC_O_MAT
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef __cplusplus
/* Defines some code to run at program inialization time. Allows
   specification of a priority. Lower priorities run first. (default
   is 69).
   Example
   <code>
   PRIORITY_PRELOAD( MyOtherInit, 153 )
   {
      // run some code probably after most all other initializtion is done.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                         */
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityStartupProc( name,TOSTR(name),priority,(void*)this DBG_SRC);	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* This is used once in deadstart_prog.c which is used to invoke
   startups when the program finishes loading.                   */
#define MAGIC_PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {	     public:pastejunk(schedule_,name)() {	  name();	    }	  } pastejunk(do_schedul_,name);	     static void name(void)
/* A macro to define some code to run during program shutdown. An
   additional priority may be specified if the order matters. Higher
   numbers are called first.
                                                                     */
#define ATEXIT_PRIORITY(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* Defines some code to run at program shutdown time. Allows
   specification of a priority. Higher priorities are run first.
   Example
   <code>
   PRIORITY_ATEXIT( MyOtherShutdown, 153 )
   {
      // run some code probably before most library code dissolves.
      // last to load, first to unload.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                 */
	/*name(); / * call on destructor of static object.*/
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static class pastejunk(shutdown_,name) {	   public:pastejunk(shutdown_,name)() {       RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	   }	  } do_shutdown_##name;	     void name(void)
/* This is the most basic way to define some code to run
   initialization before main.
   Example
   <code lang="c++">
   PRELOAD( MyInitCode )
   {
      // some code here
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>      */
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
/* Basic way to register a routine to run when the program exits
   gracefully.
   Example
   \    <code>
   ATEXIT( MyExitRoutine )
   {
       // this will be run sometime during program shutdown
   }
   </code>                                                       */
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
/* This is the core atexit. It dispatches all other exit
   routines. This is defined for internal use only...    */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
//------------------------------------------------------------------------------------
// Win32 Watcom
//------------------------------------------------------------------------------------
#elif defined( __WATCOMC__ )
#pragma off (check_stack)
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_pad;
typedef void(*__type_rtn ) ( void );
#ifdef __cplusplus
#pragma pack(1)
#else
#pragma pack(1)
#endif
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
      // - routine
    __type_rtn  rtn;
};
#pragma pack()
/* end code taken from openwatcom/bld/watcom/h/rtinit.h */
//------------------------------------------------------------------------------------
// watcom
//------------------------------------------------------------------------------------
//void RegisterStartupProc( void (*proc)(void) );
#define PRIORITY_PRELOAD(name,priority) static void pastejunk(schedule_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_ctor_label)={0,(DEADSTART_PRELOAD_PRIORITY-1),pastejunk(schedule_,name)};	 static void pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,&pastejunk(name,_ctor_label) DBG_SRC );	}	                                       void name(void)
#define ATEXIT_PRIORITY(name,priority) static void pastejunk(schedule_exit_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_dtor_label)={0,69,pastejunk(schedule_exit_,name)};	 static void pastejunk(schedule_exit_,name)(void) {	                                              RegisterPriorityShutdownProc( name,TOSTR(name),priority,&name##_dtor_label DBG_SRC );	}	                                       void name(void)
// syslog runs preload at priority 65
// message service runs preload priority 66
// deadstart itself tries to run at priority 70 (after all others have registered)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
// this is a special case macro used in client.c
// perhaps all PRIORITY_ATEXIT routines should use this
// this enables cleaning up things that require threads to be
// active under windows... (message disconnect)
// however this routine is only triggered in windows by calling
// BAG_Exit(nn) which is aliased to replace exit(n) automatically
#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY( name,priority)
/*
static void name(void); static void name##_x_(void);	static struct rt_init __based(__segname("YI")) name##_dtor_label={0,priority,name##_x_};	 static void name##_x_(void) { char myname[256];myname[0]=*(CTEXTSTR)&name##_dtor_label;GetModuleFileName(NULL,myname,sizeof(myname));name(); }	 static void name(void)
  */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
// if priority_atexit is used with priority 0 - the proc is scheduled into
// atexit, and exit() is then invoked.
//#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY(name,priority )
//------------------------------------------------------------------------------------
// Linux
//------------------------------------------------------------------------------------
#elif defined( __GNUC__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __64__ ) ||defined( __arm__ )||defined( __GNUC__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	 CTEXTSTR file;
#endif
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#if defined( __GNUC__ ) && defined( __64__)
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
#endif
} __attribute__((packed));
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  if defined( __GNUC__ ) && defined( __64__)
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label), {0,0}
#  else
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#  endif
#else
#  define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#endif
#define RTINIT_STATIC static
#define ATEXIT_PRIORITY PRIORITY_ATEXIT
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#ifdef __MAC__
#  define DEADSTART_SECTION "TEXT,deadstart_list"
#else
#  define DEADSTART_SECTION "deadstart_list"
#endif
#ifdef __MANUAL_PRELOAD__
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)		__attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 =	 {0,0,pr INIT_PADDING, __LINE__, name PASS_FILENAME	, TOSTR(name) JUNKINIT(name)} ;	 void name(void);	 void pastejunk(registerStartup,name)(void) __attribute__((constructor));	 void pastejunk(registerStartup,name)(void) {	 RegisterPriorityStartupProc(name,TOSTR(name),pr,NULL DBG_SRC); }	 void name(void)
#else
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)	   __attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 void name(void) __attribute__((used));	  void name(void)
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void name(void); static void pastejunk(atexit,name)(void) __attribute__((constructor));  void pastejunk(atexit,name)(void)                                                  {	                                                                        RegisterPriorityShutdownProc(name,TOSTR(name),priority,NULL DBG_SRC);                          }                                                                          void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT( name,ATEXIT_PRIORITY_DEFAULT )
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// CYGWIN (-mno-cygwin)
//------------------------------------------------------------------------------------
#elif defined( __CYGWIN__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#ifdef __cplusplus
	//rt_init( int _rtn_type ) { rt_init::rtn_type = _rtn_type; }
	/*rt_init( int _priority, CTEXTSTR name, __type_rtn rtn, CTEXTSTR _file, int _line )
	{
		rtn_type = 0;
		scheduled = 0;
		priority = priority;
		file = _file;
		line = _line;
      routine = rtn;
		}
      */
#endif
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __GNUC__ ) || defined( __64__ ) || defined( __arm__ ) || defined( __CYGWIN__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
	 CTEXTSTR file;
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( __GNUC__ ) && defined( __64__ )
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#ifdef __cplusplus
#define RTINIT_STATIC
#else
#define RTINIT_STATIC static
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define ATEXIT_PRIORITY(name,priority) static void name(void); static void atexit##name(void) __attribute__((constructor));	  void atexit_failed##name(void(*f)(void),int i,CTEXTSTR s1,CTEXTSTR s2,int n) { lprintf( "Failed to load atexit_priority registerar from core program." );} void atexit##name(void)                                                  {	                                                                        static char myname[256];HMODULE mod;if(myname[0])return;myname[0]='a';GetModuleFileName( NULL, myname, sizeof( myname ) );	mod=LoadLibrary(myname);if(mod){   typedef void (*x)(void);void(*rsp)( x,const CTEXTSTR,int,const CTEXTSTR,int);	 if((rsp=((void(*)(void(*)(void),const CTEXTSTR,int,const CTEXTSTR,int))(GetProcAddress( mod, "RegisterPriorityShutdownProc")))))	 {rsp( name,TOSTR(name),priority DBG_SRC);}	 else atexit_failed##name(name,priority,TOSTR(name) DBG_SRC);	        }     FreeLibrary( mod);	 }             void name( void)
#ifdef _DEBUG
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct pastejunk(rt_init name,_ctor_label)	   __attribute__((section("deadstart_list")))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 static void name(void)
#define ATEXIT(name)      ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_DEFAULT)
#define PRIORITY_ATEXIT ATEXIT_PRIORITY
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// WIN32 MSVC
//------------------------------------------------------------------------------------
#elif defined( _MSC_VER ) && defined( _WIN32 )
//#define PRELOAD(name) __declspec(allocate(".CRT$XCAA")) void CPROC name(void)
//#pragma section(".CRT$XCA",long,read)
//#pragma section(".CRT$XCZ",long,read)
// put init in both C startup and C++ startup list...
// looks like only one or the other is invoked, not both?
/////// also the variables to be put into these segments
#if defined( __cplusplus_cli )
#define LOG_ERROR(n) System::Console::WriteLine( gcnew System::String(n) + gcnew System::String( myname) ) )
#else
#define LOG_ERROR(n) SystemLog( n )
// since we get linked first, then the runtime is added, we have to link against the last indicator of section,
// so we get put between start to end.
#define _STARTSEG_ ".CRT$XIM"
#define _STARTSEG2_ ".CRT$XCY"
#define _ENDSEG_ ".CRT$XTM"
//#pragma data_seg(".CRT$XIA")
#pragma data_seg(".CRT$XIM")
#pragma section(".CRT$XIM",long,read)
#pragma data_seg(".CRT$XCY")
#pragma section(".CRT$XCY",long,read)
//#pragma data_seg(".CRT$XIZ")
//#pragma data_seg(".CRT$YCZ")
#pragma data_seg(".CRT$XTM")
#pragma section(".CRT$XTM",long,read)
#pragma data_seg()
	                                       /*static __declspec(allocate(_STARTSEG_)) void (CPROC*pointer_##name)(void) = pastejunk(schedule_,name);*/
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static int CPROC pastejunk(schedule_,name)(void);	   __declspec(allocate(_STARTSEG_)) int (CPROC*pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)))(void) = pastejunk(schedule_,name);	 int CPROC pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)) DBG_SRC );	return 0;	 }	 static void CPROC name(void)
#define ROOT_ATEXIT(name) static void name(void);	 __declspec(allocate(_ENDSEG_)) static void (*f##name)(void)=name;    static void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
typedef void(*atexit_priority_proc)(void (*)(void),int,CTEXTSTR DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static int schedule_atexit_##name(void);	   __declspec(allocate(_STARTSEG_)) void (CPROC*pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)))(void) = (void(CPROC*)(void))schedule_atexit_##name;	 static int schedule_atexit_##name(void) {	                 RegisterPriorityShutdownProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)) DBG_SRC );	return 0;	 }	                                       static void CPROC name(void)
#define ATEXIT_PRIORITY(name,priority) PRIORITY_ATEXIT(name,priority)
#endif
#ifdef __cplusplus_cli
#define InvokeDeadstart() do {	                                              TEXTCHAR myname[256];HMODULE mod;	 mod=LoadLibrary("sack_bag.dll");if(mod){           void(*rsp)(void);	 if((rsp=((void(*)(void))(GetProcAddress( mod, "RunDeadstart"))))){rsp();}else{lprintf( "Hey failed to get proc %d", GetLastError() );}	FreeLibrary( mod); }} while(0)
#else
#endif
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//extern uint32_t deadstart_complete;
//#define DEADSTART_LINK uint32_t *deadstart_link_couple = &deadstart_complete; // make sure we reference this symbol
//#pragma data_seg(".CRT$XCAA")
//extern void __cdecl __security_init_cookie(void);
//static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
//#pragma data_seg()
//------------------------------------------------------------------------------------
// UNDEFINED
//------------------------------------------------------------------------------------
#else
#error "there's nothing I can do to wrap PRELOAD() or ATEXIT()!"
/* This is the most basic way to define some startup code that
   runs at some point before the program starts. This code is
   declared as static, so the same preload initialization name
   can be used in multiple files.
   <link sack::app::deadstart, See Also.>                      */
#define PRELOAD(name)
#endif
// the higher the number the earlier it is run
#define ATEXIT_PRIORITY_SHAREMEM  1
#define ATEXIT_PRIORITY_THREAD_SEMS ATEXIT_PRIORITY_SYSLOG-1
#define ATEXIT_PRIORITY_SYSLOG    35
#define ATEXIT_PRIORITY_MSGCLIENT 85
#define ATEXIT_PRIORITY_DEFAULT   90
#define ATEXIT_PRIORITY_TIMERS   (ATEXIT_PRIORITY_DEFAULT+1)
// this is the first exit to be run.
// under linux it is __attribute__((destructor))
// under all it is registered during preload as atexit()
// only the runexits in deadstart should use ROOT_ATEXIT
#ifdef __WATCOMC__
#define ATEXIT_PRIORITY_ROOT 255
#else
#define ATEXIT_PRIORITY_ROOT 101
#endif
SACK_DEADSTART_NAMESPACE_END
USE_SACK_DEADSTART_NAMESPACE
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace jsox {
#endif
#if JSOX_EMITTER_WORKS
struct json_context_object_element
{
     // type of the element at this offset
	enum JSON_ObjectElementTypes type;
     // type of the element at this offset
	enum JSON_ObjectElementTypes content_type;
  // how big this element is.
	size_t object_size;
   // offset into the structure
	size_t offset;
 // name of this element in the object
	CTEXTSTR name;
 // at offset, this number of these is there; (array)
	size_t count;
 // at count_offset, is the number of elements that the pointer at this offset
	size_t count_offset;
	void (*user_formatter)(PVARTEXT pvt_output,CPOINTER msg_data);
	struct json_context_object *object;
};
struct json_context_object
{
	struct json_context *context;
   // list of members of this object struct json_context_object_element *
	PLIST members;
 // if set is an array format, otherwise is an object format.
	int is_array;
	size_t object_size;
	size_t offset;
	struct json_context_object_flags
	{
  // this is not a root object
		BIT_FIELD keep_phrase : 1;
		BIT_FIELD dynamic_size : 1;
	} flags;
	struct json_context_object *parent;
};
struct json_context
{
	int levels;
	PVARTEXT pvt;
	PLIST object_types;
	int human_readable;
};
#endif
enum jsox_word_char_states {
 // not in a keyword
	JSOX_WORD_POS_RESET = 0,
  // at end of a word, waiting for separator
	JSOX_WORD_POS_END,
	JSOX_WORD_POS_TRUE_1,
	JSOX_WORD_POS_TRUE_2,
	JSOX_WORD_POS_TRUE_3,
	//JSOX_WORD_POS_TRUE_4,
 // 11
	JSOX_WORD_POS_FALSE_1,
	JSOX_WORD_POS_FALSE_2,
	JSOX_WORD_POS_FALSE_3,
	JSOX_WORD_POS_FALSE_4,
 // 21  get u
	JSOX_WORD_POS_NULL_1,
 //  get l
	JSOX_WORD_POS_NULL_2,
 // 10 get l
	JSOX_WORD_POS_NULL_3,
  // 31
	JSOX_WORD_POS_UNDEFINED_1,
	JSOX_WORD_POS_UNDEFINED_2,
	JSOX_WORD_POS_UNDEFINED_3,
	JSOX_WORD_POS_UNDEFINED_4,
	JSOX_WORD_POS_UNDEFINED_5,
	JSOX_WORD_POS_UNDEFINED_6,
	JSOX_WORD_POS_UNDEFINED_7,
	JSOX_WORD_POS_UNDEFINED_8,
	//JSOX_WORD_POS_UNDEFINED_9, // instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_NAN_1,
  // 20
	JSOX_WORD_POS_NAN_2,
	//JSOX_WORD_POS_NAN_3,// instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_INFINITY_1,
	JSOX_WORD_POS_INFINITY_2,
	JSOX_WORD_POS_INFINITY_3,
	JSOX_WORD_POS_INFINITY_4,
	JSOX_WORD_POS_INFINITY_5,
	JSOX_WORD_POS_INFINITY_6,
	JSOX_WORD_POS_INFINITY_7,
	//JSOX_WORD_POS_INFINITY_8,// instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_FIELD,
	JSOX_WORD_POS_AFTER_FIELD,
 // 30
	JSOX_WORD_POS_DOT_OPERATOR,
	JSOX_WORD_POS_PROPER_NAME,
	JSOX_WORD_POS_AFTER_PROPER_NAME,
	JSOX_WORD_POS_AFTER_GET,
	JSOX_WORD_POS_AFTER_SET,
  //36
	JSOX_WORD_POS_CLASS_NAME,
 // 37
	JSOX_WORD_POS_CLASS_VALUES,
};
enum jsox_parse_context_modes {
	JSOX_CONTEXT_UNKNOWN = 0,
	JSOX_CONTEXT_IN_ARRAY = 1,
	//JSOX_CONTEXT_IN_OBJECT = 2,
	JSOX_CONTEXT_OBJECT_FIELD = 3,
	JSOX_CONTEXT_OBJECT_FIELD_VALUE = 4,
	JSOX_CONTEXT_CLASS_FIELD = 5,
	JSOX_CONTEXT_CLASS_VALUE = 6,
 // same as OBJECT_FIELD_VALUE; but within a CLASS_VALUE state
	JSOX_CONTEXT_CLASS_FIELD_VALUE = 7,
};
#define JSOX_RESET_VAL()  {	  val.value_type = JSOX_VALUE_UNSET;	 val.contains = NULL;	              val._contains = NULL;	             val.name = NULL;	                  val.string = NULL;	                val.className = NULL;	             negative = FALSE; }
#define JSOX_RESET_STATE_VAL()  {	  state->val.value_type = JSOX_VALUE_UNSET;	 state->val.contains = NULL;	              state->val._contains = NULL;	             state->val.name = NULL;	                  state->val.string = NULL;	                state->val.className = NULL;	             state->negative = FALSE; }
struct jsox_input_buffer {
      // prior input buffer
	char const * buf;
 // size of prior input buffer
	size_t       size;
  // last position in _input if context closed before end of buffer
	char const * pos;
	LOGICAL      tempBuf;
};
struct jsox_output_buffer {
      // prior input buffer
	char * buf;
 // size of prior input buffer
	size_t  size;
  // last position in _input if context closed before end of buffer
	char * pos;
	LOGICAL      unusedTempBuf;
};
typedef struct jsox_input_buffer JSOX_PARSE_BUFFER, *PJSOX_PARSE_BUFFER;
#define MAXJSOX_PARSE_BUFFERSPERSET 128
DeclareSet( JSOX_PARSE_BUFFER );
struct jsox_class_field {
	char *name;
	size_t nameLen;
};
typedef struct jsox_class_field JSOX_CLASS_FIELD, *PJSOX_CLASS_FIELD;
#define MAXJSOX_CLASS_FIELDSPERSET 128
DeclareSet( JSOX_CLASS_FIELD );
struct jsox_class_type {
	char *name;
	size_t nameLen;
	PLIST fields;
};
typedef struct jsox_class_type JSOX_CLASS, *PJSOX_CLASS;
#define MAXJSOX_CLASSSPERSET 128
DeclareSet( JSOX_CLASS );
struct jsox_parse_context {
	enum jsox_parse_context_modes context;
	PDATALIST *elements;
	char *name;
	size_t nameLen;
	struct jsox_value_container valState;
	//struct jsox_context_object *object;
	PJSOX_CLASS current_class;
	int current_class_item;
	int arrayType;
};
typedef struct jsox_parse_context JSOX_PARSE_CONTEXT, *PJSOX_PARSE_CONTEXT;
#define MAXJSOX_PARSE_CONTEXTSPERSET 128
DeclareSet( JSOX_PARSE_CONTEXT );
// this is the stack state that can be saved between parsing for streaming.
struct jsox_parse_state {
	//TEXTRUNE c;
	PDATALIST *elements;
 //
	PLINKSTACK *outBuffers;
 // matches input queue
	PLINKQUEUE *outQueue;
	PLIST *outValBuffers;
	//TEXTSTR mOut;// = NewArray( char, msglen );
	size_t line;
	size_t col;
 // character index;
	size_t n;
	//size_t _n = 0; // character index; (restore1)
	enum jsox_word_char_states word;
	LOGICAL status;
	LOGICAL negative;
	LOGICAL literalString;
	PLINKSTACK *context_stack;
	PLIST classes;
	PJSOX_CLASS current_class;
	int current_class_item;
	int arrayType;
	LOGICAL first_token;
	PJSOX_PARSE_CONTEXT context;
	enum jsox_parse_context_modes parse_context;
	struct jsox_value_container val;
	int comment;
	TEXTRUNE operatorAccum;
	PLINKQUEUE *inBuffers;
	//char const * input;     // current input buffer start
	//char const * msg_input; // current input buffer position (incremented while reading)
	LOGICAL completed;
	LOGICAL complete_at_end;
	LOGICAL gatheringString;
	LOGICAL completedString;
	TEXTRUNE gatheringStringFirstChar;
	TEXTRUNE gatheringCodeLastChar;
	int codeDepth;
	LOGICAL gatheringNumber;
	LOGICAL numberExponent;
	LOGICAL numberFromHex;
	LOGICAL numberFromDate;
	LOGICAL numberFromBigInt;
	PVARTEXT pvtError;
	LOGICAL fromHex;
	LOGICAL exponent;
	LOGICAL exponent_sign;
	LOGICAL exponent_digit;
	LOGICAL escape;
	LOGICAL cr_escaped;
	LOGICAL unicodeWide;
	LOGICAL stringUnicode;
	LOGICAL stringHex;
	TEXTRUNE hex_char;
	int hex_char_len;
	LOGICAL stringOct;
	LOGICAL weakSpace;
	PDATALIST root;
	//char *token_begin;
};
typedef struct jsox_parse_state JSOX_PARSE_STATE, *PJSOX_PARSE_STATE;
#define MAXJSOX_PARSE_STATESPERSET 32
DeclareSet( JSOX_PARSE_STATE );
#ifndef JSON_PARSER_INCLUDED
typedef PLIST *PPLIST;
#define MAXPLISTSPERSET 256
DeclareSet( PLIST );
typedef PLINKSTACK *PPLINKSTACK;
#define MAXPLINKSTACKSPERSET 256
DeclareSet( PLINKSTACK );
typedef PLINKQUEUE *PPLINKQUEUE;
#define MAXPLINKQUEUESPERSET 256
DeclareSet( PLINKQUEUE );
typedef PDATALIST *PPDATALIST;
#define MAXPDATALISTSPERSET 256
DeclareSet( PDATALIST );
#endif
struct jsox_parser_shared_data {
	PJSOX_PARSE_CONTEXTSET parseContexts;
	PJSOX_PARSE_BUFFERSET parseBuffers;
	struct jsox_parse_state *last_parse_state;
	PJSOX_PARSE_STATESET parseStates;
	PPLISTSET listSet;
	PPLINKSTACKSET linkStacks;
	PPLINKQUEUESET linkQueues;
	PPDATALISTSET dataLists;
	PJSOX_CLASSSET  classes;
	PJSOX_CLASS_FIELDSET  class_fields;
 // static parsing state for simple message interface.
	struct jsox_parse_state *_state;
};
#ifndef JSOX_PARSER_MAIN_SOURCE
extern
#endif
struct jsox_parser_shared_data jxpsd;
void _jsox_dispose_message( PDATALIST *msg_data );
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
static struct unicodeNonIdentifierBitSet{ int firstChar, lastChar; int bits[16]; } nonIdentifierBits[] =
{ { 0,384,{ 0xffd9ff,0xff6aff,0x1fc00,0x380000,0x0,0xfffff8,0xffffff,0x7fffff,0x800000,0x0,0x80,0x0,0x0,0x0,0x0,0x0 } },
{ 384,768,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00,0xe0fffc,0xffffaf } },
{ 768,1152,{ 0x0,0x0,0x0,0x0,0x200000,0x3040,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0 } },
{ 1152,1536,{ 0x304,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc,0x0,0xe6,0x0,0x4940,0x0,0x1800 } },
{ 1536,1920,{ 0xffff,0xd8,0x0,0x0,0x3c00,0x0,0x0,0x0,0x100000,0x20060,0xff6000,0xbf,0x0,0x0,0x0,0x0 } },
{ 1920,2304,{ 0x0,0x0,0x0,0x0,0xc00000,0x3,0x0,0x7fff00,0x0,0x40,0x0,0x0,0x0,0x0,0x40000,0x0 } },
{ 2304,2688,{ 0x0,0x0,0x0,0x0,0x10030,0x0,0x0,0x0,0x0,0x0,0x2ffc,0x0,0x0,0x0,0x0,0x0 } },
{ 2688,3072,{ 0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0xfd,0x0,0x0,0x0,0x0,0x7ff00 } },
{ 3072,3456,{ 0x0,0x0,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x7f00,0x3ff00 } },
{ 3456,3840,{ 0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x800000,0x8000,0xc,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 3840,4224,{ 0xfffffe,0xfc00fc,0x3d5f,0x0,0x0,0x2000,0x0,0xc00000,0xffdfbf,0x7,0x0,0x0,0x0,0xfc0000,0x0,0x0 } },
{ 4224,4608,{ 0x0,0xc0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 4608,4992,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff0000,0x1ffc01 } },
{ 4992,5376,{ 0xff0000,0x3,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 5376,5760,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60 } },
{ 5760,6144,{ 0x1,0x18,0x0,0x0,0x3800,0x0,0x0,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0xf70,0x3ff00 } },
{ 6144,6528,{ 0x47ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3100,0x0,0x0 } },
{ 6528,6912,{ 0x0,0x0,0x0,0xc00000,0xffffff,0xff,0xc000,0x0,0x0,0x0,0x0,0x0,0x3f7f,0x40,0x0,0x0 } },
{ 6912,7296,{ 0x0,0x0,0x0,0xfc0000,0xf007ff,0x1f,0x0,0x0,0x0,0x0,0xf000,0x0,0x0,0xf8,0x0,0xc00000 } },
{ 7296,7680,{ 0x0,0x0,0xff0000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 8064,8448,{ 0x0,0x0,0x3a000,0xe000e0,0xe000,0xffff60,0xffffff,0x7fffff,0xeffffe,0xffdfff,0xff7ff1,0x7f,0xffffff,0xff,0x1de000,0x0 } },
{ 8448,8832,{ 0xd0037b,0x2afc0,0x1f0c00,0xffffbc,0x0,0xe0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 8832,9216,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9216,9600,{ 0xffffff,0x7fff,0xff0000,0x7,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9600,9984,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9984,10368,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 10368,10752,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 10752,11136,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffcfff } },
{ 11136,11520,{ 0x3fffff,0xffffff,0xffe3ff,0x7fd,0xf000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe00000,0xfe0007 } },
{ 11520,11904,{ 0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xffffff,0x3ffff,0x0,0x0 } },
{ 11904,12288,{ 0xffffff,0xfffffb,0xffffff,0xffffff,0xfffff,0xffff00,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x3f,0xfff00 } },
{ 12288,12672,{ 0xffff1f,0x1ff,0xe0c1,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0 } },
{ 12672,13056,{ 0xff0000,0xff,0xff0000,0xffffff,0xf,0xffff00,0xff7fff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x7fffff } },
{ 13056,13440,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffff,0x0,0x0,0x0,0x0,0x0 } },
{ 19584,19968,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff } },
{ 41856,42240,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0x7fff,0x0,0xc00000 } },
{ 42240,42624,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0,0x0,0x0,0x0,0x400f00 } },
{ 42624,43008,{ 0x0,0x0,0x0,0x0,0xfc0000,0xffff00,0x3007f,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0 } },
{ 43008,43392,{ 0x0,0xf0000,0x3ff,0x0,0xf00000,0x0,0x0,0x0,0xc000,0x0,0x1700,0x0,0xc000,0x0,0x8000,0x0 } },
{ 43392,43776,{ 0x0,0x0,0xfe0000,0xc0003f,0x0,0x0,0x0,0x0,0x0,0xf0,0x380,0x0,0x0,0x0,0xc000,0x300 } },
{ 43776,44160,{ 0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 64128,64512,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0xfc0000,0x3ff,0x0,0x0 } },
{ 64512,64896,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0 } },
{ 64896,65280,{ 0x0,0x0,0x0,0x0,0x0,0x30,0x3ff,0xffe700,0xf71fff,0xf7fff,0x0,0x0,0x0,0x0,0x0,0x800000 } },
{ 65280,65664,{ 0xfffe,0x1fc,0x17800,0xf80000,0x3f,0x0,0x0,0x0,0x0,0x7f7f00,0x3e00,0x0,0x0,0x0,0x0,0x0 } },
{ 65664,66048,{ 0x0,0x0,0x0,0x0,0x0,0xff8700,0xffffff,0xff8fff,0x0,0x0,0xffffe0,0xfff7f,0x1,0x0,0xffffff,0x1fffff } },
{ 66048,66432,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffe00,0xfff,0x0,0xf,0x0,0x0,0x0 } },
{ 66432,66816,{ 0x0,0x80,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 66816,67200,{ 0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 67584,67968,{ 0x0,0x0,0x0,0xff8000,0x800000,0xff,0x800000,0xff,0x0,0x0,0xf800,0x8fc000,0x0,0x80,0x0,0x0 } },
{ 67968,68352,{ 0x0,0x0,0xff3000,0xfffcff,0xffffff,0xff,0x0,0x0,0xff00ff,0x1,0xe000,0xe00000,0x0,0x10000,0x0,0x7ff8 } },
{ 68352,68736,{ 0x0,0x0,0xfe00,0xff0000,0x0,0xff,0x1e00,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 68736,69120,{ 0x0,0x0,0x0,0x0,0x0,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 69120,69504,{ 0x0,0x0,0x0,0x0,0xffffff,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 69504,69888,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc3f80,0x3fff,0x0,0x0,0x0,0x3f8,0x0,0x0 } },
{ 69888,70272,{ 0x0,0x0,0xf0000,0x0,0x300000,0x0,0x0,0x0,0x23e0,0xfffee8,0x1f,0x0,0x0,0x3f,0x0,0x0 } },
{ 70272,70656,{ 0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 70656,71040,{ 0x0,0x0,0x0,0x2800f8,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71040,71424,{ 0x0,0x0,0xfe0000,0xffff,0x0,0x0,0x0,0x0,0xe,0x1fff00,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71424,71808,{ 0x0,0x0,0xfc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71808,72192,{ 0x0,0x0,0x0,0x0,0x7fc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 72192,72576,{ 0x0,0x0,0x7f8000,0x0,0x0,0x0,0x7dc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 72576,72960,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e,0x1ffffc,0x3,0x0,0x0,0x0,0x0,0x0 } },
{ 74496,74880,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00 } },
{ 92544,92928,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x0,0x0,0x2000 } },
{ 92928,93312,{ 0x0,0x0,0x30ff80,0xf80000,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 113664,114048,{ 0x0,0x0,0x0,0x0,0x0,0x0,0xf9000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 118656,119040,{ 0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x3fff } },
{ 119040,119424,{ 0xffffff,0xfe7fff,0xffffff,0xffffff,0xf81c1f,0xf01807,0xffffff,0xffffc3,0xffffff,0x1ffff,0xff0000,0xffffff,0xffffff,0x23ff,0x0,0x0 } },
{ 119424,119808,{ 0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff,0x7fffff,0xffff00,0x3,0x0,0x0,0x0,0x0,0x0 } },
{ 120192,120576,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x800,0x80000 } },
{ 120576,120960,{ 0x200000,0x0,0x20,0x80,0x8000,0x20000,0x0,0x2,0x8,0x0,0xff0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 120960,121344,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 121344,121728,{ 0x0,0x0,0x780,0x0,0xdfe000,0xfefff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 124800,125184,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff8000,0x0,0x0 } },
{ 125184,125568,{ 0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 126336,126720,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300 } },
{ 126720,127104,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xff0fff,0xffffff,0xffffff,0xffffff } },
{ 127104,127488,{ 0xfffff,0x7fff00,0xfefffe,0xfffeff,0x3fffff,0x1fff00,0xffffff,0xffff7f,0xffffff,0xfffff,0xffffff,0xffffff,0x1fff,0x0,0xc00000,0xffffff } },
{ 127488,127872,{ 0xff0007,0xffffff,0xff0fff,0x301,0x3f,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 127872,128256,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 128256,128640,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 128640,129024,{ 0xffffff,0xffffff,0xffffff,0x1fff,0xff1fff,0xffff01,0xffffff,0xffffff,0xffffff,0xffffff,0xff000f,0xffffff,0xffffff,0xffffff,0x1f,0x0 } },
{ 129024,129408,{ 0xff0fff,0xffffff,0xffffff,0x3ff00,0xffffff,0xffff,0xffffff,0x3f,0x0,0x0,0xff0000,0xffff0f,0xffffff,0x1fff7f,0xffffff,0xf } },
{ 129408,129792,{ 0xffffff,0x0,0x10000,0xffff00,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 917376,917760,{ 0x0,0x0,0x0,0x0,0x0,0x200,0xff0000,0xffffff,0xffffff,0xffffff } }
};
static uint8_t const nonIdentifiers8[255] = {
	 1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,0
	,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
};
/*
static TEXTRUNE const nonIdentifiers[] = {
 0x02C2,0x02C3,0x02C4,0x02C5,0x02D2,0x02D3,0x02D4,0x02D5,0x02D6,0x02D7,0x02D8,0x02D9,0x02DA
,0x02DB,0x02DC,0x02DD,0x02DE,0x02DF,0x02E5,0x02E6,0x02E7,0x02E8,0x02E9,0x02EA,0x02EB,0x02ED
,0x02EF,0x02F0,0x02F1,0x02F2,0x02F3,0x02F4,0x02F5,0x02F6,0x02F7,0x02F8,0x02F9,0x02FA,0x02FB
,0x02FC,0x02FD,0x02FE,0x02FF,0x0375,0x037E,0x0384,0x0385,0x03F6,0x0482,0x0488,0x0489,0x055A
,0x055B,0x055C,0x055D,0x055E,0x055F,0x0589,0x058A,0x058D,0x058E,0x058F,0x05BE,0x05C0,0x05C3
,0x05C6,0x05F3,0x05F4,0x0600,0x0601,0x0602,0x0603,0x0604,0x0605,0x0606,0x0607,0x0608,0x0609
,0x060A,0x060B,0x060C,0x060D,0x060E,0x060F,0x061B,0x061C,0x061E,0x061F,0x066A,0x066B,0x066C
,0x066D,0x06D4,0x06DD,0x06DE,0x06E9,0x06FD,0x06FE,0x0700,0x0701,0x0702,0x0703,0x0704,0x0705
,0x0706,0x0707,0x0708,0x0709,0x070A,0x070B,0x070C,0x070D,0x070F,0x07F6,0x07F7,0x07F8,0x07F9
,0x0830,0x0831,0x0832,0x0833,0x0834,0x0835,0x0836,0x0837,0x0838,0x0839,0x083A,0x083B,0x083C
,0x083D,0x083E,0x085E,0x08E2,0x0964,0x0965,0x0970,0x09F2,0x09F3,0x09F4,0x09F5,0x09F6,0x09F7
,0x09F8,0x09F9,0x09FA,0x09FB,0x09FD,0x0AF0,0x0AF1,0x0B70,0x0B72,0x0B73,0x0B74,0x0B75,0x0B76
,0x0B77,0x0BF0,0x0BF1,0x0BF2,0x0BF3,0x0BF4,0x0BF5,0x0BF6,0x0BF7,0x0BF8,0x0BF9,0x0BFA,0x0C78
,0x0C79,0x0C7A,0x0C7B,0x0C7C,0x0C7D,0x0C7E,0x0C7F,0x0D4F,0x0D58,0x0D59,0x0D5A,0x0D5B,0x0D5C
,0x0D5D,0x0D5E,0x0D70,0x0D71,0x0D72,0x0D73,0x0D74,0x0D75,0x0D76,0x0D77,0x0D78,0x0D79,0x0DF4
,0x0E3F,0x0E4F,0x0E5A,0x0E5B,0x0F01,0x0F02,0x0F03,0x0F04,0x0F05,0x0F06,0x0F07,0x0F08,0x0F09
,0x0F0A,0x0F0B,0x0F0C,0x0F0D,0x0F0E,0x0F0F,0x0F10,0x0F11,0x0F12,0x0F13,0x0F14,0x0F15,0x0F16
,0x0F17,0x0F1A,0x0F1B,0x0F1C,0x0F1D,0x0F1E,0x0F1F,0x0F2A,0x0F2B,0x0F2C,0x0F2D,0x0F2E,0x0F2F
,0x0F30,0x0F31,0x0F32,0x0F33,0x0F34,0x0F36,0x0F38,0x0F3A,0x0F3B,0x0F3C,0x0F3D,0x0F85,0x0FBE
,0x0FBF,0x0FC0,0x0FC1,0x0FC2,0x0FC3,0x0FC4,0x0FC5,0x0FC7,0x0FC8,0x0FC9,0x0FCA,0x0FCB,0x0FCC
,0x0FCE,0x0FCF,0x0FD0,0x0FD1,0x0FD2,0x0FD3,0x0FD4,0x0FD5,0x0FD6,0x0FD7,0x0FD8,0x0FD9,0x0FDA
,0x104A,0x104B,0x104C,0x104D,0x104E,0x104F,0x109E,0x109F,0x10FB,0x1360,0x1361,0x1362,0x1363
,0x1364,0x1365,0x1366,0x1367,0x1368,0x1372,0x1373,0x1374,0x1375,0x1376,0x1377,0x1378,0x1379
,0x137A,0x137B,0x137C,0x1390,0x1391,0x1392,0x1393,0x1394,0x1395,0x1396,0x1397,0x1398,0x1399
,0x1400,0x166D,0x166E,0x1680,0x169B,0x169C,0x16EB,0x16EC,0x16ED,0x1735,0x1736,0x17D4,0x17D5
,0x17D6,0x17D8,0x17D9,0x17DA,0x17DB,0x17F0,0x17F1,0x17F2,0x17F3,0x17F4,0x17F5,0x17F6,0x17F7
,0x17F8,0x17F9,0x1800,0x1801,0x1802,0x1803,0x1804,0x1805,0x1806,0x1807,0x1808,0x1809,0x180A
,0x180E,0x1940,0x1944,0x1945,0x19DE,0x19DF,0x19E0,0x19E1,0x19E2,0x19E3,0x19E4,0x19E5,0x19E6
,0x19E7,0x19E8,0x19E9,0x19EA,0x19EB,0x19EC,0x19ED,0x19EE,0x19EF,0x19F0,0x19F1,0x19F2,0x19F3
,0x19F4,0x19F5,0x19F6,0x19F7,0x19F8,0x19F9,0x19FA,0x19FB,0x19FC,0x19FD,0x19FE,0x19FF,0x1A1E
,0x1A1F,0x1AA0,0x1AA1,0x1AA2,0x1AA3,0x1AA4,0x1AA5,0x1AA6,0x1AA8,0x1AA9,0x1AAA,0x1AAB,0x1AAC
,0x1AAD,0x1ABE,0x1B5A,0x1B5B,0x1B5C,0x1B5D,0x1B5E,0x1B5F,0x1B60,0x1B61,0x1B62,0x1B63,0x1B64
,0x1B65,0x1B66,0x1B67,0x1B68,0x1B69,0x1B6A,0x1B74,0x1B75,0x1B76,0x1B77,0x1B78,0x1B79,0x1B7A
,0x1B7B,0x1B7C,0x1BFC,0x1BFD,0x1BFE,0x1BFF,0x1C3B,0x1C3C,0x1C3D,0x1C3E,0x1C3F,0x1C7E,0x1C7F
,0x1CC0,0x1CC1,0x1CC2,0x1CC3,0x1CC4,0x1CC5,0x1CC6,0x1CC7,0x1CD3,0x1FBD,0x1FBF,0x1FC0,0x1FC1
,0x1FCD,0x1FCE,0x1FCF,0x1FDD,0x1FDE,0x1FDF,0x1FED,0x1FEE,0x1FEF,0x1FFD,0x1FFE,0x2000,0x2001
,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x200B,0x200C,0x200D,0x200E
,0x200F,0x2010,0x2011,0x2012,0x2013,0x2014,0x2015,0x2016,0x2017,0x2018,0x2019,0x201A,0x201B
,0x201C,0x201D,0x201E,0x201F,0x2020,0x2021,0x2022,0x2023,0x2024,0x2025,0x2026,0x2027,0x2028
,0x2029,0x202A,0x202B,0x202C,0x202D,0x202E,0x202F,0x2030,0x2031,0x2032,0x2033,0x2034,0x2035
,0x2036,0x2037,0x2038,0x2039,0x203A,0x203B,0x203C,0x203D,0x203E,0x2041,0x2042,0x2043,0x2044
,0x2045,0x2046,0x2047,0x2048,0x2049,0x204A,0x204B,0x204C,0x204D,0x204E,0x204F,0x2050,0x2051
,0x2052,0x2053,0x2055,0x2056,0x2057,0x2058,0x2059,0x205A,0x205B,0x205C,0x205D,0x205E,0x205F
,0x2060,0x2061,0x2062,0x2063,0x2064,0x2066,0x2067,0x2068,0x2069,0x206A,0x206B,0x206C,0x206D
,0x206E,0x206F,0x2070,0x2074,0x2075,0x2076,0x2077,0x2078,0x2079,0x207A,0x207B,0x207C,0x207D
,0x207E,0x2080,0x2081,0x2082,0x2083,0x2084,0x2085,0x2086,0x2087,0x2088,0x2089,0x208A,0x208B
,0x208C,0x208D,0x208E,0x20A0,0x20A1,0x20A2,0x20A3,0x20A4,0x20A5,0x20A6,0x20A7,0x20A8,0x20A9
,0x20AA,0x20AB,0x20AC,0x20AD,0x20AE,0x20AF,0x20B0,0x20B1,0x20B2,0x20B3,0x20B4,0x20B5,0x20B6
,0x20B7,0x20B8,0x20B9,0x20BA,0x20BB,0x20BC,0x20BD,0x20BE,0x20BF,0x20DD,0x20DE,0x20DF,0x20E0
,0x20E2,0x20E3,0x20E4,0x2100,0x2101,0x2103,0x2104,0x2105,0x2106,0x2108,0x2109,0x2114,0x2116
,0x2117,0x211E,0x211F,0x2120,0x2121,0x2122,0x2123,0x2125,0x2127,0x2129,0x213A,0x213B,0x2140
,0x2141,0x2142,0x2143,0x2144,0x214A,0x214B,0x214C,0x214D,0x214F,0x2150,0x2151,0x2152,0x2153
,0x2154,0x2155,0x2156,0x2157,0x2158,0x2159,0x215A,0x215B,0x215C,0x215D,0x215E,0x215F,0x2189
,0x218A,0x218B,0x2190,0x2191,0x2192,0x2193,0x2194,0x2195,0x2196,0x2197,0x2198,0x2199,0x219A
,0x219B,0x219C,0x219D,0x219E,0x219F,0x21A0,0x21A1,0x21A2,0x21A3,0x21A4,0x21A5,0x21A6,0x21A7
,0x21A8,0x21A9,0x21AA,0x21AB,0x21AC,0x21AD,0x21AE,0x21AF,0x21B0,0x21B1,0x21B2,0x21B3,0x21B4
,0x21B5,0x21B6,0x21B7,0x21B8,0x21B9,0x21BA,0x21BB,0x21BC,0x21BD,0x21BE,0x21BF,0x21C0,0x21C1
,0x21C2,0x21C3,0x21C4,0x21C5,0x21C6,0x21C7,0x21C8,0x21C9,0x21CA,0x21CB,0x21CC,0x21CD,0x21CE
,0x21CF,0x21D0,0x21D1,0x21D2,0x21D3,0x21D4,0x21D5,0x21D6,0x21D7,0x21D8,0x21D9,0x21DA,0x21DB
,0x21DC,0x21DD,0x21DE,0x21DF,0x21E0,0x21E1,0x21E2,0x21E3,0x21E4,0x21E5,0x21E6,0x21E7,0x21E8
,0x21E9,0x21EA,0x21EB,0x21EC,0x21ED,0x21EE,0x21EF,0x21F0,0x21F1,0x21F2,0x21F3,0x21F4,0x21F5
,0x21F6,0x21F7,0x21F8,0x21F9,0x21FA,0x21FB,0x21FC,0x21FD,0x21FE,0x21FF,0x2200,0x2201,0x2202
,0x2203,0x2204,0x2205,0x2206,0x2207,0x2208,0x2209,0x220A,0x220B,0x220C,0x220D,0x220E,0x220F
,0x2210,0x2211,0x2212,0x2213,0x2214,0x2215,0x2216,0x2217,0x2218,0x2219,0x221A,0x221B,0x221C
,0x221D,0x221E,0x221F,0x2220,0x2221,0x2222,0x2223,0x2224,0x2225,0x2226,0x2227,0x2228,0x2229
,0x222A,0x222B,0x222C,0x222D,0x222E,0x222F,0x2230,0x2231,0x2232,0x2233,0x2234,0x2235,0x2236
,0x2237,0x2238,0x2239,0x223A,0x223B,0x223C,0x223D,0x223E,0x223F,0x2240,0x2241,0x2242,0x2243
,0x2244,0x2245,0x2246,0x2247,0x2248,0x2249,0x224A,0x224B,0x224C,0x224D,0x224E,0x224F,0x2250
,0x2251,0x2252,0x2253,0x2254,0x2255,0x2256,0x2257,0x2258,0x2259,0x225A,0x225B,0x225C,0x225D
,0x225E,0x225F,0x2260,0x2261,0x2262,0x2263,0x2264,0x2265,0x2266,0x2267,0x2268,0x2269,0x226A
,0x226B,0x226C,0x226D,0x226E,0x226F,0x2270,0x2271,0x2272,0x2273,0x2274,0x2275,0x2276,0x2277
,0x2278,0x2279,0x227A,0x227B,0x227C,0x227D,0x227E,0x227F,0x2280,0x2281,0x2282,0x2283,0x2284
,0x2285,0x2286,0x2287,0x2288,0x2289,0x228A,0x228B,0x228C,0x228D,0x228E,0x228F,0x2290,0x2291
,0x2292,0x2293,0x2294,0x2295,0x2296,0x2297,0x2298,0x2299,0x229A,0x229B,0x229C,0x229D,0x229E
,0x229F,0x22A0,0x22A1,0x22A2,0x22A3,0x22A4,0x22A5,0x22A6,0x22A7,0x22A8,0x22A9,0x22AA,0x22AB
,0x22AC,0x22AD,0x22AE,0x22AF,0x22B0,0x22B1,0x22B2,0x22B3,0x22B4,0x22B5,0x22B6,0x22B7,0x22B8
,0x22B9,0x22BA,0x22BB,0x22BC,0x22BD,0x22BE,0x22BF,0x22C0,0x22C1,0x22C2,0x22C3,0x22C4,0x22C5
,0x22C6,0x22C7,0x22C8,0x22C9,0x22CA,0x22CB,0x22CC,0x22CD,0x22CE,0x22CF,0x22D0,0x22D1,0x22D2
,0x22D3,0x22D4,0x22D5,0x22D6,0x22D7,0x22D8,0x22D9,0x22DA,0x22DB,0x22DC,0x22DD,0x22DE,0x22DF
,0x22E0,0x22E1,0x22E2,0x22E3,0x22E4,0x22E5,0x22E6,0x22E7,0x22E8,0x22E9,0x22EA,0x22EB,0x22EC
,0x22ED,0x22EE,0x22EF,0x22F0,0x22F1,0x22F2,0x22F3,0x22F4,0x22F5,0x22F6,0x22F7,0x22F8,0x22F9
,0x22FA,0x22FB,0x22FC,0x22FD,0x22FE,0x22FF,0x2300,0x2301,0x2302,0x2303,0x2304,0x2305,0x2306
,0x2307,0x2308,0x2309,0x230A,0x230B,0x230C,0x230D,0x230E,0x230F,0x2310,0x2311,0x2312,0x2313
,0x2314,0x2315,0x2316,0x2317,0x2318,0x2319,0x231A,0x231B,0x231C,0x231D,0x231E,0x231F,0x2320
,0x2321,0x2322,0x2323,0x2324,0x2325,0x2326,0x2327,0x2328,0x2329,0x232A,0x232B,0x232C,0x232D
,0x232E,0x232F,0x2330,0x2331,0x2332,0x2333,0x2334,0x2335,0x2336,0x2337,0x2338,0x2339,0x233A
,0x233B,0x233C,0x233D,0x233E,0x233F,0x2340,0x2341,0x2342,0x2343,0x2344,0x2345,0x2346,0x2347
,0x2348,0x2349,0x234A,0x234B,0x234C,0x234D,0x234E,0x234F,0x2350,0x2351,0x2352,0x2353,0x2354
,0x2355,0x2356,0x2357,0x2358,0x2359,0x235A,0x235B,0x235C,0x235D,0x235E,0x235F,0x2360,0x2361
,0x2362,0x2363,0x2364,0x2365,0x2366,0x2367,0x2368,0x2369,0x236A,0x236B,0x236C,0x236D,0x236E
,0x236F,0x2370,0x2371,0x2372,0x2373,0x2374,0x2375,0x2376,0x2377,0x2378,0x2379,0x237A,0x237B
,0x237C,0x237D,0x237E,0x237F,0x2380,0x2381,0x2382,0x2383,0x2384,0x2385,0x2386,0x2387,0x2388
,0x2389,0x238A,0x238B,0x238C,0x238D,0x238E,0x238F,0x2390,0x2391,0x2392,0x2393,0x2394,0x2395
,0x2396,0x2397,0x2398,0x2399,0x239A,0x239B,0x239C,0x239D,0x239E,0x239F,0x23A0,0x23A1,0x23A2
,0x23A3,0x23A4,0x23A5,0x23A6,0x23A7,0x23A8,0x23A9,0x23AA,0x23AB,0x23AC,0x23AD,0x23AE,0x23AF
,0x23B0,0x23B1,0x23B2,0x23B3,0x23B4,0x23B5,0x23B6,0x23B7,0x23B8,0x23B9,0x23BA,0x23BB,0x23BC
,0x23BD,0x23BE,0x23BF,0x23C0,0x23C1,0x23C2,0x23C3,0x23C4,0x23C5,0x23C6,0x23C7,0x23C8,0x23C9
,0x23CA,0x23CB,0x23CC,0x23CD,0x23CE,0x23CF,0x23D0,0x23D1,0x23D2,0x23D3,0x23D4,0x23D5,0x23D6
,0x23D7,0x23D8,0x23D9,0x23DA,0x23DB,0x23DC,0x23DD,0x23DE,0x23DF,0x23E0,0x23E1,0x23E2,0x23E3
,0x23E4,0x23E5,0x23E6,0x23E7,0x23E8,0x23E9,0x23EA,0x23EB,0x23EC,0x23ED,0x23EE,0x23EF,0x23F0
,0x23F1,0x23F2,0x23F3,0x23F4,0x23F5,0x23F6,0x23F7,0x23F8,0x23F9,0x23FA,0x23FB,0x23FC,0x23FD
,0x23FE,0x23FF,0x2400,0x2401,0x2402,0x2403,0x2404,0x2405,0x2406,0x2407,0x2408,0x2409,0x240A
,0x240B,0x240C,0x240D,0x240E,0x240F,0x2410,0x2411,0x2412,0x2413,0x2414,0x2415,0x2416,0x2417
,0x2418,0x2419,0x241A,0x241B,0x241C,0x241D,0x241E,0x241F,0x2420,0x2421,0x2422,0x2423,0x2424
,0x2425,0x2426,0x2440,0x2441,0x2442,0x2443,0x2444,0x2445,0x2446,0x2447,0x2448,0x2449,0x244A
,0x2460,0x2461,0x2462,0x2463,0x2464,0x2465,0x2466,0x2467,0x2468,0x2469,0x246A,0x246B,0x246C
,0x246D,0x246E,0x246F,0x2470,0x2471,0x2472,0x2473,0x2474,0x2475,0x2476,0x2477,0x2478,0x2479
,0x247A,0x247B,0x247C,0x247D,0x247E,0x247F,0x2480,0x2481,0x2482,0x2483,0x2484,0x2485,0x2486
,0x2487,0x2488,0x2489,0x248A,0x248B,0x248C,0x248D,0x248E,0x248F,0x2490,0x2491,0x2492,0x2493
,0x2494,0x2495,0x2496,0x2497,0x2498,0x2499,0x249A,0x249B,0x249C,0x249D,0x249E,0x249F,0x24A0
,0x24A1,0x24A2,0x24A3,0x24A4,0x24A5,0x24A6,0x24A7,0x24A8,0x24A9,0x24AA,0x24AB,0x24AC,0x24AD
,0x24AE,0x24AF,0x24B0,0x24B1,0x24B2,0x24B3,0x24B4,0x24B5,0x24B6,0x24B7,0x24B8,0x24B9,0x24BA
,0x24BB,0x24BC,0x24BD,0x24BE,0x24BF,0x24C0,0x24C1,0x24C2,0x24C3,0x24C4,0x24C5,0x24C6,0x24C7
,0x24C8,0x24C9,0x24CA,0x24CB,0x24CC,0x24CD,0x24CE,0x24CF,0x24D0,0x24D1,0x24D2,0x24D3,0x24D4
,0x24D5,0x24D6,0x24D7,0x24D8,0x24D9,0x24DA,0x24DB,0x24DC,0x24DD,0x24DE,0x24DF,0x24E0,0x24E1
,0x24E2,0x24E3,0x24E4,0x24E5,0x24E6,0x24E7,0x24E8,0x24E9,0x24EA,0x24EB,0x24EC,0x24ED,0x24EE
,0x24EF,0x24F0,0x24F1,0x24F2,0x24F3,0x24F4,0x24F5,0x24F6,0x24F7,0x24F8,0x24F9,0x24FA,0x24FB
,0x24FC,0x24FD,0x24FE,0x24FF,0x2500,0x2501,0x2502,0x2503,0x2504,0x2505,0x2506,0x2507,0x2508
,0x2509,0x250A,0x250B,0x250C,0x250D,0x250E,0x250F,0x2510,0x2511,0x2512,0x2513,0x2514,0x2515
,0x2516,0x2517,0x2518,0x2519,0x251A,0x251B,0x251C,0x251D,0x251E,0x251F,0x2520,0x2521,0x2522
,0x2523,0x2524,0x2525,0x2526,0x2527,0x2528,0x2529,0x252A,0x252B,0x252C,0x252D,0x252E,0x252F
,0x2530,0x2531,0x2532,0x2533,0x2534,0x2535,0x2536,0x2537,0x2538,0x2539,0x253A,0x253B,0x253C
,0x253D,0x253E,0x253F,0x2540,0x2541,0x2542,0x2543,0x2544,0x2545,0x2546,0x2547,0x2548,0x2549
,0x254A,0x254B,0x254C,0x254D,0x254E,0x254F,0x2550,0x2551,0x2552,0x2553,0x2554,0x2555,0x2556
,0x2557,0x2558,0x2559,0x255A,0x255B,0x255C,0x255D,0x255E,0x255F,0x2560,0x2561,0x2562,0x2563
,0x2564,0x2565,0x2566,0x2567,0x2568,0x2569,0x256A,0x256B,0x256C,0x256D,0x256E,0x256F,0x2570
,0x2571,0x2572,0x2573,0x2574,0x2575,0x2576,0x2577,0x2578,0x2579,0x257A,0x257B,0x257C,0x257D
,0x257E,0x257F,0x2580,0x2581,0x2582,0x2583,0x2584,0x2585,0x2586,0x2587,0x2588,0x2589,0x258A
,0x258B,0x258C,0x258D,0x258E,0x258F,0x2590,0x2591,0x2592,0x2593,0x2594,0x2595,0x2596,0x2597
,0x2598,0x2599,0x259A,0x259B,0x259C,0x259D,0x259E,0x259F,0x25A0,0x25A1,0x25A2,0x25A3,0x25A4
,0x25A5,0x25A6,0x25A7,0x25A8,0x25A9,0x25AA,0x25AB,0x25AC,0x25AD,0x25AE,0x25AF,0x25B0,0x25B1
,0x25B2,0x25B3,0x25B4,0x25B5,0x25B6,0x25B7,0x25B8,0x25B9,0x25BA,0x25BB,0x25BC,0x25BD,0x25BE
,0x25BF,0x25C0,0x25C1,0x25C2,0x25C3,0x25C4,0x25C5,0x25C6,0x25C7,0x25C8,0x25C9,0x25CA,0x25CB
,0x25CC,0x25CD,0x25CE,0x25CF,0x25D0,0x25D1,0x25D2,0x25D3,0x25D4,0x25D5,0x25D6,0x25D7,0x25D8
,0x25D9,0x25DA,0x25DB,0x25DC,0x25DD,0x25DE,0x25DF,0x25E0,0x25E1,0x25E2,0x25E3,0x25E4,0x25E5
,0x25E6,0x25E7,0x25E8,0x25E9,0x25EA,0x25EB,0x25EC,0x25ED,0x25EE,0x25EF,0x25F0,0x25F1,0x25F2
,0x25F3,0x25F4,0x25F5,0x25F6,0x25F7,0x25F8,0x25F9,0x25FA,0x25FB,0x25FC,0x25FD,0x25FE,0x25FF
,0x2600,0x2601,0x2602,0x2603,0x2604,0x2605,0x2606,0x2607,0x2608,0x2609,0x260A,0x260B,0x260C
,0x260D,0x260E,0x260F,0x2610,0x2611,0x2612,0x2613,0x2614,0x2615,0x2616,0x2617,0x2618,0x2619
,0x261A,0x261B,0x261C,0x261D,0x261E,0x261F,0x2620,0x2621,0x2622,0x2623,0x2624,0x2625,0x2626
,0x2627,0x2628,0x2629,0x262A,0x262B,0x262C,0x262D,0x262E,0x262F,0x2630,0x2631,0x2632,0x2633
,0x2634,0x2635,0x2636,0x2637,0x2638,0x2639,0x263A,0x263B,0x263C,0x263D,0x263E,0x263F,0x2640
,0x2641,0x2642,0x2643,0x2644,0x2645,0x2646,0x2647,0x2648,0x2649,0x264A,0x264B,0x264C,0x264D
,0x264E,0x264F,0x2650,0x2651,0x2652,0x2653,0x2654,0x2655,0x2656,0x2657,0x2658,0x2659,0x265A
,0x265B,0x265C,0x265D,0x265E,0x265F,0x2660,0x2661,0x2662,0x2663,0x2664,0x2665,0x2666,0x2667
,0x2668,0x2669,0x266A,0x266B,0x266C,0x266D,0x266E,0x266F,0x2670,0x2671,0x2672,0x2673,0x2674
,0x2675,0x2676,0x2677,0x2678,0x2679,0x267A,0x267B,0x267C,0x267D,0x267E,0x267F,0x2680,0x2681
,0x2682,0x2683,0x2684,0x2685,0x2686,0x2687,0x2688,0x2689,0x268A,0x268B,0x268C,0x268D,0x268E
,0x268F,0x2690,0x2691,0x2692,0x2693,0x2694,0x2695,0x2696,0x2697,0x2698,0x2699,0x269A,0x269B
,0x269C,0x269D,0x269E,0x269F,0x26A0,0x26A1,0x26A2,0x26A3,0x26A4,0x26A5,0x26A6,0x26A7,0x26A8
,0x26A9,0x26AA,0x26AB,0x26AC,0x26AD,0x26AE,0x26AF,0x26B0,0x26B1,0x26B2,0x26B3,0x26B4,0x26B5
,0x26B6,0x26B7,0x26B8,0x26B9,0x26BA,0x26BB,0x26BC,0x26BD,0x26BE,0x26BF,0x26C0,0x26C1,0x26C2
,0x26C3,0x26C4,0x26C5,0x26C6,0x26C7,0x26C8,0x26C9,0x26CA,0x26CB,0x26CC,0x26CD,0x26CE,0x26CF
,0x26D0,0x26D1,0x26D2,0x26D3,0x26D4,0x26D5,0x26D6,0x26D7,0x26D8,0x26D9,0x26DA,0x26DB,0x26DC
,0x26DD,0x26DE,0x26DF,0x26E0,0x26E1,0x26E2,0x26E3,0x26E4,0x26E5,0x26E6,0x26E7,0x26E8,0x26E9
,0x26EA,0x26EB,0x26EC,0x26ED,0x26EE,0x26EF,0x26F0,0x26F1,0x26F2,0x26F3,0x26F4,0x26F5,0x26F6
,0x26F7,0x26F8,0x26F9,0x26FA,0x26FB,0x26FC,0x26FD,0x26FE,0x26FF,0x2700,0x2701,0x2702,0x2703
,0x2704,0x2705,0x2706,0x2707,0x2708,0x2709,0x270A,0x270B,0x270C,0x270D,0x270E,0x270F,0x2710
,0x2711,0x2712,0x2713,0x2714,0x2715,0x2716,0x2717,0x2718,0x2719,0x271A,0x271B,0x271C,0x271D
,0x271E,0x271F,0x2720,0x2721,0x2722,0x2723,0x2724,0x2725,0x2726,0x2727,0x2728,0x2729,0x272A
,0x272B,0x272C,0x272D,0x272E,0x272F,0x2730,0x2731,0x2732,0x2733,0x2734,0x2735,0x2736,0x2737
,0x2738,0x2739,0x273A,0x273B,0x273C,0x273D,0x273E,0x273F,0x2740,0x2741,0x2742,0x2743,0x2744
,0x2745,0x2746,0x2747,0x2748,0x2749,0x274A,0x274B,0x274C,0x274D,0x274E,0x274F,0x2750,0x2751
,0x2752,0x2753,0x2754,0x2755,0x2756,0x2757,0x2758,0x2759,0x275A,0x275B,0x275C,0x275D,0x275E
,0x275F,0x2760,0x2761,0x2762,0x2763,0x2764,0x2765,0x2766,0x2767,0x2768,0x2769,0x276A,0x276B
,0x276C,0x276D,0x276E,0x276F,0x2770,0x2771,0x2772,0x2773,0x2774,0x2775,0x2776,0x2777,0x2778
,0x2779,0x277A,0x277B,0x277C,0x277D,0x277E,0x277F,0x2780,0x2781,0x2782,0x2783,0x2784,0x2785
,0x2786,0x2787,0x2788,0x2789,0x278A,0x278B,0x278C,0x278D,0x278E,0x278F,0x2790,0x2791,0x2792
,0x2793,0x2794,0x2795,0x2796,0x2797,0x2798,0x2799,0x279A,0x279B,0x279C,0x279D,0x279E,0x279F
,0x27A0,0x27A1,0x27A2,0x27A3,0x27A4,0x27A5,0x27A6,0x27A7,0x27A8,0x27A9,0x27AA,0x27AB,0x27AC
,0x27AD,0x27AE,0x27AF,0x27B0,0x27B1,0x27B2,0x27B3,0x27B4,0x27B5,0x27B6,0x27B7,0x27B8,0x27B9
,0x27BA,0x27BB,0x27BC,0x27BD,0x27BE,0x27BF,0x27C0,0x27C1,0x27C2,0x27C3,0x27C4,0x27C5,0x27C6
,0x27C7,0x27C8,0x27C9,0x27CA,0x27CB,0x27CC,0x27CD,0x27CE,0x27CF,0x27D0,0x27D1,0x27D2,0x27D3
,0x27D4,0x27D5,0x27D6,0x27D7,0x27D8,0x27D9,0x27DA,0x27DB,0x27DC,0x27DD,0x27DE,0x27DF,0x27E0
,0x27E1,0x27E2,0x27E3,0x27E4,0x27E5,0x27E6,0x27E7,0x27E8,0x27E9,0x27EA,0x27EB,0x27EC,0x27ED
,0x27EE,0x27EF,0x27F0,0x27F1,0x27F2,0x27F3,0x27F4,0x27F5,0x27F6,0x27F7,0x27F8,0x27F9,0x27FA
,0x27FB,0x27FC,0x27FD,0x27FE,0x27FF,0x2800,0x2801,0x2802,0x2803,0x2804,0x2805,0x2806,0x2807
,0x2808,0x2809,0x280A,0x280B,0x280C,0x280D,0x280E,0x280F,0x2810,0x2811,0x2812,0x2813,0x2814
,0x2815,0x2816,0x2817,0x2818,0x2819,0x281A,0x281B,0x281C,0x281D,0x281E,0x281F,0x2820,0x2821
,0x2822,0x2823,0x2824,0x2825,0x2826,0x2827,0x2828,0x2829,0x282A,0x282B,0x282C,0x282D,0x282E
,0x282F,0x2830,0x2831,0x2832,0x2833,0x2834,0x2835,0x2836,0x2837,0x2838,0x2839,0x283A,0x283B
,0x283C,0x283D,0x283E,0x283F,0x2840,0x2841,0x2842,0x2843,0x2844,0x2845,0x2846,0x2847,0x2848
,0x2849,0x284A,0x284B,0x284C,0x284D,0x284E,0x284F,0x2850,0x2851,0x2852,0x2853,0x2854,0x2855
,0x2856,0x2857,0x2858,0x2859,0x285A,0x285B,0x285C,0x285D,0x285E,0x285F,0x2860,0x2861,0x2862
,0x2863,0x2864,0x2865,0x2866,0x2867,0x2868,0x2869,0x286A,0x286B,0x286C,0x286D,0x286E,0x286F
,0x2870,0x2871,0x2872,0x2873,0x2874,0x2875,0x2876,0x2877,0x2878,0x2879,0x287A,0x287B,0x287C
,0x287D,0x287E,0x287F,0x2880,0x2881,0x2882,0x2883,0x2884,0x2885,0x2886,0x2887,0x2888,0x2889
,0x288A,0x288B,0x288C,0x288D,0x288E,0x288F,0x2890,0x2891,0x2892,0x2893,0x2894,0x2895,0x2896
,0x2897,0x2898,0x2899,0x289A,0x289B,0x289C,0x289D,0x289E,0x289F,0x28A0,0x28A1,0x28A2,0x28A3
,0x28A4,0x28A5,0x28A6,0x28A7,0x28A8,0x28A9,0x28AA,0x28AB,0x28AC,0x28AD,0x28AE,0x28AF,0x28B0
,0x28B1,0x28B2,0x28B3,0x28B4,0x28B5,0x28B6,0x28B7,0x28B8,0x28B9,0x28BA,0x28BB,0x28BC,0x28BD
,0x28BE,0x28BF,0x28C0,0x28C1,0x28C2,0x28C3,0x28C4,0x28C5,0x28C6,0x28C7,0x28C8,0x28C9,0x28CA
,0x28CB,0x28CC,0x28CD,0x28CE,0x28CF,0x28D0,0x28D1,0x28D2,0x28D3,0x28D4,0x28D5,0x28D6,0x28D7
,0x28D8,0x28D9,0x28DA,0x28DB,0x28DC,0x28DD,0x28DE,0x28DF,0x28E0,0x28E1,0x28E2,0x28E3,0x28E4
,0x28E5,0x28E6,0x28E7,0x28E8,0x28E9,0x28EA,0x28EB,0x28EC,0x28ED,0x28EE,0x28EF,0x28F0,0x28F1
,0x28F2,0x28F3,0x28F4,0x28F5,0x28F6,0x28F7,0x28F8,0x28F9,0x28FA,0x28FB,0x28FC,0x28FD,0x28FE
,0x28FF,0x2900,0x2901,0x2902,0x2903,0x2904,0x2905,0x2906,0x2907,0x2908,0x2909,0x290A,0x290B
,0x290C,0x290D,0x290E,0x290F,0x2910,0x2911,0x2912,0x2913,0x2914,0x2915,0x2916,0x2917,0x2918
,0x2919,0x291A,0x291B,0x291C,0x291D,0x291E,0x291F,0x2920,0x2921,0x2922,0x2923,0x2924,0x2925
,0x2926,0x2927,0x2928,0x2929,0x292A,0x292B,0x292C,0x292D,0x292E,0x292F,0x2930,0x2931,0x2932
,0x2933,0x2934,0x2935,0x2936,0x2937,0x2938,0x2939,0x293A,0x293B,0x293C,0x293D,0x293E,0x293F
,0x2940,0x2941,0x2942,0x2943,0x2944,0x2945,0x2946,0x2947,0x2948,0x2949,0x294A,0x294B,0x294C
,0x294D,0x294E,0x294F,0x2950,0x2951,0x2952,0x2953,0x2954,0x2955,0x2956,0x2957,0x2958,0x2959
,0x295A,0x295B,0x295C,0x295D,0x295E,0x295F,0x2960,0x2961,0x2962,0x2963,0x2964,0x2965,0x2966
,0x2967,0x2968,0x2969,0x296A,0x296B,0x296C,0x296D,0x296E,0x296F,0x2970,0x2971,0x2972,0x2973
,0x2974,0x2975,0x2976,0x2977,0x2978,0x2979,0x297A,0x297B,0x297C,0x297D,0x297E,0x297F,0x2980
,0x2981,0x2982,0x2983,0x2984,0x2985,0x2986,0x2987,0x2988,0x2989,0x298A,0x298B,0x298C,0x298D
,0x298E,0x298F,0x2990,0x2991,0x2992,0x2993,0x2994,0x2995,0x2996,0x2997,0x2998,0x2999,0x299A
,0x299B,0x299C,0x299D,0x299E,0x299F,0x29A0,0x29A1,0x29A2,0x29A3,0x29A4,0x29A5,0x29A6,0x29A7
,0x29A8,0x29A9,0x29AA,0x29AB,0x29AC,0x29AD,0x29AE,0x29AF,0x29B0,0x29B1,0x29B2,0x29B3,0x29B4
,0x29B5,0x29B6,0x29B7,0x29B8,0x29B9,0x29BA,0x29BB,0x29BC,0x29BD,0x29BE,0x29BF,0x29C0,0x29C1
,0x29C2,0x29C3,0x29C4,0x29C5,0x29C6,0x29C7,0x29C8,0x29C9,0x29CA,0x29CB,0x29CC,0x29CD,0x29CE
,0x29CF,0x29D0,0x29D1,0x29D2,0x29D3,0x29D4,0x29D5,0x29D6,0x29D7,0x29D8,0x29D9,0x29DA,0x29DB
,0x29DC,0x29DD,0x29DE,0x29DF,0x29E0,0x29E1,0x29E2,0x29E3,0x29E4,0x29E5,0x29E6,0x29E7,0x29E8
,0x29E9,0x29EA,0x29EB,0x29EC,0x29ED,0x29EE,0x29EF,0x29F0,0x29F1,0x29F2,0x29F3,0x29F4,0x29F5
,0x29F6,0x29F7,0x29F8,0x29F9,0x29FA,0x29FB,0x29FC,0x29FD,0x29FE,0x29FF,0x2A00,0x2A01,0x2A02
,0x2A03,0x2A04,0x2A05,0x2A06,0x2A07,0x2A08,0x2A09,0x2A0A,0x2A0B,0x2A0C,0x2A0D,0x2A0E,0x2A0F
,0x2A10,0x2A11,0x2A12,0x2A13,0x2A14,0x2A15,0x2A16,0x2A17,0x2A18,0x2A19,0x2A1A,0x2A1B,0x2A1C
,0x2A1D,0x2A1E,0x2A1F,0x2A20,0x2A21,0x2A22,0x2A23,0x2A24,0x2A25,0x2A26,0x2A27,0x2A28,0x2A29
,0x2A2A,0x2A2B,0x2A2C,0x2A2D,0x2A2E,0x2A2F,0x2A30,0x2A31,0x2A32,0x2A33,0x2A34,0x2A35,0x2A36
,0x2A37,0x2A38,0x2A39,0x2A3A,0x2A3B,0x2A3C,0x2A3D,0x2A3E,0x2A3F,0x2A40,0x2A41,0x2A42,0x2A43
,0x2A44,0x2A45,0x2A46,0x2A47,0x2A48,0x2A49,0x2A4A,0x2A4B,0x2A4C,0x2A4D,0x2A4E,0x2A4F,0x2A50
,0x2A51,0x2A52,0x2A53,0x2A54,0x2A55,0x2A56,0x2A57,0x2A58,0x2A59,0x2A5A,0x2A5B,0x2A5C,0x2A5D
,0x2A5E,0x2A5F,0x2A60,0x2A61,0x2A62,0x2A63,0x2A64,0x2A65,0x2A66,0x2A67,0x2A68,0x2A69,0x2A6A
,0x2A6B,0x2A6C,0x2A6D,0x2A6E,0x2A6F,0x2A70,0x2A71,0x2A72,0x2A73,0x2A74,0x2A75,0x2A76,0x2A77
,0x2A78,0x2A79,0x2A7A,0x2A7B,0x2A7C,0x2A7D,0x2A7E,0x2A7F,0x2A80,0x2A81,0x2A82,0x2A83,0x2A84
,0x2A85,0x2A86,0x2A87,0x2A88,0x2A89,0x2A8A,0x2A8B,0x2A8C,0x2A8D,0x2A8E,0x2A8F,0x2A90,0x2A91
,0x2A92,0x2A93,0x2A94,0x2A95,0x2A96,0x2A97,0x2A98,0x2A99,0x2A9A,0x2A9B,0x2A9C,0x2A9D,0x2A9E
,0x2A9F,0x2AA0,0x2AA1,0x2AA2,0x2AA3,0x2AA4,0x2AA5,0x2AA6,0x2AA7,0x2AA8,0x2AA9,0x2AAA,0x2AAB
,0x2AAC,0x2AAD,0x2AAE,0x2AAF,0x2AB0,0x2AB1,0x2AB2,0x2AB3,0x2AB4,0x2AB5,0x2AB6,0x2AB7,0x2AB8
,0x2AB9,0x2ABA,0x2ABB,0x2ABC,0x2ABD,0x2ABE,0x2ABF,0x2AC0,0x2AC1,0x2AC2,0x2AC3,0x2AC4,0x2AC5
,0x2AC6,0x2AC7,0x2AC8,0x2AC9,0x2ACA,0x2ACB,0x2ACC,0x2ACD,0x2ACE,0x2ACF,0x2AD0,0x2AD1,0x2AD2
,0x2AD3,0x2AD4,0x2AD5,0x2AD6,0x2AD7,0x2AD8,0x2AD9,0x2ADA,0x2ADB,0x2ADC,0x2ADD,0x2ADE,0x2ADF
,0x2AE0,0x2AE1,0x2AE2,0x2AE3,0x2AE4,0x2AE5,0x2AE6,0x2AE7,0x2AE8,0x2AE9,0x2AEA,0x2AEB,0x2AEC
,0x2AED,0x2AEE,0x2AEF,0x2AF0,0x2AF1,0x2AF2,0x2AF3,0x2AF4,0x2AF5,0x2AF6,0x2AF7,0x2AF8,0x2AF9
,0x2AFA,0x2AFB,0x2AFC,0x2AFD,0x2AFE,0x2AFF,0x2B00,0x2B01,0x2B02,0x2B03,0x2B04,0x2B05,0x2B06
,0x2B07,0x2B08,0x2B09,0x2B0A,0x2B0B,0x2B0C,0x2B0D,0x2B0E,0x2B0F,0x2B10,0x2B11,0x2B12,0x2B13
,0x2B14,0x2B15,0x2B16,0x2B17,0x2B18,0x2B19,0x2B1A,0x2B1B,0x2B1C,0x2B1D,0x2B1E,0x2B1F,0x2B20
,0x2B21,0x2B22,0x2B23,0x2B24,0x2B25,0x2B26,0x2B27,0x2B28,0x2B29,0x2B2A,0x2B2B,0x2B2C,0x2B2D
,0x2B2E,0x2B2F,0x2B30,0x2B31,0x2B32,0x2B33,0x2B34,0x2B35,0x2B36,0x2B37,0x2B38,0x2B39,0x2B3A
,0x2B3B,0x2B3C,0x2B3D,0x2B3E,0x2B3F,0x2B40,0x2B41,0x2B42,0x2B43,0x2B44,0x2B45,0x2B46,0x2B47
,0x2B48,0x2B49,0x2B4A,0x2B4B,0x2B4C,0x2B4D,0x2B4E,0x2B4F,0x2B50,0x2B51,0x2B52,0x2B53,0x2B54
,0x2B55,0x2B56,0x2B57,0x2B58,0x2B59,0x2B5A,0x2B5B,0x2B5C,0x2B5D,0x2B5E,0x2B5F,0x2B60,0x2B61
,0x2B62,0x2B63,0x2B64,0x2B65,0x2B66,0x2B67,0x2B68,0x2B69,0x2B6A,0x2B6B,0x2B6C,0x2B6D,0x2B6E
,0x2B6F,0x2B70,0x2B71,0x2B72,0x2B73,0x2B76,0x2B77,0x2B78,0x2B79,0x2B7A,0x2B7B,0x2B7C,0x2B7D
,0x2B7E,0x2B7F,0x2B80,0x2B81,0x2B82,0x2B83,0x2B84,0x2B85,0x2B86,0x2B87,0x2B88,0x2B89,0x2B8A
,0x2B8B,0x2B8C,0x2B8D,0x2B8E,0x2B8F,0x2B90,0x2B91,0x2B92,0x2B93,0x2B94,0x2B95,0x2B98,0x2B99
,0x2B9A,0x2B9B,0x2B9C,0x2B9D,0x2B9E,0x2B9F,0x2BA0,0x2BA1,0x2BA2,0x2BA3,0x2BA4,0x2BA5,0x2BA6
,0x2BA7,0x2BA8,0x2BA9,0x2BAA,0x2BAB,0x2BAC,0x2BAD,0x2BAE,0x2BAF,0x2BB0,0x2BB1,0x2BB2,0x2BB3
,0x2BB4,0x2BB5,0x2BB6,0x2BB7,0x2BB8,0x2BB9,0x2BBD,0x2BBE,0x2BBF,0x2BC0,0x2BC1,0x2BC2,0x2BC3
,0x2BC4,0x2BC5,0x2BC6,0x2BC7,0x2BC8,0x2BCA,0x2BCB,0x2BCC,0x2BCD,0x2BCE,0x2BCF,0x2BD0,0x2BD1
,0x2BD2,0x2BEC,0x2BED,0x2BEE,0x2BEF,0x2CE5,0x2CE6,0x2CE7,0x2CE8,0x2CE9,0x2CEA,0x2CF9,0x2CFA
,0x2CFB,0x2CFC,0x2CFD,0x2CFE,0x2CFF,0x2D70,0x2E00,0x2E01,0x2E02,0x2E03,0x2E04,0x2E05,0x2E06
,0x2E07,0x2E08,0x2E09,0x2E0A,0x2E0B,0x2E0C,0x2E0D,0x2E0E,0x2E0F,0x2E10,0x2E11,0x2E12,0x2E13
,0x2E14,0x2E15,0x2E16,0x2E17,0x2E18,0x2E19,0x2E1A,0x2E1B,0x2E1C,0x2E1D,0x2E1E,0x2E1F,0x2E20
,0x2E21,0x2E22,0x2E23,0x2E24,0x2E25,0x2E26,0x2E27,0x2E28,0x2E29,0x2E2A,0x2E2B,0x2E2C,0x2E2D
,0x2E2E,0x2E2F,0x2E30,0x2E31,0x2E32,0x2E33,0x2E34,0x2E35,0x2E36,0x2E37,0x2E38,0x2E39,0x2E3A
,0x2E3B,0x2E3C,0x2E3D,0x2E3E,0x2E3F,0x2E40,0x2E41,0x2E42,0x2E43,0x2E44,0x2E45,0x2E46,0x2E47
,0x2E48,0x2E49,0x2E80,0x2E81,0x2E82,0x2E83,0x2E84,0x2E85,0x2E86,0x2E87,0x2E88,0x2E89,0x2E8A
,0x2E8B,0x2E8C,0x2E8D,0x2E8E,0x2E8F,0x2E90,0x2E91,0x2E92,0x2E93,0x2E94,0x2E95,0x2E96,0x2E97
,0x2E98,0x2E99,0x2E9B,0x2E9C,0x2E9D,0x2E9E,0x2E9F,0x2EA0,0x2EA1,0x2EA2,0x2EA3,0x2EA4,0x2EA5
,0x2EA6,0x2EA7,0x2EA8,0x2EA9,0x2EAA,0x2EAB,0x2EAC,0x2EAD,0x2EAE,0x2EAF,0x2EB0,0x2EB1,0x2EB2
,0x2EB3,0x2EB4,0x2EB5,0x2EB6,0x2EB7,0x2EB8,0x2EB9,0x2EBA,0x2EBB,0x2EBC,0x2EBD,0x2EBE,0x2EBF
,0x2EC0,0x2EC1,0x2EC2,0x2EC3,0x2EC4,0x2EC5,0x2EC6,0x2EC7,0x2EC8,0x2EC9,0x2ECA,0x2ECB,0x2ECC
,0x2ECD,0x2ECE,0x2ECF,0x2ED0,0x2ED1,0x2ED2,0x2ED3,0x2ED4,0x2ED5,0x2ED6,0x2ED7,0x2ED8,0x2ED9
,0x2EDA,0x2EDB,0x2EDC,0x2EDD,0x2EDE,0x2EDF,0x2EE0,0x2EE1,0x2EE2,0x2EE3,0x2EE4,0x2EE5,0x2EE6
,0x2EE7,0x2EE8,0x2EE9,0x2EEA,0x2EEB,0x2EEC,0x2EED,0x2EEE,0x2EEF,0x2EF0,0x2EF1,0x2EF2,0x2EF3
,0x2F00,0x2F01,0x2F02,0x2F03,0x2F04,0x2F05,0x2F06,0x2F07,0x2F08,0x2F09,0x2F0A,0x2F0B,0x2F0C
,0x2F0D,0x2F0E,0x2F0F,0x2F10,0x2F11,0x2F12,0x2F13,0x2F14,0x2F15,0x2F16,0x2F17,0x2F18,0x2F19
,0x2F1A,0x2F1B,0x2F1C,0x2F1D,0x2F1E,0x2F1F,0x2F20,0x2F21,0x2F22,0x2F23,0x2F24,0x2F25,0x2F26
,0x2F27,0x2F28,0x2F29,0x2F2A,0x2F2B,0x2F2C,0x2F2D,0x2F2E,0x2F2F,0x2F30,0x2F31,0x2F32,0x2F33
,0x2F34,0x2F35,0x2F36,0x2F37,0x2F38,0x2F39,0x2F3A,0x2F3B,0x2F3C,0x2F3D,0x2F3E,0x2F3F,0x2F40
,0x2F41,0x2F42,0x2F43,0x2F44,0x2F45,0x2F46,0x2F47,0x2F48,0x2F49,0x2F4A,0x2F4B,0x2F4C,0x2F4D
,0x2F4E,0x2F4F,0x2F50,0x2F51,0x2F52,0x2F53,0x2F54,0x2F55,0x2F56,0x2F57,0x2F58,0x2F59,0x2F5A
,0x2F5B,0x2F5C,0x2F5D,0x2F5E,0x2F5F,0x2F60,0x2F61,0x2F62,0x2F63,0x2F64,0x2F65,0x2F66,0x2F67
,0x2F68,0x2F69,0x2F6A,0x2F6B,0x2F6C,0x2F6D,0x2F6E,0x2F6F,0x2F70,0x2F71,0x2F72,0x2F73,0x2F74
,0x2F75,0x2F76,0x2F77,0x2F78,0x2F79,0x2F7A,0x2F7B,0x2F7C,0x2F7D,0x2F7E,0x2F7F,0x2F80,0x2F81
,0x2F82,0x2F83,0x2F84,0x2F85,0x2F86,0x2F87,0x2F88,0x2F89,0x2F8A,0x2F8B,0x2F8C,0x2F8D,0x2F8E
,0x2F8F,0x2F90,0x2F91,0x2F92,0x2F93,0x2F94,0x2F95,0x2F96,0x2F97,0x2F98,0x2F99,0x2F9A,0x2F9B
,0x2F9C,0x2F9D,0x2F9E,0x2F9F,0x2FA0,0x2FA1,0x2FA2,0x2FA3,0x2FA4,0x2FA5,0x2FA6,0x2FA7,0x2FA8
,0x2FA9,0x2FAA,0x2FAB,0x2FAC,0x2FAD,0x2FAE,0x2FAF,0x2FB0,0x2FB1,0x2FB2,0x2FB3,0x2FB4,0x2FB5
,0x2FB6,0x2FB7,0x2FB8,0x2FB9,0x2FBA,0x2FBB,0x2FBC,0x2FBD,0x2FBE,0x2FBF,0x2FC0,0x2FC1,0x2FC2
,0x2FC3,0x2FC4,0x2FC5,0x2FC6,0x2FC7,0x2FC8,0x2FC9,0x2FCA,0x2FCB,0x2FCC,0x2FCD,0x2FCE,0x2FCF
,0x2FD0,0x2FD1,0x2FD2,0x2FD3,0x2FD4,0x2FD5,0x2FF0,0x2FF1,0x2FF2,0x2FF3,0x2FF4,0x2FF5,0x2FF6
,0x2FF7,0x2FF8,0x2FF9,0x2FFA,0x2FFB,0x3000,0x3001,0x3002,0x3003,0x3004,0x3008,0x3009,0x300A
,0x300B,0x300C,0x300D,0x300E,0x300F,0x3010,0x3011,0x3012,0x3013,0x3014,0x3015,0x3016,0x3017
,0x3018,0x3019,0x301A,0x301B,0x301C,0x301D,0x301E,0x301F,0x3020,0x3030,0x3036,0x3037,0x303D
,0x303E,0x303F,0x30A0,0x30FB,0x3190,0x3191,0x3192,0x3193,0x3194,0x3195,0x3196,0x3197,0x3198
,0x3199,0x319A,0x319B,0x319C,0x319D,0x319E,0x319F,0x31C0,0x31C1,0x31C2,0x31C3,0x31C4,0x31C5
,0x31C6,0x31C7,0x31C8,0x31C9,0x31CA,0x31CB,0x31CC,0x31CD,0x31CE,0x31CF,0x31D0,0x31D1,0x31D2
,0x31D3,0x31D4,0x31D5,0x31D6,0x31D7,0x31D8,0x31D9,0x31DA,0x31DB,0x31DC,0x31DD,0x31DE,0x31DF
,0x31E0,0x31E1,0x31E2,0x31E3,0x3200,0x3201,0x3202,0x3203,0x3204,0x3205,0x3206,0x3207,0x3208
,0x3209,0x320A,0x320B,0x320C,0x320D,0x320E,0x320F,0x3210,0x3211,0x3212,0x3213,0x3214,0x3215
,0x3216,0x3217,0x3218,0x3219,0x321A,0x321B,0x321C,0x321D,0x321E,0x3220,0x3221,0x3222,0x3223
,0x3224,0x3225,0x3226,0x3227,0x3228,0x3229,0x322A,0x322B,0x322C,0x322D,0x322E,0x322F,0x3230
,0x3231,0x3232,0x3233,0x3234,0x3235,0x3236,0x3237,0x3238,0x3239,0x323A,0x323B,0x323C,0x323D
,0x323E,0x323F,0x3240,0x3241,0x3242,0x3243,0x3244,0x3245,0x3246,0x3247,0x3248,0x3249,0x324A
,0x324B,0x324C,0x324D,0x324E,0x324F,0x3250,0x3251,0x3252,0x3253,0x3254,0x3255,0x3256,0x3257
,0x3258,0x3259,0x325A,0x325B,0x325C,0x325D,0x325E,0x325F,0x3260,0x3261,0x3262,0x3263,0x3264
,0x3265,0x3266,0x3267,0x3268,0x3269,0x326A,0x326B,0x326C,0x326D,0x326E,0x326F,0x3270,0x3271
,0x3272,0x3273,0x3274,0x3275,0x3276,0x3277,0x3278,0x3279,0x327A,0x327B,0x327C,0x327D,0x327E
,0x327F,0x3280,0x3281,0x3282,0x3283,0x3284,0x3285,0x3286,0x3287,0x3288,0x3289,0x328A,0x328B
,0x328C,0x328D,0x328E,0x328F,0x3290,0x3291,0x3292,0x3293,0x3294,0x3295,0x3296,0x3297,0x3298
,0x3299,0x329A,0x329B,0x329C,0x329D,0x329E,0x329F,0x32A0,0x32A1,0x32A2,0x32A3,0x32A4,0x32A5
,0x32A6,0x32A7,0x32A8,0x32A9,0x32AA,0x32AB,0x32AC,0x32AD,0x32AE,0x32AF,0x32B0,0x32B1,0x32B2
,0x32B3,0x32B4,0x32B5,0x32B6,0x32B7,0x32B8,0x32B9,0x32BA,0x32BB,0x32BC,0x32BD,0x32BE,0x32BF
,0x32C0,0x32C1,0x32C2,0x32C3,0x32C4,0x32C5,0x32C6,0x32C7,0x32C8,0x32C9,0x32CA,0x32CB,0x32CC
,0x32CD,0x32CE,0x32CF,0x32D0,0x32D1,0x32D2,0x32D3,0x32D4,0x32D5,0x32D6,0x32D7,0x32D8,0x32D9
,0x32DA,0x32DB,0x32DC,0x32DD,0x32DE,0x32DF,0x32E0,0x32E1,0x32E2,0x32E3,0x32E4,0x32E5,0x32E6
,0x32E7,0x32E8,0x32E9,0x32EA,0x32EB,0x32EC,0x32ED,0x32EE,0x32EF,0x32F0,0x32F1,0x32F2,0x32F3
,0x32F4,0x32F5,0x32F6,0x32F7,0x32F8,0x32F9,0x32FA,0x32FB,0x32FC,0x32FD,0x32FE,0x3300,0x3301
,0x3302,0x3303,0x3304,0x3305,0x3306,0x3307,0x3308,0x3309,0x330A,0x330B,0x330C,0x330D,0x330E
,0x330F,0x3310,0x3311,0x3312,0x3313,0x3314,0x3315,0x3316,0x3317,0x3318,0x3319,0x331A,0x331B
,0x331C,0x331D,0x331E,0x331F,0x3320,0x3321,0x3322,0x3323,0x3324,0x3325,0x3326,0x3327,0x3328
,0x3329,0x332A,0x332B,0x332C,0x332D,0x332E,0x332F,0x3330,0x3331,0x3332,0x3333,0x3334,0x3335
,0x3336,0x3337,0x3338,0x3339,0x333A,0x333B,0x333C,0x333D,0x333E,0x333F,0x3340,0x3341,0x3342
,0x3343,0x3344,0x3345,0x3346,0x3347,0x3348,0x3349,0x334A,0x334B,0x334C,0x334D,0x334E,0x334F
,0x3350,0x3351,0x3352,0x3353,0x3354,0x3355,0x3356,0x3357,0x3358,0x3359,0x335A,0x335B,0x335C
,0x335D,0x335E,0x335F,0x3360,0x3361,0x3362,0x3363,0x3364,0x3365,0x3366,0x3367,0x3368,0x3369
,0x336A,0x336B,0x336C,0x336D,0x336E,0x336F,0x3370,0x3371,0x3372,0x3373,0x3374,0x3375,0x3376
,0x3377,0x3378,0x3379,0x337A,0x337B,0x337C,0x337D,0x337E,0x337F,0x3380,0x3381,0x3382,0x3383
,0x3384,0x3385,0x3386,0x3387,0x3388,0x3389,0x338A,0x338B,0x338C,0x338D,0x338E,0x338F,0x3390
,0x3391,0x3392,0x3393,0x3394,0x3395,0x3396,0x3397,0x3398,0x3399,0x339A,0x339B,0x339C,0x339D
,0x339E,0x339F,0x33A0,0x33A1,0x33A2,0x33A3,0x33A4,0x33A5,0x33A6,0x33A7,0x33A8,0x33A9,0x33AA
,0x33AB,0x33AC,0x33AD,0x33AE,0x33AF,0x33B0,0x33B1,0x33B2,0x33B3,0x33B4,0x33B5,0x33B6,0x33B7
,0x33B8,0x33B9,0x33BA,0x33BB,0x33BC,0x33BD,0x33BE,0x33BF,0x33C0,0x33C1,0x33C2,0x33C3,0x33C4
,0x33C5,0x33C6,0x33C7,0x33C8,0x33C9,0x33CA,0x33CB,0x33CC,0x33CD,0x33CE,0x33CF,0x33D0,0x33D1
,0x33D2,0x33D3,0x33D4,0x33D5,0x33D6,0x33D7,0x33D8,0x33D9,0x33DA,0x33DB,0x33DC,0x33DD,0x33DE
,0x33DF,0x33E0,0x33E1,0x33E2,0x33E3,0x33E4,0x33E5,0x33E6,0x33E7,0x33E8,0x33E9,0x33EA,0x33EB
,0x33EC,0x33ED,0x33EE,0x33EF,0x33F0,0x33F1,0x33F2,0x33F3,0x33F4,0x33F5,0x33F6,0x33F7,0x33F8
,0x33F9,0x33FA,0x33FB,0x33FC,0x33FD,0x33FE,0x33FF,0x4DC0,0x4DC1,0x4DC2,0x4DC3,0x4DC4,0x4DC5
,0x4DC6,0x4DC7,0x4DC8,0x4DC9,0x4DCA,0x4DCB,0x4DCC,0x4DCD,0x4DCE,0x4DCF,0x4DD0,0x4DD1,0x4DD2
,0x4DD3,0x4DD4,0x4DD5,0x4DD6,0x4DD7,0x4DD8,0x4DD9,0x4DDA,0x4DDB,0x4DDC,0x4DDD,0x4DDE,0x4DDF
,0x4DE0,0x4DE1,0x4DE2,0x4DE3,0x4DE4,0x4DE5,0x4DE6,0x4DE7,0x4DE8,0x4DE9,0x4DEA,0x4DEB,0x4DEC
,0x4DED,0x4DEE,0x4DEF,0x4DF0,0x4DF1,0x4DF2,0x4DF3,0x4DF4,0x4DF5,0x4DF6,0x4DF7,0x4DF8,0x4DF9
,0x4DFA,0x4DFB,0x4DFC,0x4DFD,0x4DFE,0x4DFF,0xA490,0xA491,0xA492,0xA493,0xA494,0xA495,0xA496
,0xA497,0xA498,0xA499,0xA49A,0xA49B,0xA49C,0xA49D,0xA49E,0xA49F,0xA4A0,0xA4A1,0xA4A2,0xA4A3
,0xA4A4,0xA4A5,0xA4A6,0xA4A7,0xA4A8,0xA4A9,0xA4AA,0xA4AB,0xA4AC,0xA4AD,0xA4AE,0xA4AF,0xA4B0
,0xA4B1,0xA4B2,0xA4B3,0xA4B4,0xA4B5,0xA4B6,0xA4B7,0xA4B8,0xA4B9,0xA4BA,0xA4BB,0xA4BC,0xA4BD
,0xA4BE,0xA4BF,0xA4C0,0xA4C1,0xA4C2,0xA4C3,0xA4C4,0xA4C5,0xA4C6,0xA4FE,0xA4FF,0xA60D,0xA60E
,0xA60F,0xA670,0xA671,0xA672,0xA673,0xA67E,0xA6F2,0xA6F3,0xA6F4,0xA6F5,0xA6F6,0xA6F7,0xA700
,0xA701,0xA702,0xA703,0xA704,0xA705,0xA706,0xA707,0xA708,0xA709,0xA70A,0xA70B,0xA70C,0xA70D
,0xA70E,0xA70F,0xA710,0xA711,0xA712,0xA713,0xA714,0xA715,0xA716,0xA720,0xA721,0xA789,0xA78A
,0xA828,0xA829,0xA82A,0xA82B,0xA830,0xA831,0xA832,0xA833,0xA834,0xA835,0xA836,0xA837,0xA838
,0xA839,0xA874,0xA875,0xA876,0xA877,0xA8CE,0xA8CF,0xA8F8,0xA8F9,0xA8FA,0xA8FC,0xA92E,0xA92F
,0xA95F,0xA9C1,0xA9C2,0xA9C3,0xA9C4,0xA9C5,0xA9C6,0xA9C7,0xA9C8,0xA9C9,0xA9CA,0xA9CB,0xA9CC
,0xA9CD,0xA9DE,0xA9DF,0xAA5C,0xAA5D,0xAA5E,0xAA5F,0xAA77,0xAA78,0xAA79,0xAADE,0xAADF,0xAAF0
,0xAAF1,0xAB5B,0xABEB,0xFB29,0xFBB2,0xFBB3,0xFBB4,0xFBB5,0xFBB6,0xFBB7,0xFBB8,0xFBB9,0xFBBA
,0xFBBB,0xFBBC,0xFBBD,0xFBBE,0xFBBF,0xFBC0,0xFBC1,0xFD3E,0xFD3F,0xFDFC,0xFDFD,0xFE10,0xFE11
,0xFE12,0xFE13,0xFE14,0xFE15,0xFE16,0xFE17,0xFE18,0xFE19,0xFE30,0xFE31,0xFE32,0xFE35,0xFE36
,0xFE37,0xFE38,0xFE39,0xFE3A,0xFE3B,0xFE3C,0xFE3D,0xFE3E,0xFE3F,0xFE40,0xFE41,0xFE42,0xFE43
,0xFE44,0xFE45,0xFE46,0xFE47,0xFE48,0xFE49,0xFE4A,0xFE4B,0xFE4C,0xFE50,0xFE51,0xFE52,0xFE54
,0xFE55,0xFE56,0xFE57,0xFE58,0xFE59,0xFE5A,0xFE5B,0xFE5C,0xFE5D,0xFE5E,0xFE5F,0xFE60,0xFE61
,0xFE62,0xFE63,0xFE64,0xFE65,0xFE66,0xFE68,0xFE69,0xFE6A,0xFE6B,0xFEFF,0xFF01,0xFF02,0xFF03
,0xFF04,0xFF05,0xFF06,0xFF07,0xFF08,0xFF09,0xFF0A,0xFF0B,0xFF0C,0xFF0D,0xFF0E,0xFF0F,0xFF1A
,0xFF1B,0xFF1C,0xFF1D,0xFF1E,0xFF1F,0xFF20,0xFF3B,0xFF3C,0xFF3D,0xFF3E,0xFF40,0xFF5B,0xFF5C
,0xFF5D,0xFF5E,0xFF5F,0xFF60,0xFF61,0xFF62,0xFF63,0xFF64,0xFF65,0xFFE0,0xFFE1,0xFFE2,0xFFE3
,0xFFE4,0xFFE5,0xFFE6,0xFFE8,0xFFE9,0xFFEA,0xFFEB,0xFFEC,0xFFED,0xFFEE,0xFFF9,0xFFFA,0xFFFB
,0xFFFC,0xFFFD,0x10100,0x10101,0x10102,0x10107,0x10108,0x10109,0x1010A,0x1010B,0x1010C,0x1010D
,0x1010E,0x1010F,0x10110,0x10111,0x10112,0x10113,0x10114,0x10115,0x10116,0x10117,0x10118,0x10119
,0x1011A,0x1011B,0x1011C,0x1011D,0x1011E,0x1011F,0x10120,0x10121,0x10122,0x10123,0x10124,0x10125
,0x10126,0x10127,0x10128,0x10129,0x1012A,0x1012B,0x1012C,0x1012D,0x1012E,0x1012F,0x10130,0x10131
,0x10132,0x10133,0x10137,0x10138,0x10139,0x1013A,0x1013B,0x1013C,0x1013D,0x1013E,0x1013F,0x10175
,0x10176,0x10177,0x10178,0x10179,0x1017A,0x1017B,0x1017C,0x1017D,0x1017E,0x1017F,0x10180,0x10181
,0x10182,0x10183,0x10184,0x10185,0x10186,0x10187,0x10188,0x10189,0x1018A,0x1018B,0x1018C,0x1018D
,0x1018E,0x10190,0x10191,0x10192,0x10193,0x10194,0x10195,0x10196,0x10197,0x10198,0x10199,0x1019A
,0x1019B,0x101A0,0x101D0,0x101D1,0x101D2,0x101D3,0x101D4,0x101D5,0x101D6,0x101D7,0x101D8,0x101D9
,0x101DA,0x101DB,0x101DC,0x101DD,0x101DE,0x101DF,0x101E0,0x101E1,0x101E2,0x101E3,0x101E4,0x101E5
,0x101E6,0x101E7,0x101E8,0x101E9,0x101EA,0x101EB,0x101EC,0x101ED,0x101EE,0x101EF,0x101F0,0x101F1
,0x101F2,0x101F3,0x101F4,0x101F5,0x101F6,0x101F7,0x101F8,0x101F9,0x101FA,0x101FB,0x101FC,0x102E1
,0x102E2,0x102E3,0x102E4,0x102E5,0x102E6,0x102E7,0x102E8,0x102E9,0x102EA,0x102EB,0x102EC,0x102ED
,0x102EE,0x102EF,0x102F0,0x102F1,0x102F2,0x102F3,0x102F4,0x102F5,0x102F6,0x102F7,0x102F8,0x102F9
,0x102FA,0x102FB,0x10320,0x10321,0x10322,0x10323,0x1039F,0x103D0,0x1056F,0x10857,0x10858,0x10859
,0x1085A,0x1085B,0x1085C,0x1085D,0x1085E,0x1085F,0x10877,0x10878,0x10879,0x1087A,0x1087B,0x1087C
,0x1087D,0x1087E,0x1087F,0x108A7,0x108A8,0x108A9,0x108AA,0x108AB,0x108AC,0x108AD,0x108AE,0x108AF
,0x108FB,0x108FC,0x108FD,0x108FE,0x108FF,0x10916,0x10917,0x10918,0x10919,0x1091A,0x1091B,0x1091F
,0x1093F,0x109BC,0x109BD,0x109C0,0x109C1,0x109C2,0x109C3,0x109C4,0x109C5,0x109C6,0x109C7,0x109C8
,0x109C9,0x109CA,0x109CB,0x109CC,0x109CD,0x109CE,0x109CF,0x109D2,0x109D3,0x109D4,0x109D5,0x109D6
,0x109D7,0x109D8,0x109D9,0x109DA,0x109DB,0x109DC,0x109DD,0x109DE,0x109DF,0x109E0,0x109E1,0x109E2
,0x109E3,0x109E4,0x109E5,0x109E6,0x109E7,0x109E8,0x109E9,0x109EA,0x109EB,0x109EC,0x109ED,0x109EE
,0x109EF,0x109F0,0x109F1,0x109F2,0x109F3,0x109F4,0x109F5,0x109F6,0x109F7,0x109F8,0x109F9,0x109FA
,0x109FB,0x109FC,0x109FD,0x109FE,0x109FF,0x10A40,0x10A41,0x10A42,0x10A43,0x10A44,0x10A45,0x10A46
,0x10A47,0x10A50,0x10A51,0x10A52,0x10A53,0x10A54,0x10A55,0x10A56,0x10A57,0x10A58,0x10A7D,0x10A7E
,0x10A7F,0x10A9D,0x10A9E,0x10A9F,0x10AC8,0x10AEB,0x10AEC,0x10AED,0x10AEE,0x10AEF,0x10AF0,0x10AF1
,0x10AF2,0x10AF3,0x10AF4,0x10AF5,0x10AF6,0x10B39,0x10B3A,0x10B3B,0x10B3C,0x10B3D,0x10B3E,0x10B3F
,0x10B58,0x10B59,0x10B5A,0x10B5B,0x10B5C,0x10B5D,0x10B5E,0x10B5F,0x10B78,0x10B79,0x10B7A,0x10B7B
,0x10B7C,0x10B7D,0x10B7E,0x10B7F,0x10B99,0x10B9A,0x10B9B,0x10B9C,0x10BA9,0x10BAA,0x10BAB,0x10BAC
,0x10BAD,0x10BAE,0x10BAF,0x10CFA,0x10CFB,0x10CFC,0x10CFD,0x10CFE,0x10CFF,0x10E60,0x10E61,0x10E62
,0x10E63,0x10E64,0x10E65,0x10E66,0x10E67,0x10E68,0x10E69,0x10E6A,0x10E6B,0x10E6C,0x10E6D,0x10E6E
,0x10E6F,0x10E70,0x10E71,0x10E72,0x10E73,0x10E74,0x10E75,0x10E76,0x10E77,0x10E78,0x10E79,0x10E7A
,0x10E7B,0x10E7C,0x10E7D,0x10E7E,0x11047,0x11048,0x11049,0x1104A,0x1104B,0x1104C,0x1104D,0x11052
,0x11053,0x11054,0x11055,0x11056,0x11057,0x11058,0x11059,0x1105A,0x1105B,0x1105C,0x1105D,0x1105E
,0x1105F,0x11060,0x11061,0x11062,0x11063,0x11064,0x11065,0x110BB,0x110BC,0x110BD,0x110BE,0x110BF
,0x110C0,0x110C1,0x11140,0x11141,0x11142,0x11143,0x11174,0x11175,0x111C5,0x111C6,0x111C7,0x111C8
,0x111C9,0x111CD,0x111DB,0x111DD,0x111DE,0x111DF,0x111E1,0x111E2,0x111E3,0x111E4,0x111E5,0x111E6
,0x111E7,0x111E8,0x111E9,0x111EA,0x111EB,0x111EC,0x111ED,0x111EE,0x111EF,0x111F0,0x111F1,0x111F2
,0x111F3,0x111F4,0x11238,0x11239,0x1123A,0x1123B,0x1123C,0x1123D,0x112A9,0x1144B,0x1144C,0x1144D
,0x1144E,0x1144F,0x1145B,0x1145D,0x114C6,0x115C1,0x115C2,0x115C3,0x115C4,0x115C5,0x115C6,0x115C7
,0x115C8,0x115C9,0x115CA,0x115CB,0x115CC,0x115CD,0x115CE,0x115CF,0x115D0,0x115D1,0x115D2,0x115D3
,0x115D4,0x115D5,0x115D6,0x115D7,0x11641,0x11642,0x11643,0x11660,0x11661,0x11662,0x11663,0x11664
,0x11665,0x11666,0x11667,0x11668,0x11669,0x1166A,0x1166B,0x1166C,0x1173A,0x1173B,0x1173C,0x1173D
,0x1173E,0x1173F,0x118EA,0x118EB,0x118EC,0x118ED,0x118EE,0x118EF,0x118F0,0x118F1,0x118F2,0x11A3F
,0x11A40,0x11A41,0x11A42,0x11A43,0x11A44,0x11A45,0x11A46,0x11A9A,0x11A9B,0x11A9C,0x11A9E,0x11A9F
,0x11AA0,0x11AA1,0x11AA2,0x11C41,0x11C42,0x11C43,0x11C44,0x11C45,0x11C5A,0x11C5B,0x11C5C,0x11C5D
,0x11C5E,0x11C5F,0x11C60,0x11C61,0x11C62,0x11C63,0x11C64,0x11C65,0x11C66,0x11C67,0x11C68,0x11C69
,0x11C6A,0x11C6B,0x11C6C,0x11C70,0x11C71,0x12470,0x12471,0x12472,0x12473,0x12474,0x16A6E,0x16A6F
,0x16AF5,0x16B37,0x16B38,0x16B39,0x16B3A,0x16B3B,0x16B3C,0x16B3D,0x16B3E,0x16B3F,0x16B44,0x16B45
,0x16B5B,0x16B5C,0x16B5D,0x16B5E,0x16B5F,0x16B60,0x16B61,0x1BC9C,0x1BC9F,0x1BCA0,0x1BCA1,0x1BCA2
,0x1BCA3,0x1D000,0x1D001,0x1D002,0x1D003,0x1D004,0x1D005,0x1D006,0x1D007,0x1D008,0x1D009,0x1D00A
,0x1D00B,0x1D00C,0x1D00D,0x1D00E,0x1D00F,0x1D010,0x1D011,0x1D012,0x1D013,0x1D014,0x1D015,0x1D016
,0x1D017,0x1D018,0x1D019,0x1D01A,0x1D01B,0x1D01C,0x1D01D,0x1D01E,0x1D01F,0x1D020,0x1D021,0x1D022
,0x1D023,0x1D024,0x1D025,0x1D026,0x1D027,0x1D028,0x1D029,0x1D02A,0x1D02B,0x1D02C,0x1D02D,0x1D02E
,0x1D02F,0x1D030,0x1D031,0x1D032,0x1D033,0x1D034,0x1D035,0x1D036,0x1D037,0x1D038,0x1D039,0x1D03A
,0x1D03B,0x1D03C,0x1D03D,0x1D03E,0x1D03F,0x1D040,0x1D041,0x1D042,0x1D043,0x1D044,0x1D045,0x1D046
,0x1D047,0x1D048,0x1D049,0x1D04A,0x1D04B,0x1D04C,0x1D04D,0x1D04E,0x1D04F,0x1D050,0x1D051,0x1D052
,0x1D053,0x1D054,0x1D055,0x1D056,0x1D057,0x1D058,0x1D059,0x1D05A,0x1D05B,0x1D05C,0x1D05D,0x1D05E
,0x1D05F,0x1D060,0x1D061,0x1D062,0x1D063,0x1D064,0x1D065,0x1D066,0x1D067,0x1D068,0x1D069,0x1D06A
,0x1D06B,0x1D06C,0x1D06D,0x1D06E,0x1D06F,0x1D070,0x1D071,0x1D072,0x1D073,0x1D074,0x1D075,0x1D076
,0x1D077,0x1D078,0x1D079,0x1D07A,0x1D07B,0x1D07C,0x1D07D,0x1D07E,0x1D07F,0x1D080,0x1D081,0x1D082
,0x1D083,0x1D084,0x1D085,0x1D086,0x1D087,0x1D088,0x1D089,0x1D08A,0x1D08B,0x1D08C,0x1D08D,0x1D08E
,0x1D08F,0x1D090,0x1D091,0x1D092,0x1D093,0x1D094,0x1D095,0x1D096,0x1D097,0x1D098,0x1D099,0x1D09A
,0x1D09B,0x1D09C,0x1D09D,0x1D09E,0x1D09F,0x1D0A0,0x1D0A1,0x1D0A2,0x1D0A3,0x1D0A4,0x1D0A5,0x1D0A6
,0x1D0A7,0x1D0A8,0x1D0A9,0x1D0AA,0x1D0AB,0x1D0AC,0x1D0AD,0x1D0AE,0x1D0AF,0x1D0B0,0x1D0B1,0x1D0B2
,0x1D0B3,0x1D0B4,0x1D0B5,0x1D0B6,0x1D0B7,0x1D0B8,0x1D0B9,0x1D0BA,0x1D0BB,0x1D0BC,0x1D0BD,0x1D0BE
,0x1D0BF,0x1D0C0,0x1D0C1,0x1D0C2,0x1D0C3,0x1D0C4,0x1D0C5,0x1D0C6,0x1D0C7,0x1D0C8,0x1D0C9,0x1D0CA
,0x1D0CB,0x1D0CC,0x1D0CD,0x1D0CE,0x1D0CF,0x1D0D0,0x1D0D1,0x1D0D2,0x1D0D3,0x1D0D4,0x1D0D5,0x1D0D6
,0x1D0D7,0x1D0D8,0x1D0D9,0x1D0DA,0x1D0DB,0x1D0DC,0x1D0DD,0x1D0DE,0x1D0DF,0x1D0E0,0x1D0E1,0x1D0E2
,0x1D0E3,0x1D0E4,0x1D0E5,0x1D0E6,0x1D0E7,0x1D0E8,0x1D0E9,0x1D0EA,0x1D0EB,0x1D0EC,0x1D0ED,0x1D0EE
,0x1D0EF,0x1D0F0,0x1D0F1,0x1D0F2,0x1D0F3,0x1D0F4,0x1D0F5,0x1D100,0x1D101,0x1D102,0x1D103,0x1D104
,0x1D105,0x1D106,0x1D107,0x1D108,0x1D109,0x1D10A,0x1D10B,0x1D10C,0x1D10D,0x1D10E,0x1D10F,0x1D110
,0x1D111,0x1D112,0x1D113,0x1D114,0x1D115,0x1D116,0x1D117,0x1D118,0x1D119,0x1D11A,0x1D11B,0x1D11C
,0x1D11D,0x1D11E,0x1D11F,0x1D120,0x1D121,0x1D122,0x1D123,0x1D124,0x1D125,0x1D126,0x1D129,0x1D12A
,0x1D12B,0x1D12C,0x1D12D,0x1D12E,0x1D12F,0x1D130,0x1D131,0x1D132,0x1D133,0x1D134,0x1D135,0x1D136
,0x1D137,0x1D138,0x1D139,0x1D13A,0x1D13B,0x1D13C,0x1D13D,0x1D13E,0x1D13F,0x1D140,0x1D141,0x1D142
,0x1D143,0x1D144,0x1D145,0x1D146,0x1D147,0x1D148,0x1D149,0x1D14A,0x1D14B,0x1D14C,0x1D14D,0x1D14E
,0x1D14F,0x1D150,0x1D151,0x1D152,0x1D153,0x1D154,0x1D155,0x1D156,0x1D157,0x1D158,0x1D159,0x1D15A
,0x1D15B,0x1D15C,0x1D15D,0x1D15E,0x1D15F,0x1D160,0x1D161,0x1D162,0x1D163,0x1D164,0x1D16A,0x1D16B
,0x1D16C,0x1D173,0x1D174,0x1D175,0x1D176,0x1D177,0x1D178,0x1D179,0x1D17A,0x1D183,0x1D184,0x1D18C
,0x1D18D,0x1D18E,0x1D18F,0x1D190,0x1D191,0x1D192,0x1D193,0x1D194,0x1D195,0x1D196,0x1D197,0x1D198
,0x1D199,0x1D19A,0x1D19B,0x1D19C,0x1D19D,0x1D19E,0x1D19F,0x1D1A0,0x1D1A1,0x1D1A2,0x1D1A3,0x1D1A4
,0x1D1A5,0x1D1A6,0x1D1A7,0x1D1A8,0x1D1A9,0x1D1AE,0x1D1AF,0x1D1B0,0x1D1B1,0x1D1B2,0x1D1B3,0x1D1B4
,0x1D1B5,0x1D1B6,0x1D1B7,0x1D1B8,0x1D1B9,0x1D1BA,0x1D1BB,0x1D1BC,0x1D1BD,0x1D1BE,0x1D1BF,0x1D1C0
,0x1D1C1,0x1D1C2,0x1D1C3,0x1D1C4,0x1D1C5,0x1D1C6,0x1D1C7,0x1D1C8,0x1D1C9,0x1D1CA,0x1D1CB,0x1D1CC
,0x1D1CD,0x1D1CE,0x1D1CF,0x1D1D0,0x1D1D1,0x1D1D2,0x1D1D3,0x1D1D4,0x1D1D5,0x1D1D6,0x1D1D7,0x1D1D8
,0x1D1D9,0x1D1DA,0x1D1DB,0x1D1DC,0x1D1DD,0x1D1DE,0x1D1DF,0x1D1E0,0x1D1E1,0x1D1E2,0x1D1E3,0x1D1E4
,0x1D1E5,0x1D1E6,0x1D1E7,0x1D1E8,0x1D200,0x1D201,0x1D202,0x1D203,0x1D204,0x1D205,0x1D206,0x1D207
,0x1D208,0x1D209,0x1D20A,0x1D20B,0x1D20C,0x1D20D,0x1D20E,0x1D20F,0x1D210,0x1D211,0x1D212,0x1D213
,0x1D214,0x1D215,0x1D216,0x1D217,0x1D218,0x1D219,0x1D21A,0x1D21B,0x1D21C,0x1D21D,0x1D21E,0x1D21F
,0x1D220,0x1D221,0x1D222,0x1D223,0x1D224,0x1D225,0x1D226,0x1D227,0x1D228,0x1D229,0x1D22A,0x1D22B
,0x1D22C,0x1D22D,0x1D22E,0x1D22F,0x1D230,0x1D231,0x1D232,0x1D233,0x1D234,0x1D235,0x1D236,0x1D237
,0x1D238,0x1D239,0x1D23A,0x1D23B,0x1D23C,0x1D23D,0x1D23E,0x1D23F,0x1D240,0x1D241,0x1D245,0x1D300
,0x1D301,0x1D302,0x1D303,0x1D304,0x1D305,0x1D306,0x1D307,0x1D308,0x1D309,0x1D30A,0x1D30B,0x1D30C
,0x1D30D,0x1D30E,0x1D30F,0x1D310,0x1D311,0x1D312,0x1D313,0x1D314,0x1D315,0x1D316,0x1D317,0x1D318
,0x1D319,0x1D31A,0x1D31B,0x1D31C,0x1D31D,0x1D31E,0x1D31F,0x1D320,0x1D321,0x1D322,0x1D323,0x1D324
,0x1D325,0x1D326,0x1D327,0x1D328,0x1D329,0x1D32A,0x1D32B,0x1D32C,0x1D32D,0x1D32E,0x1D32F,0x1D330
,0x1D331,0x1D332,0x1D333,0x1D334,0x1D335,0x1D336,0x1D337,0x1D338,0x1D339,0x1D33A,0x1D33B,0x1D33C
,0x1D33D,0x1D33E,0x1D33F,0x1D340,0x1D341,0x1D342,0x1D343,0x1D344,0x1D345,0x1D346,0x1D347,0x1D348
,0x1D349,0x1D34A,0x1D34B,0x1D34C,0x1D34D,0x1D34E,0x1D34F,0x1D350,0x1D351,0x1D352,0x1D353,0x1D354
,0x1D355,0x1D356,0x1D360,0x1D361,0x1D362,0x1D363,0x1D364,0x1D365,0x1D366,0x1D367,0x1D368,0x1D369
,0x1D36A,0x1D36B,0x1D36C,0x1D36D,0x1D36E,0x1D36F,0x1D370,0x1D371,0x1D6C1,0x1D6DB,0x1D6FB,0x1D715
,0x1D735,0x1D74F,0x1D76F,0x1D789,0x1D7A9,0x1D7C3,0x1D800,0x1D801,0x1D802,0x1D803,0x1D804,0x1D805
,0x1D806,0x1D807,0x1D808,0x1D809,0x1D80A,0x1D80B,0x1D80C,0x1D80D,0x1D80E,0x1D80F,0x1D810,0x1D811
,0x1D812,0x1D813,0x1D814,0x1D815,0x1D816,0x1D817,0x1D818,0x1D819,0x1D81A,0x1D81B,0x1D81C,0x1D81D
,0x1D81E,0x1D81F,0x1D820,0x1D821,0x1D822,0x1D823,0x1D824,0x1D825,0x1D826,0x1D827,0x1D828,0x1D829
,0x1D82A,0x1D82B,0x1D82C,0x1D82D,0x1D82E,0x1D82F,0x1D830,0x1D831,0x1D832,0x1D833,0x1D834,0x1D835
,0x1D836,0x1D837,0x1D838,0x1D839,0x1D83A,0x1D83B,0x1D83C,0x1D83D,0x1D83E,0x1D83F,0x1D840,0x1D841
,0x1D842,0x1D843,0x1D844,0x1D845,0x1D846,0x1D847,0x1D848,0x1D849,0x1D84A,0x1D84B,0x1D84C,0x1D84D
,0x1D84E,0x1D84F,0x1D850,0x1D851,0x1D852,0x1D853,0x1D854,0x1D855,0x1D856,0x1D857,0x1D858,0x1D859
,0x1D85A,0x1D85B,0x1D85C,0x1D85D,0x1D85E,0x1D85F,0x1D860,0x1D861,0x1D862,0x1D863,0x1D864,0x1D865
,0x1D866,0x1D867,0x1D868,0x1D869,0x1D86A,0x1D86B,0x1D86C,0x1D86D,0x1D86E,0x1D86F,0x1D870,0x1D871
,0x1D872,0x1D873,0x1D874,0x1D875,0x1D876,0x1D877,0x1D878,0x1D879,0x1D87A,0x1D87B,0x1D87C,0x1D87D
,0x1D87E,0x1D87F,0x1D880,0x1D881,0x1D882,0x1D883,0x1D884,0x1D885,0x1D886,0x1D887,0x1D888,0x1D889
,0x1D88A,0x1D88B,0x1D88C,0x1D88D,0x1D88E,0x1D88F,0x1D890,0x1D891,0x1D892,0x1D893,0x1D894,0x1D895
,0x1D896,0x1D897,0x1D898,0x1D899,0x1D89A,0x1D89B,0x1D89C,0x1D89D,0x1D89E,0x1D89F,0x1D8A0,0x1D8A1
,0x1D8A2,0x1D8A3,0x1D8A4,0x1D8A5,0x1D8A6,0x1D8A7,0x1D8A8,0x1D8A9,0x1D8AA,0x1D8AB,0x1D8AC,0x1D8AD
,0x1D8AE,0x1D8AF,0x1D8B0,0x1D8B1,0x1D8B2,0x1D8B3,0x1D8B4,0x1D8B5,0x1D8B6,0x1D8B7,0x1D8B8,0x1D8B9
,0x1D8BA,0x1D8BB,0x1D8BC,0x1D8BD,0x1D8BE,0x1D8BF,0x1D8C0,0x1D8C1,0x1D8C2,0x1D8C3,0x1D8C4,0x1D8C5
,0x1D8C6,0x1D8C7,0x1D8C8,0x1D8C9,0x1D8CA,0x1D8CB,0x1D8CC,0x1D8CD,0x1D8CE,0x1D8CF,0x1D8D0,0x1D8D1
,0x1D8D2,0x1D8D3,0x1D8D4,0x1D8D5,0x1D8D6,0x1D8D7,0x1D8D8,0x1D8D9,0x1D8DA,0x1D8DB,0x1D8DC,0x1D8DD
,0x1D8DE,0x1D8DF,0x1D8E0,0x1D8E1,0x1D8E2,0x1D8E3,0x1D8E4,0x1D8E5,0x1D8E6,0x1D8E7,0x1D8E8,0x1D8E9
,0x1D8EA,0x1D8EB,0x1D8EC,0x1D8ED,0x1D8EE,0x1D8EF,0x1D8F0,0x1D8F1,0x1D8F2,0x1D8F3,0x1D8F4,0x1D8F5
,0x1D8F6,0x1D8F7,0x1D8F8,0x1D8F9,0x1D8FA,0x1D8FB,0x1D8FC,0x1D8FD,0x1D8FE,0x1D8FF,0x1D900,0x1D901
,0x1D902,0x1D903,0x1D904,0x1D905,0x1D906,0x1D907,0x1D908,0x1D909,0x1D90A,0x1D90B,0x1D90C,0x1D90D
,0x1D90E,0x1D90F,0x1D910,0x1D911,0x1D912,0x1D913,0x1D914,0x1D915,0x1D916,0x1D917,0x1D918,0x1D919
,0x1D91A,0x1D91B,0x1D91C,0x1D91D,0x1D91E,0x1D91F,0x1D920,0x1D921,0x1D922,0x1D923,0x1D924,0x1D925
,0x1D926,0x1D927,0x1D928,0x1D929,0x1D92A,0x1D92B,0x1D92C,0x1D92D,0x1D92E,0x1D92F,0x1D930,0x1D931
,0x1D932,0x1D933,0x1D934,0x1D935,0x1D936,0x1D937,0x1D938,0x1D939,0x1D93A,0x1D93B,0x1D93C,0x1D93D
,0x1D93E,0x1D93F,0x1D940,0x1D941,0x1D942,0x1D943,0x1D944,0x1D945,0x1D946,0x1D947,0x1D948,0x1D949
,0x1D94A,0x1D94B,0x1D94C,0x1D94D,0x1D94E,0x1D94F,0x1D950,0x1D951,0x1D952,0x1D953,0x1D954,0x1D955
,0x1D956,0x1D957,0x1D958,0x1D959,0x1D95A,0x1D95B,0x1D95C,0x1D95D,0x1D95E,0x1D95F,0x1D960,0x1D961
,0x1D962,0x1D963,0x1D964,0x1D965,0x1D966,0x1D967,0x1D968,0x1D969,0x1D96A,0x1D96B,0x1D96C,0x1D96D
,0x1D96E,0x1D96F,0x1D970,0x1D971,0x1D972,0x1D973,0x1D974,0x1D975,0x1D976,0x1D977,0x1D978,0x1D979
,0x1D97A,0x1D97B,0x1D97C,0x1D97D,0x1D97E,0x1D97F,0x1D980,0x1D981,0x1D982,0x1D983,0x1D984,0x1D985
,0x1D986,0x1D987,0x1D988,0x1D989,0x1D98A,0x1D98B,0x1D98C,0x1D98D,0x1D98E,0x1D98F,0x1D990,0x1D991
,0x1D992,0x1D993,0x1D994,0x1D995,0x1D996,0x1D997,0x1D998,0x1D999,0x1D99A,0x1D99B,0x1D99C,0x1D99D
,0x1D99E,0x1D99F,0x1D9A0,0x1D9A1,0x1D9A2,0x1D9A3,0x1D9A4,0x1D9A5,0x1D9A6,0x1D9A7,0x1D9A8,0x1D9A9
,0x1D9AA,0x1D9AB,0x1D9AC,0x1D9AD,0x1D9AE,0x1D9AF,0x1D9B0,0x1D9B1,0x1D9B2,0x1D9B3,0x1D9B4,0x1D9B5
,0x1D9B6,0x1D9B7,0x1D9B8,0x1D9B9,0x1D9BA,0x1D9BB,0x1D9BC,0x1D9BD,0x1D9BE,0x1D9BF,0x1D9C0,0x1D9C1
,0x1D9C2,0x1D9C3,0x1D9C4,0x1D9C5,0x1D9C6,0x1D9C7,0x1D9C8,0x1D9C9,0x1D9CA,0x1D9CB,0x1D9CC,0x1D9CD
,0x1D9CE,0x1D9CF,0x1D9D0,0x1D9D1,0x1D9D2,0x1D9D3,0x1D9D4,0x1D9D5,0x1D9D6,0x1D9D7,0x1D9D8,0x1D9D9
,0x1D9DA,0x1D9DB,0x1D9DC,0x1D9DD,0x1D9DE,0x1D9DF,0x1D9E0,0x1D9E1,0x1D9E2,0x1D9E3,0x1D9E4,0x1D9E5
,0x1D9E6,0x1D9E7,0x1D9E8,0x1D9E9,0x1D9EA,0x1D9EB,0x1D9EC,0x1D9ED,0x1D9EE,0x1D9EF,0x1D9F0,0x1D9F1
,0x1D9F2,0x1D9F3,0x1D9F4,0x1D9F5,0x1D9F6,0x1D9F7,0x1D9F8,0x1D9F9,0x1D9FA,0x1D9FB,0x1D9FC,0x1D9FD
,0x1D9FE,0x1D9FF,0x1DA37,0x1DA38,0x1DA39,0x1DA3A,0x1DA6D,0x1DA6E,0x1DA6F,0x1DA70,0x1DA71,0x1DA72
,0x1DA73,0x1DA74,0x1DA76,0x1DA77,0x1DA78,0x1DA79,0x1DA7A,0x1DA7B,0x1DA7C,0x1DA7D,0x1DA7E,0x1DA7F
,0x1DA80,0x1DA81,0x1DA82,0x1DA83,0x1DA85,0x1DA86,0x1DA87,0x1DA88,0x1DA89,0x1DA8A,0x1DA8B,0x1E8C7
,0x1E8C8,0x1E8C9,0x1E8CA,0x1E8CB,0x1E8CC,0x1E8CD,0x1E8CE,0x1E8CF,0x1E95E,0x1E95F,0x1EEF0,0x1EEF1
,0x1F000,0x1F001,0x1F002,0x1F003,0x1F004,0x1F005,0x1F006,0x1F007,0x1F008,0x1F009,0x1F00A,0x1F00B
,0x1F00C,0x1F00D,0x1F00E,0x1F00F,0x1F010,0x1F011,0x1F012,0x1F013,0x1F014,0x1F015,0x1F016,0x1F017
,0x1F018,0x1F019,0x1F01A,0x1F01B,0x1F01C,0x1F01D,0x1F01E,0x1F01F,0x1F020,0x1F021,0x1F022,0x1F023
,0x1F024,0x1F025,0x1F026,0x1F027,0x1F028,0x1F029,0x1F02A,0x1F02B,0x1F030,0x1F031,0x1F032,0x1F033
,0x1F034,0x1F035,0x1F036,0x1F037,0x1F038,0x1F039,0x1F03A,0x1F03B,0x1F03C,0x1F03D,0x1F03E,0x1F03F
,0x1F040,0x1F041,0x1F042,0x1F043,0x1F044,0x1F045,0x1F046,0x1F047,0x1F048,0x1F049,0x1F04A,0x1F04B
,0x1F04C,0x1F04D,0x1F04E,0x1F04F,0x1F050,0x1F051,0x1F052,0x1F053,0x1F054,0x1F055,0x1F056,0x1F057
,0x1F058,0x1F059,0x1F05A,0x1F05B,0x1F05C,0x1F05D,0x1F05E,0x1F05F,0x1F060,0x1F061,0x1F062,0x1F063
,0x1F064,0x1F065,0x1F066,0x1F067,0x1F068,0x1F069,0x1F06A,0x1F06B,0x1F06C,0x1F06D,0x1F06E,0x1F06F
,0x1F070,0x1F071,0x1F072,0x1F073,0x1F074,0x1F075,0x1F076,0x1F077,0x1F078,0x1F079,0x1F07A,0x1F07B
,0x1F07C,0x1F07D,0x1F07E,0x1F07F,0x1F080,0x1F081,0x1F082,0x1F083,0x1F084,0x1F085,0x1F086,0x1F087
,0x1F088,0x1F089,0x1F08A,0x1F08B,0x1F08C,0x1F08D,0x1F08E,0x1F08F,0x1F090,0x1F091,0x1F092,0x1F093
,0x1F0A0,0x1F0A1,0x1F0A2,0x1F0A3,0x1F0A4,0x1F0A5,0x1F0A6,0x1F0A7,0x1F0A8,0x1F0A9,0x1F0AA,0x1F0AB
,0x1F0AC,0x1F0AD,0x1F0AE,0x1F0B1,0x1F0B2,0x1F0B3,0x1F0B4,0x1F0B5,0x1F0B6,0x1F0B7,0x1F0B8,0x1F0B9
,0x1F0BA,0x1F0BB,0x1F0BC,0x1F0BD,0x1F0BE,0x1F0BF,0x1F0C1,0x1F0C2,0x1F0C3,0x1F0C4,0x1F0C5,0x1F0C6
,0x1F0C7,0x1F0C8,0x1F0C9,0x1F0CA,0x1F0CB,0x1F0CC,0x1F0CD,0x1F0CE,0x1F0CF,0x1F0D1,0x1F0D2,0x1F0D3
,0x1F0D4,0x1F0D5,0x1F0D6,0x1F0D7,0x1F0D8,0x1F0D9,0x1F0DA,0x1F0DB,0x1F0DC,0x1F0DD,0x1F0DE,0x1F0DF
,0x1F0E0,0x1F0E1,0x1F0E2,0x1F0E3,0x1F0E4,0x1F0E5,0x1F0E6,0x1F0E7,0x1F0E8,0x1F0E9,0x1F0EA,0x1F0EB
,0x1F0EC,0x1F0ED,0x1F0EE,0x1F0EF,0x1F0F0,0x1F0F1,0x1F0F2,0x1F0F3,0x1F0F4,0x1F0F5,0x1F100,0x1F101
,0x1F102,0x1F103,0x1F104,0x1F105,0x1F106,0x1F107,0x1F108,0x1F109,0x1F10A,0x1F10B,0x1F10C,0x1F110
,0x1F111,0x1F112,0x1F113,0x1F114,0x1F115,0x1F116,0x1F117,0x1F118,0x1F119,0x1F11A,0x1F11B,0x1F11C
,0x1F11D,0x1F11E,0x1F11F,0x1F120,0x1F121,0x1F122,0x1F123,0x1F124,0x1F125,0x1F126,0x1F127,0x1F128
,0x1F129,0x1F12A,0x1F12B,0x1F12C,0x1F12D,0x1F12E,0x1F130,0x1F131,0x1F132,0x1F133,0x1F134,0x1F135
,0x1F136,0x1F137,0x1F138,0x1F139,0x1F13A,0x1F13B,0x1F13C,0x1F13D,0x1F13E,0x1F13F,0x1F140,0x1F141
,0x1F142,0x1F143,0x1F144,0x1F145,0x1F146,0x1F147,0x1F148,0x1F149,0x1F14A,0x1F14B,0x1F14C,0x1F14D
,0x1F14E,0x1F14F,0x1F150,0x1F151,0x1F152,0x1F153,0x1F154,0x1F155,0x1F156,0x1F157,0x1F158,0x1F159
,0x1F15A,0x1F15B,0x1F15C,0x1F15D,0x1F15E,0x1F15F,0x1F160,0x1F161,0x1F162,0x1F163,0x1F164,0x1F165
,0x1F166,0x1F167,0x1F168,0x1F169,0x1F16A,0x1F16B,0x1F170,0x1F171,0x1F172,0x1F173,0x1F174,0x1F175
,0x1F176,0x1F177,0x1F178,0x1F179,0x1F17A,0x1F17B,0x1F17C,0x1F17D,0x1F17E,0x1F17F,0x1F180,0x1F181
,0x1F182,0x1F183,0x1F184,0x1F185,0x1F186,0x1F187,0x1F188,0x1F189,0x1F18A,0x1F18B,0x1F18C,0x1F18D
,0x1F18E,0x1F18F,0x1F190,0x1F191,0x1F192,0x1F193,0x1F194,0x1F195,0x1F196,0x1F197,0x1F198,0x1F199
,0x1F19A,0x1F19B,0x1F19C,0x1F19D,0x1F19E,0x1F19F,0x1F1A0,0x1F1A1,0x1F1A2,0x1F1A3,0x1F1A4,0x1F1A5
,0x1F1A6,0x1F1A7,0x1F1A8,0x1F1A9,0x1F1AA,0x1F1AB,0x1F1AC,0x1F1E6,0x1F1E7,0x1F1E8,0x1F1E9,0x1F1EA
,0x1F1EB,0x1F1EC,0x1F1ED,0x1F1EE,0x1F1EF,0x1F1F0,0x1F1F1,0x1F1F2,0x1F1F3,0x1F1F4,0x1F1F5,0x1F1F6
,0x1F1F7,0x1F1F8,0x1F1F9,0x1F1FA,0x1F1FB,0x1F1FC,0x1F1FD,0x1F1FE,0x1F1FF,0x1F200,0x1F201,0x1F202
,0x1F210,0x1F211,0x1F212,0x1F213,0x1F214,0x1F215,0x1F216,0x1F217,0x1F218,0x1F219,0x1F21A,0x1F21B
,0x1F21C,0x1F21D,0x1F21E,0x1F21F,0x1F220,0x1F221,0x1F222,0x1F223,0x1F224,0x1F225,0x1F226,0x1F227
,0x1F228,0x1F229,0x1F22A,0x1F22B,0x1F22C,0x1F22D,0x1F22E,0x1F22F,0x1F230,0x1F231,0x1F232,0x1F233
,0x1F234,0x1F235,0x1F236,0x1F237,0x1F238,0x1F239,0x1F23A,0x1F23B,0x1F240,0x1F241,0x1F242,0x1F243
,0x1F244,0x1F245,0x1F246,0x1F247,0x1F248,0x1F250,0x1F251,0x1F260,0x1F261,0x1F262,0x1F263,0x1F264
,0x1F265,0x1F300,0x1F301,0x1F302,0x1F303,0x1F304,0x1F305,0x1F306,0x1F307,0x1F308,0x1F309,0x1F30A
,0x1F30B,0x1F30C,0x1F30D,0x1F30E,0x1F30F,0x1F310,0x1F311,0x1F312,0x1F313,0x1F314,0x1F315,0x1F316
,0x1F317,0x1F318,0x1F319,0x1F31A,0x1F31B,0x1F31C,0x1F31D,0x1F31E,0x1F31F,0x1F320,0x1F321,0x1F322
,0x1F323,0x1F324,0x1F325,0x1F326,0x1F327,0x1F328,0x1F329,0x1F32A,0x1F32B,0x1F32C,0x1F32D,0x1F32E
,0x1F32F,0x1F330,0x1F331,0x1F332,0x1F333,0x1F334,0x1F335,0x1F336,0x1F337,0x1F338,0x1F339,0x1F33A
,0x1F33B,0x1F33C,0x1F33D,0x1F33E,0x1F33F,0x1F340,0x1F341,0x1F342,0x1F343,0x1F344,0x1F345,0x1F346
,0x1F347,0x1F348,0x1F349,0x1F34A,0x1F34B,0x1F34C,0x1F34D,0x1F34E,0x1F34F,0x1F350,0x1F351,0x1F352
,0x1F353,0x1F354,0x1F355,0x1F356,0x1F357,0x1F358,0x1F359,0x1F35A,0x1F35B,0x1F35C,0x1F35D,0x1F35E
,0x1F35F,0x1F360,0x1F361,0x1F362,0x1F363,0x1F364,0x1F365,0x1F366,0x1F367,0x1F368,0x1F369,0x1F36A
,0x1F36B,0x1F36C,0x1F36D,0x1F36E,0x1F36F,0x1F370,0x1F371,0x1F372,0x1F373,0x1F374,0x1F375,0x1F376
,0x1F377,0x1F378,0x1F379,0x1F37A,0x1F37B,0x1F37C,0x1F37D,0x1F37E,0x1F37F,0x1F380,0x1F381,0x1F382
,0x1F383,0x1F384,0x1F385,0x1F386,0x1F387,0x1F388,0x1F389,0x1F38A,0x1F38B,0x1F38C,0x1F38D,0x1F38E
,0x1F38F,0x1F390,0x1F391,0x1F392,0x1F393,0x1F394,0x1F395,0x1F396,0x1F397,0x1F398,0x1F399,0x1F39A
,0x1F39B,0x1F39C,0x1F39D,0x1F39E,0x1F39F,0x1F3A0,0x1F3A1,0x1F3A2,0x1F3A3,0x1F3A4,0x1F3A5,0x1F3A6
,0x1F3A7,0x1F3A8,0x1F3A9,0x1F3AA,0x1F3AB,0x1F3AC,0x1F3AD,0x1F3AE,0x1F3AF,0x1F3B0,0x1F3B1,0x1F3B2
,0x1F3B3,0x1F3B4,0x1F3B5,0x1F3B6,0x1F3B7,0x1F3B8,0x1F3B9,0x1F3BA,0x1F3BB,0x1F3BC,0x1F3BD,0x1F3BE
,0x1F3BF,0x1F3C0,0x1F3C1,0x1F3C2,0x1F3C3,0x1F3C4,0x1F3C5,0x1F3C6,0x1F3C7,0x1F3C8,0x1F3C9,0x1F3CA
,0x1F3CB,0x1F3CC,0x1F3CD,0x1F3CE,0x1F3CF,0x1F3D0,0x1F3D1,0x1F3D2,0x1F3D3,0x1F3D4,0x1F3D5,0x1F3D6
,0x1F3D7,0x1F3D8,0x1F3D9,0x1F3DA,0x1F3DB,0x1F3DC,0x1F3DD,0x1F3DE,0x1F3DF,0x1F3E0,0x1F3E1,0x1F3E2
,0x1F3E3,0x1F3E4,0x1F3E5,0x1F3E6,0x1F3E7,0x1F3E8,0x1F3E9,0x1F3EA,0x1F3EB,0x1F3EC,0x1F3ED,0x1F3EE
,0x1F3EF,0x1F3F0,0x1F3F1,0x1F3F2,0x1F3F3,0x1F3F4,0x1F3F5,0x1F3F6,0x1F3F7,0x1F3F8,0x1F3F9,0x1F3FA
,0x1F3FB,0x1F3FC,0x1F3FD,0x1F3FE,0x1F3FF,0x1F400,0x1F401,0x1F402,0x1F403,0x1F404,0x1F405,0x1F406
,0x1F407,0x1F408,0x1F409,0x1F40A,0x1F40B,0x1F40C,0x1F40D,0x1F40E,0x1F40F,0x1F410,0x1F411,0x1F412
,0x1F413,0x1F414,0x1F415,0x1F416,0x1F417,0x1F418,0x1F419,0x1F41A,0x1F41B,0x1F41C,0x1F41D,0x1F41E
,0x1F41F,0x1F420,0x1F421,0x1F422,0x1F423,0x1F424,0x1F425,0x1F426,0x1F427,0x1F428,0x1F429,0x1F42A
,0x1F42B,0x1F42C,0x1F42D,0x1F42E,0x1F42F,0x1F430,0x1F431,0x1F432,0x1F433,0x1F434,0x1F435,0x1F436
,0x1F437,0x1F438,0x1F439,0x1F43A,0x1F43B,0x1F43C,0x1F43D,0x1F43E,0x1F43F,0x1F440,0x1F441,0x1F442
,0x1F443,0x1F444,0x1F445,0x1F446,0x1F447,0x1F448,0x1F449,0x1F44A,0x1F44B,0x1F44C,0x1F44D,0x1F44E
,0x1F44F,0x1F450,0x1F451,0x1F452,0x1F453,0x1F454,0x1F455,0x1F456,0x1F457,0x1F458,0x1F459,0x1F45A
,0x1F45B,0x1F45C,0x1F45D,0x1F45E,0x1F45F,0x1F460,0x1F461,0x1F462,0x1F463,0x1F464,0x1F465,0x1F466
,0x1F467,0x1F468,0x1F469,0x1F46A,0x1F46B,0x1F46C,0x1F46D,0x1F46E,0x1F46F,0x1F470,0x1F471,0x1F472
,0x1F473,0x1F474,0x1F475,0x1F476,0x1F477,0x1F478,0x1F479,0x1F47A,0x1F47B,0x1F47C,0x1F47D,0x1F47E
,0x1F47F,0x1F480,0x1F481,0x1F482,0x1F483,0x1F484,0x1F485,0x1F486,0x1F487,0x1F488,0x1F489,0x1F48A
,0x1F48B,0x1F48C,0x1F48D,0x1F48E,0x1F48F,0x1F490,0x1F491,0x1F492,0x1F493,0x1F494,0x1F495,0x1F496
,0x1F497,0x1F498,0x1F499,0x1F49A,0x1F49B,0x1F49C,0x1F49D,0x1F49E,0x1F49F,0x1F4A0,0x1F4A1,0x1F4A2
,0x1F4A3,0x1F4A4,0x1F4A5,0x1F4A6,0x1F4A7,0x1F4A8,0x1F4A9,0x1F4AA,0x1F4AB,0x1F4AC,0x1F4AD,0x1F4AE
,0x1F4AF,0x1F4B0,0x1F4B1,0x1F4B2,0x1F4B3,0x1F4B4,0x1F4B5,0x1F4B6,0x1F4B7,0x1F4B8,0x1F4B9,0x1F4BA
,0x1F4BB,0x1F4BC,0x1F4BD,0x1F4BE,0x1F4BF,0x1F4C0,0x1F4C1,0x1F4C2,0x1F4C3,0x1F4C4,0x1F4C5,0x1F4C6
,0x1F4C7,0x1F4C8,0x1F4C9,0x1F4CA,0x1F4CB,0x1F4CC,0x1F4CD,0x1F4CE,0x1F4CF,0x1F4D0,0x1F4D1,0x1F4D2
,0x1F4D3,0x1F4D4,0x1F4D5,0x1F4D6,0x1F4D7,0x1F4D8,0x1F4D9,0x1F4DA,0x1F4DB,0x1F4DC,0x1F4DD,0x1F4DE
,0x1F4DF,0x1F4E0,0x1F4E1,0x1F4E2,0x1F4E3,0x1F4E4,0x1F4E5,0x1F4E6,0x1F4E7,0x1F4E8,0x1F4E9,0x1F4EA
,0x1F4EB,0x1F4EC,0x1F4ED,0x1F4EE,0x1F4EF,0x1F4F0,0x1F4F1,0x1F4F2,0x1F4F3,0x1F4F4,0x1F4F5,0x1F4F6
,0x1F4F7,0x1F4F8,0x1F4F9,0x1F4FA,0x1F4FB,0x1F4FC,0x1F4FD,0x1F4FE,0x1F4FF,0x1F500,0x1F501,0x1F502
,0x1F503,0x1F504,0x1F505,0x1F506,0x1F507,0x1F508,0x1F509,0x1F50A,0x1F50B,0x1F50C,0x1F50D,0x1F50E
,0x1F50F,0x1F510,0x1F511,0x1F512,0x1F513,0x1F514,0x1F515,0x1F516,0x1F517,0x1F518,0x1F519,0x1F51A
,0x1F51B,0x1F51C,0x1F51D,0x1F51E,0x1F51F,0x1F520,0x1F521,0x1F522,0x1F523,0x1F524,0x1F525,0x1F526
,0x1F527,0x1F528,0x1F529,0x1F52A,0x1F52B,0x1F52C,0x1F52D,0x1F52E,0x1F52F,0x1F530,0x1F531,0x1F532
,0x1F533,0x1F534,0x1F535,0x1F536,0x1F537,0x1F538,0x1F539,0x1F53A,0x1F53B,0x1F53C,0x1F53D,0x1F53E
,0x1F53F,0x1F540,0x1F541,0x1F542,0x1F543,0x1F544,0x1F545,0x1F546,0x1F547,0x1F548,0x1F549,0x1F54A
,0x1F54B,0x1F54C,0x1F54D,0x1F54E,0x1F54F,0x1F550,0x1F551,0x1F552,0x1F553,0x1F554,0x1F555,0x1F556
,0x1F557,0x1F558,0x1F559,0x1F55A,0x1F55B,0x1F55C,0x1F55D,0x1F55E,0x1F55F,0x1F560,0x1F561,0x1F562
,0x1F563,0x1F564,0x1F565,0x1F566,0x1F567,0x1F568,0x1F569,0x1F56A,0x1F56B,0x1F56C,0x1F56D,0x1F56E
,0x1F56F,0x1F570,0x1F571,0x1F572,0x1F573,0x1F574,0x1F575,0x1F576,0x1F577,0x1F578,0x1F579,0x1F57A
,0x1F57B,0x1F57C,0x1F57D,0x1F57E,0x1F57F,0x1F580,0x1F581,0x1F582,0x1F583,0x1F584,0x1F585,0x1F586
,0x1F587,0x1F588,0x1F589,0x1F58A,0x1F58B,0x1F58C,0x1F58D,0x1F58E,0x1F58F,0x1F590,0x1F591,0x1F592
,0x1F593,0x1F594,0x1F595,0x1F596,0x1F597,0x1F598,0x1F599,0x1F59A,0x1F59B,0x1F59C,0x1F59D,0x1F59E
,0x1F59F,0x1F5A0,0x1F5A1,0x1F5A2,0x1F5A3,0x1F5A4,0x1F5A5,0x1F5A6,0x1F5A7,0x1F5A8,0x1F5A9,0x1F5AA
,0x1F5AB,0x1F5AC,0x1F5AD,0x1F5AE,0x1F5AF,0x1F5B0,0x1F5B1,0x1F5B2,0x1F5B3,0x1F5B4,0x1F5B5,0x1F5B6
,0x1F5B7,0x1F5B8,0x1F5B9,0x1F5BA,0x1F5BB,0x1F5BC,0x1F5BD,0x1F5BE,0x1F5BF,0x1F5C0,0x1F5C1,0x1F5C2
,0x1F5C3,0x1F5C4,0x1F5C5,0x1F5C6,0x1F5C7,0x1F5C8,0x1F5C9,0x1F5CA,0x1F5CB,0x1F5CC,0x1F5CD,0x1F5CE
,0x1F5CF,0x1F5D0,0x1F5D1,0x1F5D2,0x1F5D3,0x1F5D4,0x1F5D5,0x1F5D6,0x1F5D7,0x1F5D8,0x1F5D9,0x1F5DA
,0x1F5DB,0x1F5DC,0x1F5DD,0x1F5DE,0x1F5DF,0x1F5E0,0x1F5E1,0x1F5E2,0x1F5E3,0x1F5E4,0x1F5E5,0x1F5E6
,0x1F5E7,0x1F5E8,0x1F5E9,0x1F5EA,0x1F5EB,0x1F5EC,0x1F5ED,0x1F5EE,0x1F5EF,0x1F5F0,0x1F5F1,0x1F5F2
,0x1F5F3,0x1F5F4,0x1F5F5,0x1F5F6,0x1F5F7,0x1F5F8,0x1F5F9,0x1F5FA,0x1F5FB,0x1F5FC,0x1F5FD,0x1F5FE
,0x1F5FF,0x1F600,0x1F601,0x1F602,0x1F603,0x1F604,0x1F605,0x1F606,0x1F607,0x1F608,0x1F609,0x1F60A
,0x1F60B,0x1F60C,0x1F60D,0x1F60E,0x1F60F,0x1F610,0x1F611,0x1F612,0x1F613,0x1F614,0x1F615,0x1F616
,0x1F617,0x1F618,0x1F619,0x1F61A,0x1F61B,0x1F61C,0x1F61D,0x1F61E,0x1F61F,0x1F620,0x1F621,0x1F622
,0x1F623,0x1F624,0x1F625,0x1F626,0x1F627,0x1F628,0x1F629,0x1F62A,0x1F62B,0x1F62C,0x1F62D,0x1F62E
,0x1F62F,0x1F630,0x1F631,0x1F632,0x1F633,0x1F634,0x1F635,0x1F636,0x1F637,0x1F638,0x1F639,0x1F63A
,0x1F63B,0x1F63C,0x1F63D,0x1F63E,0x1F63F,0x1F640,0x1F641,0x1F642,0x1F643,0x1F644,0x1F645,0x1F646
,0x1F647,0x1F648,0x1F649,0x1F64A,0x1F64B,0x1F64C,0x1F64D,0x1F64E,0x1F64F,0x1F650,0x1F651,0x1F652
,0x1F653,0x1F654,0x1F655,0x1F656,0x1F657,0x1F658,0x1F659,0x1F65A,0x1F65B,0x1F65C,0x1F65D,0x1F65E
,0x1F65F,0x1F660,0x1F661,0x1F662,0x1F663,0x1F664,0x1F665,0x1F666,0x1F667,0x1F668,0x1F669,0x1F66A
,0x1F66B,0x1F66C,0x1F66D,0x1F66E,0x1F66F,0x1F670,0x1F671,0x1F672,0x1F673,0x1F674,0x1F675,0x1F676
,0x1F677,0x1F678,0x1F679,0x1F67A,0x1F67B,0x1F67C,0x1F67D,0x1F67E,0x1F67F,0x1F680,0x1F681,0x1F682
,0x1F683,0x1F684,0x1F685,0x1F686,0x1F687,0x1F688,0x1F689,0x1F68A,0x1F68B,0x1F68C,0x1F68D,0x1F68E
,0x1F68F,0x1F690,0x1F691,0x1F692,0x1F693,0x1F694,0x1F695,0x1F696,0x1F697,0x1F698,0x1F699,0x1F69A
,0x1F69B,0x1F69C,0x1F69D,0x1F69E,0x1F69F,0x1F6A0,0x1F6A1,0x1F6A2,0x1F6A3,0x1F6A4,0x1F6A5,0x1F6A6
,0x1F6A7,0x1F6A8,0x1F6A9,0x1F6AA,0x1F6AB,0x1F6AC,0x1F6AD,0x1F6AE,0x1F6AF,0x1F6B0,0x1F6B1,0x1F6B2
,0x1F6B3,0x1F6B4,0x1F6B5,0x1F6B6,0x1F6B7,0x1F6B8,0x1F6B9,0x1F6BA,0x1F6BB,0x1F6BC,0x1F6BD,0x1F6BE
,0x1F6BF,0x1F6C0,0x1F6C1,0x1F6C2,0x1F6C3,0x1F6C4,0x1F6C5,0x1F6C6,0x1F6C7,0x1F6C8,0x1F6C9,0x1F6CA
,0x1F6CB,0x1F6CC,0x1F6CD,0x1F6CE,0x1F6CF,0x1F6D0,0x1F6D1,0x1F6D2,0x1F6D3,0x1F6D4,0x1F6E0,0x1F6E1
,0x1F6E2,0x1F6E3,0x1F6E4,0x1F6E5,0x1F6E6,0x1F6E7,0x1F6E8,0x1F6E9,0x1F6EA,0x1F6EB,0x1F6EC,0x1F6F0
,0x1F6F1,0x1F6F2,0x1F6F3,0x1F6F4,0x1F6F5,0x1F6F6,0x1F6F7,0x1F6F8,0x1F700,0x1F701,0x1F702,0x1F703
,0x1F704,0x1F705,0x1F706,0x1F707,0x1F708,0x1F709,0x1F70A,0x1F70B,0x1F70C,0x1F70D,0x1F70E,0x1F70F
,0x1F710,0x1F711,0x1F712,0x1F713,0x1F714,0x1F715,0x1F716,0x1F717,0x1F718,0x1F719,0x1F71A,0x1F71B
,0x1F71C,0x1F71D,0x1F71E,0x1F71F,0x1F720,0x1F721,0x1F722,0x1F723,0x1F724,0x1F725,0x1F726,0x1F727
,0x1F728,0x1F729,0x1F72A,0x1F72B,0x1F72C,0x1F72D,0x1F72E,0x1F72F,0x1F730,0x1F731,0x1F732,0x1F733
,0x1F734,0x1F735,0x1F736,0x1F737,0x1F738,0x1F739,0x1F73A,0x1F73B,0x1F73C,0x1F73D,0x1F73E,0x1F73F
,0x1F740,0x1F741,0x1F742,0x1F743,0x1F744,0x1F745,0x1F746,0x1F747,0x1F748,0x1F749,0x1F74A,0x1F74B
,0x1F74C,0x1F74D,0x1F74E,0x1F74F,0x1F750,0x1F751,0x1F752,0x1F753,0x1F754,0x1F755,0x1F756,0x1F757
,0x1F758,0x1F759,0x1F75A,0x1F75B,0x1F75C,0x1F75D,0x1F75E,0x1F75F,0x1F760,0x1F761,0x1F762,0x1F763
,0x1F764,0x1F765,0x1F766,0x1F767,0x1F768,0x1F769,0x1F76A,0x1F76B,0x1F76C,0x1F76D,0x1F76E,0x1F76F
,0x1F770,0x1F771,0x1F772,0x1F773,0x1F780,0x1F781,0x1F782,0x1F783,0x1F784,0x1F785,0x1F786,0x1F787
,0x1F788,0x1F789,0x1F78A,0x1F78B,0x1F78C,0x1F78D,0x1F78E,0x1F78F,0x1F790,0x1F791,0x1F792,0x1F793
,0x1F794,0x1F795,0x1F796,0x1F797,0x1F798,0x1F799,0x1F79A,0x1F79B,0x1F79C,0x1F79D,0x1F79E,0x1F79F
,0x1F7A0,0x1F7A1,0x1F7A2,0x1F7A3,0x1F7A4,0x1F7A5,0x1F7A6,0x1F7A7,0x1F7A8,0x1F7A9,0x1F7AA,0x1F7AB
,0x1F7AC,0x1F7AD,0x1F7AE,0x1F7AF,0x1F7B0,0x1F7B1,0x1F7B2,0x1F7B3,0x1F7B4,0x1F7B5,0x1F7B6,0x1F7B7
,0x1F7B8,0x1F7B9,0x1F7BA,0x1F7BB,0x1F7BC,0x1F7BD,0x1F7BE,0x1F7BF,0x1F7C0,0x1F7C1,0x1F7C2,0x1F7C3
,0x1F7C4,0x1F7C5,0x1F7C6,0x1F7C7,0x1F7C8,0x1F7C9,0x1F7CA,0x1F7CB,0x1F7CC,0x1F7CD,0x1F7CE,0x1F7CF
,0x1F7D0,0x1F7D1,0x1F7D2,0x1F7D3,0x1F7D4,0x1F800,0x1F801,0x1F802,0x1F803,0x1F804,0x1F805,0x1F806
,0x1F807,0x1F808,0x1F809,0x1F80A,0x1F80B,0x1F810,0x1F811,0x1F812,0x1F813,0x1F814,0x1F815,0x1F816
,0x1F817,0x1F818,0x1F819,0x1F81A,0x1F81B,0x1F81C,0x1F81D,0x1F81E,0x1F81F,0x1F820,0x1F821,0x1F822
,0x1F823,0x1F824,0x1F825,0x1F826,0x1F827,0x1F828,0x1F829,0x1F82A,0x1F82B,0x1F82C,0x1F82D,0x1F82E
,0x1F82F,0x1F830,0x1F831,0x1F832,0x1F833,0x1F834,0x1F835,0x1F836,0x1F837,0x1F838,0x1F839,0x1F83A
,0x1F83B,0x1F83C,0x1F83D,0x1F83E,0x1F83F,0x1F840,0x1F841,0x1F842,0x1F843,0x1F844,0x1F845,0x1F846
,0x1F847,0x1F850,0x1F851,0x1F852,0x1F853,0x1F854,0x1F855,0x1F856,0x1F857,0x1F858,0x1F859,0x1F860
,0x1F861,0x1F862,0x1F863,0x1F864,0x1F865,0x1F866,0x1F867,0x1F868,0x1F869,0x1F86A,0x1F86B,0x1F86C
,0x1F86D,0x1F86E,0x1F86F,0x1F870,0x1F871,0x1F872,0x1F873,0x1F874,0x1F875,0x1F876,0x1F877,0x1F878
,0x1F879,0x1F87A,0x1F87B,0x1F87C,0x1F87D,0x1F87E,0x1F87F,0x1F880,0x1F881,0x1F882,0x1F883,0x1F884
,0x1F885,0x1F886,0x1F887,0x1F890,0x1F891,0x1F892,0x1F893,0x1F894,0x1F895,0x1F896,0x1F897,0x1F898
,0x1F899,0x1F89A,0x1F89B,0x1F89C,0x1F89D,0x1F89E,0x1F89F,0x1F8A0,0x1F8A1,0x1F8A2,0x1F8A3,0x1F8A4
,0x1F8A5,0x1F8A6,0x1F8A7,0x1F8A8,0x1F8A9,0x1F8AA,0x1F8AB,0x1F8AC,0x1F8AD,0x1F900,0x1F901,0x1F902
,0x1F903,0x1F904,0x1F905,0x1F906,0x1F907,0x1F908,0x1F909,0x1F90A,0x1F90B,0x1F910,0x1F911,0x1F912
,0x1F913,0x1F914,0x1F915,0x1F916,0x1F917,0x1F918,0x1F919,0x1F91A,0x1F91B,0x1F91C,0x1F91D,0x1F91E
,0x1F91F,0x1F920,0x1F921,0x1F922,0x1F923,0x1F924,0x1F925,0x1F926,0x1F927,0x1F928,0x1F929,0x1F92A
,0x1F92B,0x1F92C,0x1F92D,0x1F92E,0x1F92F,0x1F930,0x1F931,0x1F932,0x1F933,0x1F934,0x1F935,0x1F936
,0x1F937,0x1F938,0x1F939,0x1F93A,0x1F93B,0x1F93C,0x1F93D,0x1F93E,0x1F940,0x1F941,0x1F942,0x1F943
,0x1F944,0x1F945,0x1F946,0x1F947,0x1F948,0x1F949,0x1F94A,0x1F94B,0x1F94C,0x1F950,0x1F951,0x1F952
,0x1F953,0x1F954,0x1F955,0x1F956,0x1F957,0x1F958,0x1F959,0x1F95A,0x1F95B,0x1F95C,0x1F95D,0x1F95E
,0x1F95F,0x1F960,0x1F961,0x1F962,0x1F963,0x1F964,0x1F965,0x1F966,0x1F967,0x1F968,0x1F969,0x1F96A
,0x1F96B,0x1F980,0x1F981,0x1F982,0x1F983,0x1F984,0x1F985,0x1F986,0x1F987,0x1F988,0x1F989,0x1F98A
,0x1F98B,0x1F98C,0x1F98D,0x1F98E,0x1F98F,0x1F990,0x1F991,0x1F992,0x1F993,0x1F994,0x1F995,0x1F996
,0x1F997,0x1F9C0,0x1F9D0,0x1F9D1,0x1F9D2,0x1F9D3,0x1F9D4,0x1F9D5,0x1F9D6,0x1F9D7,0x1F9D8,0x1F9D9
,0x1F9DA,0x1F9DB,0x1F9DC,0x1F9DD,0x1F9DE,0x1F9DF,0x1F9E0,0x1F9E1,0x1F9E2,0x1F9E3,0x1F9E4,0x1F9E5
,0x1F9E6,0xE0001,0xE0020,0xE0021,0xE0022,0xE0023,0xE0024,0xE0025,0xE0026,0xE0027,0xE0028,0xE0029
,0xE002A,0xE002B,0xE002C,0xE002D,0xE002E,0xE002F,0xE0030,0xE0031,0xE0032,0xE0033,0xE0034,0xE0035
,0xE0036,0xE0037,0xE0038,0xE0039,0xE003A,0xE003B,0xE003C,0xE003D,0xE003E,0xE003F,0xE0040,0xE0041
,0xE0042,0xE0043,0xE0044,0xE0045,0xE0046,0xE0047,0xE0048,0xE0049,0xE004A,0xE004B,0xE004C,0xE004D
,0xE004E,0xE004F,0xE0050,0xE0051,0xE0052,0xE0053,0xE0054,0xE0055,0xE0056,0xE0057,0xE0058,0xE0059
,0xE005A,0xE005B,0xE005C,0xE005D,0xE005E,0xE005F,0xE0060,0xE0061,0xE0062,0xE0063,0xE0064,0xE0065
,0xE0066,0xE0067,0xE0068,0xE0069,0xE006A,0xE006B,0xE006C,0xE006D,0xE006E,0xE006F,0xE0070,0xE0071
,0xE0072,0xE0073,0xE0074,0xE0075,0xE0076,0xE0077,0xE0078,0xE0079,0xE007A,0xE007B,0xE007C,0xE007D
};
*/
//#define DEBUG_PARSING
/*
Code Point	Name	Abbreviation	Usage
U+200C	ZERO WIDTH NON-JOINER	<ZWNJ>	IdentifierPart
U+200D	ZERO WIDTH JOINER	<ZWJ>	IdentifierPart
U+FEFF	ZERO WIDTH NO-BREAK SPACE	<ZWNBSP>	WhiteSpace
*/
/*
ID_Start       XID_Start        Uppercase letters, lowercase letters, titlecase letters, modifier letters
                                , other letters, letter numbers, stability extensions
ID_Continue    XID_Continue     All of the above, plus nonspacing marks, spacing combining marks, decimal numbers
                                , connector punctuations, stability extensions.
                                These are also known simply as Identifier Characters, since they are a superset of
                                the ID_Start. The set of ID_Start characters minus the ID_Continue characters are
                                known as ID_Only_Continue characters.
*/
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace jsox {
#endif
PLIST knownArrayTypeNames;
static void registerKnownArrayTypeNames(void) {
	AddLink( &knownArrayTypeNames, "ab" );
	AddLink( &knownArrayTypeNames, "u8" );
	AddLink( &knownArrayTypeNames, "cu8" );
	AddLink( &knownArrayTypeNames, "s8" );
	AddLink( &knownArrayTypeNames, "u16" );
	AddLink( &knownArrayTypeNames, "s16" );
	AddLink( &knownArrayTypeNames, "u32" );
	AddLink( &knownArrayTypeNames, "s32" );
	AddLink( &knownArrayTypeNames, "u64" );
	AddLink( &knownArrayTypeNames, "s64" );
	AddLink( &knownArrayTypeNames, "f32" );
	AddLink( &knownArrayTypeNames, "f64" );
	AddLink( &knownArrayTypeNames, "ref" );
}
static void jsox_state_init( struct jsox_parse_state *state )
{
	PPDATALIST ppElements;
	PPLIST ppList;
	PPLINKQUEUE ppQueue;
	PPLINKSTACK ppStack;
	ppElements = GetFromSet( PDATALIST, &jxpsd.dataLists );
	if( !ppElements[0] ) ppElements[0] = CreateDataList( sizeof( state->val ) );
	state->elements = ppElements;
	state->elements[0]->Cnt = 0;
	ppStack = GetFromSet( PLINKSTACK, &jxpsd.linkStacks );
	if( !ppStack[0] ) ppStack[0] = CreateLinkStack();
	state->outBuffers = ppStack;
	state->outBuffers[0]->Top = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jxpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->inBuffers = ppQueue;
	state->inBuffers[0]->Top = state->inBuffers[0]->Bottom = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jxpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->outQueue = ppQueue;
	state->outQueue[0]->Top = state->outQueue[0]->Bottom = 0;
	ppList = GetFromSet( PLIST, &jxpsd.listSet );
	if( ppList[0] ) ppList[0]->Cnt = 0;
	state->outValBuffers = ppList;
	state->line = 1;
	state->col = 1;
 // character index;
	state->n = 0;
	state->word = JSOX_WORD_POS_RESET;
	state->status = TRUE;
	state->negative = FALSE;
	state->current_class = NULL;
	state->current_class_item = 0;
	state->arrayType = -1;
// NULL;
	state->context_stack = GetFromSet( PLINKSTACK, &jxpsd.linkStacks );
	if( state->context_stack[0] ) state->context_stack[0]->Top = 0;
	//state->first_token = TRUE;
	state->context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
	state->parse_context = JSOX_CONTEXT_UNKNOWN;
	state->comment = 0;
	state->completed = FALSE;
	//state->mOut = msg;// = NewArray( char, msglen );
	//state->msg_input = (char const *)msg;
	state->val.value_type = JSOX_VALUE_UNSET;
	state->val.contains = NULL;
	state->val._contains = NULL;
	state->val.name = NULL;
	state->val.string = NULL;
	state->complete_at_end = FALSE;
	state->gatheringString = FALSE;
	state->gatheringNumber = FALSE;
	state->pvtError = NULL;
}
/* I guess this is a good parser */
struct jsox_parse_state * jsox_begin_parse( void )
{
//New( struct json_parse_state );
	struct jsox_parse_state *state = GetFromSet( JSOX_PARSE_STATE, &jxpsd.parseStates );
	jsox_state_init( state );
	return state;
}
char *jsox_escape_string_length( const char *string, size_t len, size_t *outlen ) {
	size_t m = 0;
	size_t ch;
	const char *input;
	TEXTSTR output;
	TEXTSTR _output;
	if( !( input = string ) ) return NULL;
	for( ch = 0; ch < len; ch++, input++ ) {
 /*|| (input[0] == '\n') || (input[0] == '\t')*/
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`') || (input[0] == '\'') )
			m++;
	}
	_output = output = NewArray( TEXTCHAR, len+m+1 );
	for( (ch = 0), (input = string); ch < len; ch++, input++ ) {
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`' )|| (input[0] == '\'' )) {
			(*output++) = '\\';
		}
		(*output++) = input[0];
	}
	(*output) = 0;
	if( outlen ) (*outlen) = output - _output;
	return _output;
}
char *jsox_escape_string( const char *string ) {
	return jsox_escape_string_length( string, strlen( string ), NULL );
}
#undef __GetUtfChar
#undef _zero
#define BADUTF8 0xFFFFFFF
#define _2char(result,from) (((*from) += 2),( ( result & 0x1F ) << 6 ) | ( ( result & 0x3f00 )>>8))
#define _zero(result,from)  ((*from)++,BADUTF8)
#define _gzero(result,from)  ((*from)++,0)
#define _3char(result,from) ( ((*from) += 3),( ( ( result & 0xF ) << 12 ) | ( ( result & 0x3F00 ) >> 2 ) | ( ( result & 0x3f0000 ) >> 16 )) )
#define _4char(result,from)  ( ((*from) += 4), ( ( ( result & 0x7 ) << 18 )                             | ( ( result & 0x3F00 ) << 4 )                           | ( ( result & 0x3f0000 ) >> 10 )                            | ( ( result & 0x3f000000 ) >> 24 ) ) )
// load 4 bytes in a little endian way; might result in a 8 byte variable, but only 4 are valid.
#define get4Chars(p) ((((TEXTRUNE*) ((uintptr_t)(p) & ~0x3) )[0]                  >> (CHAR_BIT*((uintptr_t)(p) & 0x3)))                         | (( ((uintptr_t)(p)) & 0x3 )                                          ? (((TEXTRUNE*) ((uintptr_t)(p) & ~0x3) )[1]                          << (CHAR_BIT*(4-((uintptr_t)(p) & 0x3))))                     :(TEXTRUNE)0 ))
#define __GetUtfChar( result, from )           ((result = get4Chars(*from)),             ( ( !(result & 0xFF) )              ?_gzero(result,from)         :( ( result & 0x80 )                               ?( ( result & 0xE0 ) == 0xC0 )               ?( ( ( result & 0xC000 ) == 0x8000 ) ?_2char(result,from) : _zero(result,from)  )                :( ( ( result & 0xF0 ) == 0xE0 )                                           ?( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) ) ? _3char(result,from) : _zero(result,from)  )                   :( ( ( result & 0xF8 ) == 0xF0 )                               ? ( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) && ( ( result & 0xC0000000 ) == 0x80000000 ) )                      ?_4char(result,from):_zero(result,from) )                                                                                                                                  :( ( ( result & 0xC0 ) == 0x80 )                                                                                                                      ?_zero(result,from)                                                                                                                                           : ( (*from)++, (result & 0x7F) ) ) ) )                                                                                               : ( (*from)++, (result & 0x7F) ) ) ) )
#define GetUtfChar(x) __GetUtfChar(c,x)
static int gatherStringX(struct jsox_parse_state *state, CTEXTSTR msg, CTEXTSTR *msg_input, size_t msglen, TEXTSTR *pmOut, TEXTRUNE start_c
		//, int literalString
		) {
	char *mOut = (*pmOut);
	// collect a string
	int status = 0;
	size_t n;
	size_t nextN = ( *msg_input ) - msg;
	//int escape;
	//LOGICAL cr_escaped;
	TEXTRUNE c;
	//escape = 0;
	//cr_escaped = FALSE;
	while( ( ( n = nextN ), ( n < msglen ) )
		&& ( ( ( c = GetUtfChar( msg_input ) ) != BADUTF8 )
			&& ( status >= 0 ) ) )
	{
		if( (nextN = msg_input[0] - msg ) > msglen ) {
 // restore input position.
			(msg_input[0]) = msg + n;
			return status;
		}
		(state->col)++;
		if( c == start_c ) {
			if( state->escape ) { ( *mOut++ ) = c; state->escape = FALSE; }
			else if( c == start_c ) {
				status = 1;
				break;
 // other else is not valid close quote; just store as content.
			} else ( *mOut++ ) = c;
		} else if( state->escape ) {
			if( state->stringOct ) {
/*'0'*/
/*'9'*/
				if( state->hex_char_len < 3 && c >= 48 && c <= 57 ) {
					state->hex_char *= 8;
/*.codePointAt(0)*/
					state->hex_char += c - 0x30;
					state->hex_char_len++;
					if( state->hex_char_len == 3 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringOct = FALSE;
						state->escape = FALSE;
						continue;
					}
					continue;
				} else {
					if( state->hex_char > 255 ) {
						lprintf("(escaped character, parsing octal escape val=%d) fault while parsing; )" " (near %*.*s[%c]%s)"
							, state->hex_char
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						break;
					}
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringOct = FALSE;
					state->escape = FALSE;
					continue;
				}
			} else if( state->unicodeWide ) {
				if( c == '}' ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->unicodeWide = FALSE;
					state->stringUnicode = FALSE;
					state->escape = FALSE;
					continue;
				}
				state->hex_char *= 16;
				if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
				else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
				else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
				else {
					lprintf("(escaped character, parsing hex of \\u) fault while parsing; '%c' unexpected at %" _size_f " (near %*.*s[%c]%s)", c, n
						, (int)( ( n > 3 ) ? 3 : n ), (int)( ( n > 3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n > 3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
					state->unicodeWide = FALSE;
					state->escape = FALSE;
				}
				continue;
			} else if( state->stringHex || state->stringUnicode ) {
				if( state->hex_char_len == 0 && c == '{' ) {
					state->unicodeWide = TRUE;
					continue;
				}
				if( state->hex_char_len < 2 || ( state->stringUnicode && state->hex_char_len < 4 ) ) {
					state->hex_char *= 16;
					if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
					else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
					else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
					else {
						lprintf("(escaped character, parsing hex of \\x) fault while parsing; '%c' unexpected at %" _size_f " (near %*.*s[%c]%s)", c, n
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						state->stringHex = FALSE;
						state->escape = FALSE;
						continue;
					}
				}
				state->hex_char_len++;
				if( state->stringUnicode ) {
					if( state->hex_char_len == 4 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringUnicode = FALSE;
						state->escape = FALSE;
					}
				} else if( state->hex_char_len == 2 ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringHex = FALSE;
					state->escape = FALSE;
				}
				continue;
			}
			switch( c ) {
			case '\r':
				state->cr_escaped = TRUE;
				continue;
			case '\n':
				state->line++;
				state->col = 1;
				if( state->cr_escaped ) state->cr_escaped = FALSE;
				// fall through to clear escape status <CR><LF> support.
 // LS (Line separator)
			case 2028:
 // PS (paragraph separate)
			case 2029:
				continue;
			case '/':
			case '\\':
			case '\'':
			case '"':
			case '`':
				( *mOut++ ) = c;
				break;
			case 't':
				( *mOut++ ) = '\t';
				break;
			case 'b':
				( *mOut++ ) = '\b';
				break;
			case 'n':
				( *mOut++ ) = '\n';
				break;
			case 'r':
				( *mOut++ ) = '\r';
				break;
			case 'f':
				( *mOut++ ) = '\f';
				break;
			case '0': case '1': case '2': case '3':
				state->stringOct = TRUE;
				state->hex_char = c - 48;
				state->hex_char_len = 1;
				continue;
			case 'x':
				state->stringHex = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			case 'u':
				state->stringUnicode = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			default:
				if( state->cr_escaped ) {
					state->cr_escaped = FALSE;
					state->escape = FALSE;
					mOut += ConvertToUTF8(mOut, c);
				} else {
					lprintf("(escaped character) fault while parsing; '%c' unexpected %" _size_f " (near %*.*s[%c]%s)", c, n
						, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
				}
				break;
			}
			state->escape = 0;
		} else if( c == '\\' ) {
			if( state->escape ) {
				(*mOut++) = '\\';
				state->escape = 0;
			}
			else state->escape = 1;
		}
		else
		{
			if( state->cr_escaped ) {
				state->cr_escaped = FALSE;
				if( c == '\n' ) {
					state->line++;
					state->col = 1;
					state->escape = FALSE;
					continue;
				}
			}
			mOut += ConvertToUTF8( mOut, c );
		}
	}
	if( status ) {
		state->completedString = TRUE;
  // terminate the string.
		(*mOut++) = 0;
	}
	(*pmOut) = mOut;
	return status;
}
static int recoverIdent( struct jsox_parse_state *state, struct jsox_output_buffer* output, int cInt );
static int openObject( struct jsox_parse_state *state, struct jsox_output_buffer* output, int c ) {
	enum jsox_parse_context_modes nextMode;
	PJSOX_CLASS cls = NULL;
	//let tmpobj = {};
	if( state->word > JSOX_WORD_POS_RESET && state->word < JSOX_WORD_POS_FIELD )
		recoverIdent( state, output, -1 );
	if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
 /*|| state->word == JSOX_WORD_POS_AFTER_FIELD*/
		if( state->word == JSOX_WORD_POS_FIELD ) {
			INDEX idx;
			(*output->pos++) = 0;
#ifdef DEBUG_PARSING
			lprintf( "define class: %*.*s", output->pos - state->val.string, output->pos - state->val.string, state->val.string );
#endif
			LIST_FORALL( state->classes, idx, PJSOX_CLASS, cls )
				if( strcmp( cls->name, state->val.string ) == 0 )
					break;
			if( !cls ) {
				cls = GetFromSet( JSOX_CLASS, &jxpsd.classes );
				cls->name = state->val.string;
				cls->nameLen = output->pos - state->val.string;
				cls->fields = NULL;
				AddLink( &state->classes, cls );
				nextMode = JSOX_CONTEXT_CLASS_FIELD;
			} else {
				//tmpobj = Object.assign( tmpobj, cls.protoObject );
				//Object.setPrototypeOf( tmpobj, Object.getPrototypeOf( cls.protoObject ) );
				nextMode = JSOX_CONTEXT_CLASS_VALUE;
			}
			state->word = JSOX_WORD_POS_RESET;
		}
		else {
			nextMode = JSOX_CONTEXT_OBJECT_FIELD;
			state->word = JSOX_WORD_POS_FIELD;
		}
 /*|| state->word == JSOX_WORD_POS_AFTER_FIELD*/
	} else if( state->word == JSOX_WORD_POS_FIELD || state->parse_context == JSOX_CONTEXT_IN_ARRAY || state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE ) {
		if( state->word != JSOX_WORD_POS_RESET ) {
			INDEX idx;
			(*output->pos++) = 0;
			LIST_FORALL( state->classes, idx, PJSOX_CLASS, cls )
				if( strcmp( cls->name, state->val.string ) == 0 )
					break;
			if( !cls ) lprintf( "Referenced class %s has not been defined", state->val.string );
			nextMode = JSOX_CONTEXT_CLASS_VALUE;
			state->word = JSOX_WORD_POS_RESET;
		}
		else {
			nextMode = JSOX_CONTEXT_OBJECT_FIELD;
			state->word = JSOX_WORD_POS_RESET;
		}
	} else if( (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD && state->word == JSOX_WORD_POS_RESET) ) {
		if( !state->pvtError ) state->pvtError = VarTextCreate();
		vtprintf( state->pvtError, "Fault while parsing; getting field name unexpected '%c' at %" _size_f " %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
		state->status = FALSE;
		return FALSE;
	}
	else
		nextMode = JSOX_CONTEXT_OBJECT_FIELD;
	// common code; create new object container layer...
	{
		struct jsox_parse_context *old_context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
#ifdef DEBUG_PARSING
		lprintf( "Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d", state->val.value_type );
#endif
		old_context->context = state->parse_context;
		old_context->elements = state->elements;
		old_context->name = state->val.name;
		old_context->nameLen = state->val.nameLen;
		old_context->current_class = state->current_class;
		old_context->current_class_item = state->current_class_item;
		old_context->arrayType = state->arrayType;
		state->arrayType = -1;
		state->current_class = cls;
		state->current_class_item = 0;
// CreateDataList( sizeof( state->val ) );
		state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
		if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
		else state->elements[0]->Cnt = 0;
		PushLink( state->context_stack, old_context );
		JSOX_RESET_STATE_VAL();
		state->parse_context = nextMode;
	}
	return TRUE;
}
// this is about nLeast being uninitialized.
// LIST_FORALL initilaizes typeIndex.
// knownArrayTypeNames is always NOT NULL.
#pragma warning( disable: 6001 )
static LOGICAL openArray( struct jsox_parse_state *state, struct jsox_output_buffer* output, int c ) {
	PJSOX_CLASS cls = NULL;
	if( state->word > JSOX_WORD_POS_RESET && state->word < JSOX_WORD_POS_FIELD )
		recoverIdent(state,output,c);
	if( state->word == JSOX_WORD_POS_FIELD ) {
		char *name;
// = knownArrayTypeNames.findIndex( type = > (type == = val.string) );
		INDEX typeIndex;
		(*output->pos++) = 0;
#ifdef DEBUG_PARSING
		lprintf( "define typed array:%s", state->val.string );
#endif
		if( !knownArrayTypeNames ) registerKnownArrayTypeNames();
		LIST_FORALL( knownArrayTypeNames, typeIndex, char *, name ) {
			if( strcmp( state->val.string, name ) == 0 )
				break;
		}
		if( typeIndex < 13 ) {
			state->word = JSOX_WORD_POS_FIELD;
			state->arrayType = (int)typeIndex;
#ifdef DEBUG_PARSING
			lprintf( "setup array type... %d", typeIndex );
#endif
			state->val.string = output->pos;
		}
		else {
			cls = GetFromSet( JSOX_CLASS, &jxpsd.classes );
			cls->name = state->val.string;
			cls->nameLen = output->pos - state->val.string;
			cls->fields = NULL;
			AddLink( &state->classes, cls );
#if 0
			// might be an external type
			if( !state->pvtError ) state->pvtError = VarTextCreate();
			vtprintf( state->pvtError, "Unknown type specified for array:; %s at '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f
				, state->val.string, c, state->n, state->line, state->col );
			state->status = FALSE;
			return FALSE;
#endif
		}
	} else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) {
		if( !state->pvtError ) state->pvtError = VarTextCreate();
		vtprintf( state->pvtError, "Fault while parsing; while getting field name unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
		state->status = FALSE;
		return FALSE;
	}
	{
		struct jsox_parse_context *old_context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
#ifdef DEBUG_PARSING
		lprintf( "Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d", state->val.value_type );
#endif
		old_context->context = state->parse_context;
		old_context->elements = state->elements;
		old_context->name = state->val.name;
		old_context->nameLen = state->val.nameLen;
		old_context->current_class = state->current_class;
		old_context->current_class_item = state->current_class_item;
		old_context->arrayType = state->arrayType;
		state->current_class = cls;
		state->current_class_item = 0;
		state->arrayType = -1;
// CreateDataList( sizeof( state->val ) );
		state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
		if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
		else state->elements[0]->Cnt = 0;
		PushLink( state->context_stack, old_context );
		JSOX_RESET_STATE_VAL();
		state->parse_context = JSOX_CONTEXT_IN_ARRAY;
		state->word = JSOX_WORD_POS_RESET;
	}
	return TRUE;
}
#pragma warning( default: 6001 )
int recoverIdent( struct jsox_parse_state *state, struct jsox_output_buffer* output, int cInt ) {
	if( state->word != JSOX_WORD_POS_RESET ) {
		if( !state->val.string ) {
#ifdef DEBUG_PARSINGs
			lprintf( "Updating string postion?" );
#endif
			state->val.string = output->pos;
		}
		if( state->word == JSOX_WORD_POS_END ) {
			switch( state->val.value_type ) {
			default:
				lprintf( "FAULT: UNEXPECTED VALUE TYPE RECOVERINT IDENT:%d", state->val.value_type );
				break;
			case JSOX_VALUE_TRUE:
				(*output->pos++) = 't';
				(*output->pos++) = 'r';
				(*output->pos++) = 'u';
				(*output->pos++) = 'e';
				break;
			case JSOX_VALUE_FALSE:
				(*output->pos++) = 'f';
				(*output->pos++) = 'a';
				(*output->pos++) = 'l';
				(*output->pos++) = 's';
				(*output->pos++) = 'e';
				break;
			case JSOX_VALUE_NULL:
				(*output->pos++) = 'n';
				(*output->pos++) = 'u';
				(*output->pos++) = 'l';
				(*output->pos++) = 'l';
				break;
			case JSOX_VALUE_UNDEFINED:
				(*output->pos++) = 'u';
				(*output->pos++) = 'n';
				(*output->pos++) = 'd';
				(*output->pos++) = 'e';
				(*output->pos++) = 'f';
				(*output->pos++) = 'i';
				(*output->pos++) = 'n';
				(*output->pos++) = 'e';
				(*output->pos++) = 'd';
				break;
			case JSOX_VALUE_NEG_NAN:
				(*output->pos++) = '-';
			case JSOX_VALUE_NAN:
				(*output->pos++) = 'N';
				(*output->pos++) = 'a';
				(*output->pos++) = 'N';
				break;
			case JSOX_VALUE_NEG_INFINITY:
				(*output->pos++) = '-';
			case JSOX_VALUE_INFINITY:
				(*output->pos++) = 'I';
				(*output->pos++) = 'n';
				(*output->pos++) = 'f';
				(*output->pos++) = 'i';
				(*output->pos++) = 'n';
				(*output->pos++) = 'i';
				(*output->pos++) = 't';
				(*output->pos++) = 'y';
				break;
			}
		}
		switch( state->word ) {
		default:
			lprintf( "FAULT: UNEXPECTED VALUE WORD POS RECOVERING IDENT:%d", state->word );
			break;
		case JSOX_WORD_POS_AFTER_FIELD:
		case JSOX_WORD_POS_FIELD:
  // full text fro before.
		case JSOX_WORD_POS_END:
			break;
		case JSOX_WORD_POS_TRUE_1:
			(*output->pos++) = 't';
			break;
		case JSOX_WORD_POS_TRUE_2:
			(*output->pos++) = 't';
			(*output->pos++) = 'r';
			break;
		case JSOX_WORD_POS_TRUE_3:
			(*output->pos++) = 't';
			(*output->pos++) = 'r';
			(*output->pos++) = 'u';
			break;
 // 11
		case JSOX_WORD_POS_FALSE_1:
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_FALSE_2:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			break;
		case JSOX_WORD_POS_FALSE_3:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			(*output->pos++) = 'l';
			break;
		case JSOX_WORD_POS_FALSE_4:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			(*output->pos++) = 'l';
			(*output->pos++) = 's';
			break;
 // 21  get u
		case JSOX_WORD_POS_NULL_1:
			(*output->pos++) = 'n';
			break;
 //  get l
		case JSOX_WORD_POS_NULL_2:
			(*output->pos++) = 'n';
			(*output->pos++) = 'u';
			break;
 //  get l
		case JSOX_WORD_POS_NULL_3:
			(*output->pos++) = 'n';
			(*output->pos++) = 'u';
			(*output->pos++) = 'l';
			break;
  // 31
		case JSOX_WORD_POS_UNDEFINED_1:
			(*output->pos++) = 'u';
			break;
		case JSOX_WORD_POS_UNDEFINED_2:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_UNDEFINED_3:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			break;
		case JSOX_WORD_POS_UNDEFINED_4:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			break;
		case JSOX_WORD_POS_UNDEFINED_5:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_UNDEFINED_6:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_UNDEFINED_7:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_UNDEFINED_8:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'e';
			break;
		case JSOX_WORD_POS_NAN_1:
			(*output->pos++) = 'N';
			break;
		case JSOX_WORD_POS_NAN_2:
			(*output->pos++) = 'N';
			(*output->pos++) = 'a';
			break;
		case JSOX_WORD_POS_INFINITY_1:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			break;
		case JSOX_WORD_POS_INFINITY_2:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_INFINITY_3:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_INFINITY_4:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_INFINITY_5:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_INFINITY_6:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_INFINITY_7:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'i';
			(*output->pos++) = 't';
			break;
		}
	}
#ifdef DEBUG_PARSING
	lprintf( "RECOVER IDENT: TURN INTO FIELD NAME" );
#endif
	state->word = JSOX_WORD_POS_FIELD;
	state->negative = FALSE;
	state->val.value_type = JSOX_VALUE_STRING;
	state->completedString = FALSE;
/*'{'*/
	if( cInt == 123 )
		openObject( state, output, cInt );
/*'['*/
	else if( cInt == 91 )
		openArray( state, output, cInt );
	else if( cInt >= 0 ) {
		// ignore white space.
/*' '*/
		if( cInt == 32 || cInt == 13 || cInt == 10 || cInt == 9 || cInt == 0xFEFF || cInt == 2028 || cInt == 2029 ) {
			state->word = JSOX_WORD_POS_END;
			state->val.stringLen = output->pos - state->val.string;
			return 0;
		}
/*','*/
/*'}'*/
/*']'*/
/*':'*/
		if( cInt == 44 || cInt == 125 || cInt == 93 || cInt == 58 )
			vtprintf( state->pvtError, "invalid character; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, cInt, state->n, state->line, state->col );
		else {
			if( !state->val.string )  state->val.string = output->pos;
			if( cInt < 128 ) (*output->pos++) = cInt;
			else output->pos += ConvertToUTF8( output->pos, cInt );
#ifdef DEBUG_PARSING
			lprintf( "Collected .. %d %c  %*.*s", cInt, cInt, output->pos - state->val.string, output->pos - state->val.string, state->val.string );
#endif
			state->val.stringLen = output->pos - state->val.string;
		}
	}
	return 0;
}
static void pushValue( struct jsox_parse_state *state, PDATALIST *pdl, struct jsox_value_container *val, int line ) {
#define pushValue(a,b,c) pushValue(a,b,c,__LINE__)
#ifdef DEBUG_PARSING
	lprintf( "pushValue:%d %d", val->value_type, state->arrayType );
	if( val->name )
		lprintf( "push named:%*.*s %d", val->nameLen, val->nameLen, val->name, line );
#endif
	if( val->value_type == JSOX_VALUE_ARRAY ) {
		if( state->arrayType >= 0 ) {
			struct jsox_value_container *innerVal = (struct jsox_value_container *)GetDataItem( &val->contains, 0 );
			//size_t size;
			val->className = (char*)GetLink( &knownArrayTypeNames, state->arrayType );
			val->value_type = (enum jsox_value_types)(JSOX_VALUE_TYPED_ARRAY + state->arrayType);
			//lprintf( "INPUT:%d %s", val->stringLen, val->string );
			if( state->arrayType < 12 )
				val->string = (char*)DecodeBase64Ex( innerVal->string, innerVal->stringLen, &val->stringLen, NULL );
			//lprintf( "base:%s", EncodeBase64Ex( "HELLO, World!", 13, NULL, NULL ) );
			//lprintf( "Resolve base64 string:%s", val->string );
		}
	}
	AddDataItem( pdl, val );
}
static LOGICAL isNonIdentifier( TEXTRUNE c ) {
	if( c < 0xFF ) {
		if( nonIdentifiers8[c] ) {
			return TRUE;
		}
	}
	else {
		int n;
		for( n = 0; n < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )); n++ ) {
			if( c >= (TEXTRUNE)nonIdentifierBits[n].firstChar && c < (TEXTRUNE)nonIdentifierBits[n].lastChar &&
				(nonIdentifierBits[n].bits[(c - nonIdentifierBits[n].firstChar) / 24]
					& (1 << ((c - nonIdentifierBits[n].firstChar) % 24))) )
				return TRUE;
		}
	}
	return FALSE;
}
int jsox_parse_add_data( struct jsox_parse_state *state
                            , const char * msg
                            , size_t msglen )
{
	/* I guess this is a good parser */
	TEXTRUNE c;
	PJSOX_PARSE_BUFFER input;
	struct jsox_output_buffer* output;
	int string_status;
	int retval = 0;
	if( !state->status )
		return -1;
	if( msg && msglen ) {
		if( input = (PJSOX_PARSE_BUFFER)PeekQueue( state->inBuffers[0] ) ) {
			size_t used = input->pos - input->buf;
			size_t unused = input->size - used;
			if( input->tempBuf || ( unused < 6 ) ) {
				const char *newBuf = NewArray( const char, unused + msglen );
				memcpy( (char*)newBuf, input->pos, unused );
				memcpy( (char*)newBuf + unused, msg, msglen );
				if( input->tempBuf )
					Deallocate( CPOINTER, input->buf );
				input->pos = input->buf = newBuf;
				input->tempBuf = TRUE;
			}
		}
		// no input; or this buffer wasn't appended to the previous buffer...
		if( !input || !input->tempBuf )
		{
			input = GetFromSet( JSOX_PARSE_BUFFER, &jxpsd.parseBuffers );
			input->pos = input->buf = msg;
			input->size = msglen;
			input->tempBuf = FALSE;
			EnqueLinkNL( state->inBuffers, input );
		}
		if( state->gatheringString
			|| state->gatheringNumber
			|| state->word == JSOX_WORD_POS_FIELD
			|| state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) {
			// have to extend the previous output buffer to include this one instead of allocating a split string.
			size_t offset;
			size_t offset2;
			output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
			//lprintf( "output from before is %p", output );
			offset = (output->pos - output->buf);
			offset2 = state->val.string ? (state->val.string - output->buf) : 0;
			AddLink( state->outValBuffers, output->buf );
			output->buf = NewArray( char, output->size + msglen + 1 );
			if( state->val.string ) {
				MemCpy( output->buf + offset2, state->val.string, offset - offset2 );
				state->val.string = output->buf + offset2;
			}
			output->size += msglen;
			//lprintf( "previous val:%s", state->val.string, state->val.string );
			output->pos = output->buf + offset;
			PrequeLink( state->outQueue, output );
		}
		else {
			output = (struct jsox_output_buffer*)GetFromSet( JSOX_PARSE_BUFFER, &jxpsd.parseBuffers );
			output->pos = output->buf = NewArray( char, msglen + 1 );
			output->size = msglen;
			EnqueLinkNL( state->outQueue, output );
		}
	}
	else {
		// zero length input buffer... terminate a number.
		if( state->gatheringNumber ) {
			//console.log( "Force completed.")
			output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
			output->pos[0] = 0;
			PushLink( state->outBuffers, output );
			state->gatheringNumber = FALSE;
			//lprintf( "result with number:%s", state->val.string );
			if( state->val.float_result )
			{
				CTEXTSTR endpos;
				state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
				if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
			}
			else
			{
				state->val.result_n = IntCreateFromText( state->val.string );
				if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
			}
			state->val.value_type = JSOX_VALUE_NUMBER;
			if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
				state->completed = TRUE;
			}
			retval = 1;
		}
	}
	while( state->status && ( input = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) ) ) {
		size_t newN;
		output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
		//lprintf( "output is %p", output );
		state->n = input->pos - input->buf;
		if( state->n > input->size ) DebugBreak();
		if( state->gatheringString ) {
			string_status = gatherStringX( state, input->buf, &input->pos, input->size, &output->pos, state->gatheringStringFirstChar );
			if( string_status < 0 )
				state->status = FALSE;
			else if( string_status > 0 )
			{
				state->gatheringString = FALSE;
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
				state->val.stringLen = (output->pos - state->val.string)-1;
#ifdef DEBUG_PARSING
				lprintf( "STRING1: %s %d", state->val.string, state->val.stringLen );
#endif
				if( state->status ) {
					state->val.value_type = JSOX_VALUE_STRING;
					state->completedString = TRUE;
				}
			}
			else {
				state->n = input->pos - input->buf;
				if( state->n > input->size ) {
					DebugBreak();
				}
			}
		}
		if( state->gatheringNumber ) {
			//lprintf( "continue gathering a string" );
			goto continueNumber;
		}
		//lprintf( "Completed at start?%d", state->completed );
		while( state->status && (state->n < input->size) && ( (c = GetUtfChar( &input->pos ))!= BADUTF8) )
		{
#ifdef DEBUG_PARSING
			lprintf( "parse character %c %d %d %d %d", c<32?'.':c, state->word, state->parse_context, state->parse_context, state->word );
#endif
			state->col++;
			newN = input->pos - input->buf;
			if( newN > input->size ) {
				// partial utf8 character across buffer boundaries.
				//DebugBreak();
				break;
			}
			state->n = newN;
			if( state->comment ) {
				if( state->comment == 1 ) {
					if( c == '*' ) { state->comment = 3; continue; }
					if( c != '/' ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "Fault while parsing; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
					else state->comment = 2;
					continue;
				}
				if( state->comment == 2 ) {
					if( c == '\n' ) { state->comment = 0; continue; }
					else continue;
				}
				if( state->comment == 3 ) {
					if( c == '*' ) { state->comment = 4; continue; }
					else continue;
				}
				if( state->comment == 4 ) {
					if( c == '/' ) { state->comment = 0; continue; }
					else { if( c != '*' ) state->comment = 3; continue; }
				}
			}
			switch( c )
			{
			case '/':
				if( !state->comment ) state->comment = 1;
				break;
			case '{':
				openObject( state, output, c );
				break;
			case '[':
				openArray( state, output, c );
				break;
			case ':':
				if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD
					|| state->parse_context == JSOX_CONTEXT_CLASS_VALUE
					|| state->parse_context == JSOX_CONTEXT_CLASS_FIELD
					)
				{
					if( state->word != JSOX_WORD_POS_RESET
						&& state->word != JSOX_WORD_POS_FIELD
						&& state->word != JSOX_WORD_POS_AFTER_FIELD ) {
						// allow starting a new word
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "unquoted keyword used as object field name:parsing fault; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
						break;
					}
					else if( state->word == JSOX_WORD_POS_FIELD || state->word == JSOX_WORD_POS_AFTER_FIELD && !state->completedString ) {
						state->val.stringLen = ( output->pos - state->val.string );
						(*output->pos++) = 0;
					}
					else if( (state->val.value_type == JSOX_VALUE_STRING) && !state->completedString ) {
						state->val.stringLen = ( output->pos - state->val.string );
						(*output->pos++) = 0;
					}
					if( state->val.name ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "two names single value?" );
					}
					state->word = JSOX_WORD_POS_RESET;
					state->val.name = state->val.string;
					state->val.nameLen = state->val.stringLen;
					state->val.string = NULL;
					state->val.stringLen = 0;
					// classname will later indicate this was a class...
					// this can no longer be a prototype definition (class_field)
					// but if it's a value, we want to stay that we're collecting class values.
					state->parse_context = (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD || state->parse_context == JSOX_CONTEXT_CLASS_FIELD)
						? JSOX_CONTEXT_OBJECT_FIELD_VALUE
						: JSOX_CONTEXT_CLASS_FIELD_VALUE;
					state->val.value_type = JSOX_VALUE_UNSET;
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
						vtprintf( state->pvtError, "(in array, got colon out of string):parsing fault; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
					else
						vtprintf( state->pvtError, "(outside any object, got colon out of string):parsing fault; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case '}':
				if( state->word == JSOX_WORD_POS_END ) {
					// allow starting a new word
					state->word = JSOX_WORD_POS_RESET;
				}
				if( state->parse_context == JSOX_CONTEXT_CLASS_FIELD ) {
					if( state->current_class ) {
						// allow blank comma at end to not be a field
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						if(state->val.string) {
							struct jsox_class_field *field = GetFromSet( JSOX_CLASS_FIELD, &jxpsd.class_fields );
							field->name = state->val.string;
							field->nameLen = output->pos - state->val.string;
							(*output->pos++) = 0;
							state->val.string = NULL;
							AddLink( &state->current_class->fields, field );
							//AddLink( &state->current_class->fields, state->val.string );
						}
						JSOX_RESET_STATE_VAL();
						state->word = JSOX_WORD_POS_RESET;
						/*
						state->val.value_type = JSOX_VALUE_OBJECT;
						state->val.contains = state->elements[0];
						state->val._contains = state->elements;
						if( state->current_class )
							state->val.className = state->current_class->name;
						*/
#ifdef DEBUG_PARSING_STCK
						lprintf( "object pop stack (close obj) %d %p", context_stack.length, old_context );
#endif
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					} else {
						vtprintf( state->pvtError, "State error; gathering class fields, and lost the class; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f
							, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
				} else if( ( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) || state->parse_context == JSOX_CONTEXT_CLASS_VALUE ) {
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->current_class ) {
							if( state->current_class->fields ) {
								struct jsox_class_field *field = (struct jsox_class_field *)GetLink( &state->current_class->fields, state->current_class_item++ );
								state->val.name = field->name;
								state->val.nameLen = field->nameLen;
							}
							else {
								if( !state->val.name ) {
									vtprintf( state->pvtError, "State error; class fields, class has no fields, and one was needed; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f
										, c, state->n, state->line, state->col );
									state->status = FALSE;
									break;
								}
							}
						}
#ifdef DEBUG_PARSING
						lprintf( "Push value closing class value %d %p", state->current_class_item, state->current_class );
#endif
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
					//if( _DEBUG_PARSING ) lprintf( "close object; empty object", val, elements );
					state->val.value_type = JSOX_VALUE_OBJECT;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					if( state->current_class )
						state->val.className = state->current_class->name;
					state->val.string = NULL;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//if( _DEBUG_PARSING_STACK ) console.log( "object pop stack (close obj)", context_stack.length, old_context );
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				} else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE ) {
					//enum json_value_types
#ifdef DEBUG_PARSING
					lprintf( "close object; empty object %d", state->val.value_type );
#endif
					//if( (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE) )
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->val.string ) {
							if( state->val.value_type != JSOX_VALUE_STRING ) {
								state->val.stringLen = output->pos - state->val.string;
#ifdef DEBUG_PARSING
								lprintf( "STRING2: %s %d", state->val.string, state->val.stringLen );
#endif
								(*output->pos++) = 0;
							}
						}
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
					//JSOX_RESET_STATE_VAL();
					state->val.value_type = JSOX_VALUE_OBJECT;
					state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					if( state->current_class )
						state->val.className = state->current_class->name;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//struct jsox_value_container *oldVal = (struct jsox_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, "Fault while parsing; unexpected %c at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ']':
				state->word = JSOX_WORD_POS_RESET;
				if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
				{
#ifdef DEBUG_PARSING
					lprintf( "close array, push last element: %d", state->val.value_type );
#endif
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->val.string ) {
							if( state->val.value_type != JSOX_VALUE_STRING ) {
								state->val.stringLen = output->pos - state->val.string;
#ifdef DEBUG_PARSING
								lprintf( "STRING3: %s %d", state->val.string, state->val.stringLen );
#endif
								(*output->pos++) = 0;
							}
						}
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
					state->val.value_type = JSOX_VALUE_ARRAY;
					//state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					if( state->current_class )
						state->val.className = state->current_class->name;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//struct jsox_value_container *oldVal = (struct jsox_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, "bad context %d; fault while parsing; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, state->parse_context, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ',':
				if( state->word == JSOX_WORD_POS_END || state->word == JSOX_WORD_POS_FIELD ) {
					// allow starting a new word
					state->word = JSOX_WORD_POS_RESET;
				}
				if( state->parse_context == JSOX_CONTEXT_CLASS_FIELD ) {
					if( state->current_class ) {
						struct jsox_class_field *field = GetFromSet( JSOX_CLASS_FIELD, &jxpsd.class_fields );
						field->name = state->val.string;
						field->nameLen = output->pos - state->val.string;
						(*output->pos++) = 0;
						state->val.string = NULL;
						AddLink( &state->current_class->fields, field );
						state->word = JSOX_WORD_POS_FIELD;
					}
					else {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
						vtprintf( state->pvtError, "lost class definition; fault while parsing; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, state->parse_context, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_CLASS_VALUE ) {
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->current_class->fields ) {
							struct jsox_class_field *field = (struct jsox_class_field *)GetLink( &state->current_class->fields, state->current_class_item++ );
							state->val.name = field->name;
							state->val.nameLen = field->nameLen;
						}
						else if( !state->val.name ) {
							if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
							vtprintf( state->pvtError, "class field has no matching field definitions; fault while parsing; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, state->parse_context, c, state->n, state->line, state->col );
							state->status = FALSE;
							break;
						}
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
						//state->parse_context = JSOX_CONTEXT_CLASS_FIELD;
						state->word = JSOX_WORD_POS_RESET;
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
				{
					if( state->val.value_type == JSOX_VALUE_UNSET )
 // in an array, elements after a comma should init as undefined...
						state->val.value_type = JSOX_VALUE_EMPTY;
																 // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
#ifdef DEBUG_PARSING
						lprintf( "back in array; push item %d", state->val.value_type );
#endif
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE )
				{
					// after an array value, it will have returned to OBJECT_FIELD anyway
#ifdef DEBUG_PARSING
					lprintf( "comma after field value, push field to object: %s", state->val.name );
#endif
					state->parse_context = JSOX_CONTEXT_OBJECT_FIELD;
					state->word = JSOX_WORD_POS_RESET;
					if( state->val.value_type != JSOX_VALUE_UNSET )
						pushValue( state, state->elements, &state->val );
					JSOX_RESET_STATE_VAL();
				}
				else if( state->parse_context == JSOX_CONTEXT_CLASS_VALUE ) {
					// after an array value, it will have returned to OBJECT_FIELD anyway
#ifdef DEBUG_PARSING
					lprintf( "comma after field value, push field to object: %s", state->val.name );
#endif
					state->parse_context = JSOX_CONTEXT_OBJECT_FIELD;
					state->word = JSOX_WORD_POS_RESET;
					if( state->val.value_type != JSOX_VALUE_UNSET )
						pushValue( state, state->elements, &state->val );
					JSOX_RESET_STATE_VAL();
				}
				else
				{
					state->status = FALSE;
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, "bad context; fault while parsing; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
				}
				break;
			default:
				if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD
				   //|| state->parse_context == JSOX_CONTEXT_UNKNOWN
				   //|| state->parse_context == JSOX_CONTEXT_IN_ARRAY
				   || (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE && state->word == JSOX_WORD_POS_FIELD )
				   || state->parse_context == JSOX_CONTEXT_CLASS_FIELD
				) {
					//lprintf( "gathering object field:%c  %*.*s", c, output->pos- state->val.string, output->pos - state->val.string, state->val.string );
					switch( c )
					{
					case '`':
						// this should be a special case that passes continuation to gatherString
						// but gatherString now just gathers all strings
					case '"':
					case '\'':
						if( state->val.value_type == JSOX_VALUE_STRING
							&& state->val.className ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
							vtprintf( state->pvtError, "too many strings in a row; fault while parsing; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
							break;
						}
						if( state->word == JSOX_WORD_POS_FIELD
							|| ( state->val.value_type == JSOX_VALUE_STRING
								&& !state->val.className ) ) {
							(*output->pos++) = 0;
							state->val.className = state->val.string;
						}
						state->val.string = output->pos;
						state->gatheringString = TRUE;
						state->gatheringStringFirstChar = c;
						string_status = gatherStringX( state, input->buf, &input->pos, input->size, &output->pos, c );
						//lprintf( "string gather status:%d", string_status );
						if( string_status < 0 )
							state->status = FALSE;
						else if( string_status > 0 ) {
							state->gatheringString = FALSE;
							state->val.stringLen = (output->pos - state->val.string) - 1;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) state->completed = TRUE;
#ifdef DEBUG_PARSING
							lprintf( "STRING4: %s %d", state->val.string, state->val.stringLen );
#endif
						}
						state->n = input->pos - input->buf;
						if( state->n > input->size ) DebugBreak();
						if( state->status ) {
							state->val.value_type = JSOX_VALUE_STRING;
							state->completedString = TRUE;
							state->word = JSOX_WORD_POS_AFTER_FIELD;
							//state->val.stringLen = (output->pos - state->val.string - 1);
							//lprintf( "Set string length:%d", state->val.stringLen );
						}
						break;
					case '\n':
						state->line++;
						state->col = 1;
						// fall through to normal space handling - just updated line/col position
					case ' ':
					case '\t':
					case '\r':
 // LS (Line separator)
					case 2028:
 // PS (paragraph separate)
					case 2029:
 // ZWNBS is WS though
					case 0xFEFF:
						if( state->word == JSOX_WORD_POS_END ) {
							state->word = JSOX_WORD_POS_RESET;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
							break;
						}
						if( (state->word == JSOX_WORD_POS_RESET) || ( state->word == JSOX_WORD_POS_AFTER_FIELD ) )
							break;
						else if( state->word == JSOX_WORD_POS_FIELD ) {
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
								break;
							}
							if( state->val.string ) {
								state->val.value_type = JSOX_VALUE_STRING;
								state->word = JSOX_WORD_POS_AFTER_FIELD;
								//if( state->parse_context == JSOX_CONTEXT_UNKNOWN )
								//	state->completed = TRUE;
							}
						}
						else {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, "fault while parsing; whitespace unexpected at %" _size_f "  %" _size_f ":%" _size_f, state->n, state->line, state->col );
						}
						// skip whitespace
						//n++;
						//lprintf( "whitespace skip..." );
						break;
					default:
						if( state->word == JSOX_WORD_POS_RESET && ( (c >= '0' && c <= '9') || (c == '+') || (c == '.') ) ) {
							goto beginNumber;
						}
						if( state->word == JSOX_WORD_POS_AFTER_FIELD ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, "fault while parsing; second string in field name at %" _size_f "  %" _size_f ":%" _size_f, state->n, state->line, state->col );
							break;
						} else if( state->word == JSOX_WORD_POS_RESET ) {
							state->word = JSOX_WORD_POS_FIELD;
							state->val.string = output->pos;
							state->val.value_type = JSOX_VALUE_STRING;
							state->completedString = FALSE;
						}
						if( isNonIdentifier( c ) ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, "fault while parsing object field name; \\u00%02X unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
							break;
						}
						if( !state->val.string ) state->val.string = output->pos;
						if( c < 128 ) (*output->pos++) = c;
						else output->pos += ConvertToUTF8( output->pos, c );
 // default
						break;
					}
				}
				else switch( c )
				{
				case '`':
					// this should be a special case that passes continuation to gatherString
					// but gatherString now just gathers all strings
				case '"':
				case '\'':
					if( state->word == JSOX_WORD_POS_FIELD
						|| ( state->val.value_type == JSOX_VALUE_STRING
							 && !state->val.className ) ) {
						(*output->pos++) = 0;
						state->val.className = state->val.string;
					}
					state->val.string = output->pos;
					state->gatheringString = TRUE;
					state->gatheringStringFirstChar = c;
					string_status = gatherStringX( state, input->buf, &input->pos, input->size, &output->pos, c );
					//lprintf( "string gather status:%d", string_status );
					if( string_status < 0 )
						state->status = FALSE;
					else if( string_status > 0 ) {
						state->gatheringString = FALSE;
						state->val.stringLen = (output->pos - state->val.string) - 1;
#ifdef DEBUG_PARSING
						lprintf( "STRING5: %s %d", state->val.string, state->val.stringLen );
#endif
					} else if( state->complete_at_end ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "End of string fail." );
						state->status = FALSE;
					}
					state->n = input->pos - input->buf;
					if( state->n > input->size ) DebugBreak();
					if( state->status ) {
						state->val.value_type = JSOX_VALUE_STRING;
						state->completedString = TRUE;
						state->word = JSOX_WORD_POS_END;
						if( state->complete_at_end ) {
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					break;
				case '\n':
					state->line++;
					state->col = 1;
					// FALLTHROUGH
				case ' ':
 // LS (Line separator)
				case 2028:
 // PS (paragraph separate)
				case 2029:
				case '\t':
				case '\r':
				case 0xFEFF:
					if( state->word == JSOX_WORD_POS_END ) {
						state->word = JSOX_WORD_POS_RESET;
						if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
							state->completed = TRUE;
						}
						break;
					}
					if( state->word == JSOX_WORD_POS_RESET || (state->word == JSOX_WORD_POS_AFTER_FIELD) ) {
						break;
					}
					else if( state->word == JSOX_WORD_POS_FIELD ) {
						if( state->val.string ) {
							state->val.value_type = JSOX_VALUE_STRING;
							state->word = JSOX_WORD_POS_AFTER_FIELD;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN )
								state->completed = TRUE;
						}
					}
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
						vtprintf( state->pvtError, "fault while parsing; whitespace unexpected at %" _size_f "  %" _size_f ":%" _size_f, state->n );
					}
					// skip whitespace
					//n++;
					//lprintf( "whitespace skip..." );
					break;
					//----------------------------------------------------------
					//  catch characters for true/false/null/undefined which are values outside of quotes
				case 't':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_TRUE_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_6 ) state->word = JSOX_WORD_POS_INFINITY_7;
					else recoverIdent( state, output, c );
					break;
				case 'r':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_1 ) state->word = JSOX_WORD_POS_TRUE_2;
					else {
						recoverIdent( state, output, c );
// fault
					}
					break;
				case 'u':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_2 ) state->word = JSOX_WORD_POS_TRUE_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_1 ) state->word = JSOX_WORD_POS_NULL_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_UNDEFINED_1;
					else recoverIdent( state, output, c );
					break;
				case 'e':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_3 ) {
						state->val.value_type = JSOX_VALUE_TRUE;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_4 ) {
						state->val.value_type = JSOX_VALUE_FALSE;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_3 ) state->word = JSOX_WORD_POS_UNDEFINED_4;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_7 ) state->word = JSOX_WORD_POS_UNDEFINED_8;
					else recoverIdent( state, output, c );
					break;
				case 'n':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_NULL_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_1 ) state->word = JSOX_WORD_POS_UNDEFINED_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_6 ) state->word = JSOX_WORD_POS_UNDEFINED_7;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_1 ) state->word = JSOX_WORD_POS_INFINITY_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_4 ) state->word = JSOX_WORD_POS_INFINITY_5;
					else recoverIdent( state, output, c );
					break;
				case 'd':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_2 ) state->word = JSOX_WORD_POS_UNDEFINED_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_8 ) { state->val.value_type = JSOX_VALUE_UNDEFINED; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
				case 'i':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_5 ) state->word = JSOX_WORD_POS_UNDEFINED_6;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_3 ) state->word = JSOX_WORD_POS_INFINITY_4;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_5 ) state->word = JSOX_WORD_POS_INFINITY_6;
					else recoverIdent( state, output, c );
					break;
				case 'l':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_2 ) state->word = JSOX_WORD_POS_NULL_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_3 ) {
						state->val.value_type = JSOX_VALUE_NULL;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_2 ) state->word = JSOX_WORD_POS_FALSE_3;
					else recoverIdent( state, output, c );
					break;
				case 'f':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_FALSE_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_4 ) state->word = JSOX_WORD_POS_UNDEFINED_5;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_2 ) state->word = JSOX_WORD_POS_INFINITY_3;
					else recoverIdent( state, output, c );
					break;
				case 'a':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_1 ) state->word = JSOX_WORD_POS_FALSE_2;
					else if(state->val.value_type == JSOX_VALUE_UNSET &&  state->word == JSOX_WORD_POS_NAN_1 ) state->word = JSOX_WORD_POS_NAN_2;
					else recoverIdent( state, output, c );
					break;
				case 's':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_3 ) state->word = JSOX_WORD_POS_FALSE_4;
					else recoverIdent( state, output, c );
					break;
				case 'I':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_INFINITY_1;
					else recoverIdent( state, output, c );
					break;
				case 'N':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_NAN_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NAN_2 ) { state->val.value_type = state->negative ? JSOX_VALUE_NEG_NAN : JSOX_VALUE_NAN; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
				case 'y':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_7 ) { state->val.value_type = state->negative ? JSOX_VALUE_NEG_INFINITY : JSOX_VALUE_INFINITY; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
					//
					//----------------------------------------------------------
				case '-':
					state->negative = !state->negative;
					break;
				default:
					if( state->word == JSOX_WORD_POS_RESET && ( (c >= '0' && c <= '9') || (c == '+') || (c == '.') ) )
					{
						LOGICAL fromDate;
 // to unwind last character past number.
						const char *_msg_input;
						// always reset this here....
						// keep it set to determine what sort of value is ready.
					beginNumber:
						if( !state->gatheringNumber ) {
							state->numberFromBigInt = FALSE;
							state->numberFromDate = FALSE;
							state->exponent = FALSE;
							state->exponent_sign = FALSE;
							state->exponent_digit = FALSE;
							fromDate = FALSE;
							state->fromHex = FALSE;
							state->val.float_result = (c == '.');
							state->val.string = output->pos;
  // terminate the string.
							(*output->pos++) = c;
						}
						else
						{
						continueNumber:
							fromDate = state->numberFromDate;
						}
						while( (_msg_input = input->pos), ((state->n < input->size) && ( (c = GetUtfChar( &input->pos ))!= BADUTF8)) )
						{
							newN = input->pos - input->buf;
							if( newN > input->size ) {
								break;
							}
							state->n = newN;
							//lprintf( "Number input:%c", c );
							state->col++;
							if( state->n > input->size ) DebugBreak();
							// leading zeros should be forbidden.
							if( c == '_' )
								continue;
							if( c >= '0' && c <= '9' )
							{
								(*output->pos++) = c;
								if( state->exponent )
									state->exponent_digit = TRUE;
							}
							// to be implemented
							else if( c == ':' || c == '-' || c == 'T' || c == 'Z' || c == '+' ) {
								/* toISOString()
								var today = new Date('05 October 2011 14:48 UTC');
								console.log(today.toISOString());
								// Returns 2011-10-05T14:48:00.000Z
								*/
								(*output->pos++) = c;
								state->numberFromDate = TRUE;
							}
							else if( ( c == 'x' || c == 'b' || c =='o' || c == 'X' || c == 'B' || c == 'O')
							       && ( output->pos - state->val.string) == 1
							       && state->val.string[0] == '0' ) {
								// hex conversion.
								if( !state->fromHex ) {
									state->fromHex = TRUE;
 // force lower case.
									(*output->pos++) = c | 0x20;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, "fault while parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( (c == 'e') || (c == 'E') )
							{
								if( !state->exponent ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
									state->exponent = TRUE;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, "fault white parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( c == '-' || c == '+' ) {
								if( !state->exponent ) {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, "fault white parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
									break;
								}
								else {
									if( !state->exponent_sign && !state->exponent_digit ) {
										(*output->pos++) = c;
										state->exponent_sign = 1;
									}
									else {
										state->status = FALSE;
										if( !state->pvtError ) state->pvtError = VarTextCreate();
										vtprintf( state->pvtError, "fault white parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
										break;
									}
								}
							} else if( c == 'n' ) {
								(*output->pos++) = c;
								state->numberFromBigInt = TRUE;
 // consume character.
								_msg_input = input->pos;
								break;
							} else if( c == '.' ) {
								if( !state->val.float_result && !state->fromHex ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, "fault white parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
									break;
								}
							} else {
								// in non streaming mode; these would be required to follow
								if( c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 0xFEFF
									|| c == ',' || c == ']' || c == '}'  || c == ':' ) {
									//lprintf( "Non numeric character received; push the value we have" );
									(*output->pos) = 0;
									break;
								}
								else {
									if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
										(*output->pos) = 0;
										break;
									}
									else {
										state->status = FALSE;
										if( !state->pvtError ) state->pvtError = VarTextCreate();
										vtprintf( state->pvtError, "fault white parsing number; '%c' unexpected at %" _size_f "  %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
										break;
									}
								}
							}
						}
						if( input ) {
							input->pos = _msg_input;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
						}
						//LogBinary( (uint8_t*)output->buf, output->size );
						if( input && (!state->complete_at_end) && state->n == input->size )
						{
							//lprintf( "completion mode is not end of string; and at end of string" );
							state->gatheringNumber = TRUE;
							state->numberFromDate = fromDate;
						}
						else
						{
							(*output->pos++) = 0;
							state->val.stringLen = (output->pos - state->val.string) - 1;
#ifdef DEBUG_PARSING
							lprintf( "STRING6: %s %d", state->val.string, state->val.stringLen );
#endif
							state->gatheringNumber = FALSE;
							//lprintf( "result with number:%s", state->val.string );
							if( state->val.float_result )
							{
								CTEXTSTR endpos;
								state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
								if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
							}
							else
							{
								state->val.result_n = IntCreateFromText( state->val.string );
								if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
							}
							if( state->numberFromDate )
								state->val.value_type = JSOX_VALUE_DATE;
							else if( state->numberFromBigInt )
								state->val.value_type = JSOX_VALUE_BIGINT;
							else
								state->val.value_type = JSOX_VALUE_NUMBER;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					else
					{
						recoverIdent( state, output, c );
					}
 // default
					break;
				}
 // default of high level switch
				break;
			}
			// got a completed value; skip out
			if( state->completed ) {
				if( state->word == JSOX_WORD_POS_END ) {
					state->word = JSOX_WORD_POS_RESET;
				}
				break;
			}
		}
		//lprintf( "at end... %d %d comp:%d", state->n, input->size, state->completed );
		if( input ) {
			if( state->n >= input->size ) {
				if( input->tempBuf )
					Deallocate( CPOINTER, input->buf );
				DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, input );
				if( state->gatheringString
					|| state->gatheringNumber
					|| state->parse_context == JSOX_CONTEXT_OBJECT_FIELD
					|| state->word == JSOX_WORD_POS_FIELD ) {
					//lprintf( "output is still incomplete? " );
					PrequeLink( state->outQueue, output );
					retval = 0;
				}
				else {
					PushLink( state->outBuffers, output );
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN
					  && ( state->val.value_type != JSOX_VALUE_UNSET
					     || state->elements[0]->Cnt ) ) {
						if( state->word == JSOX_WORD_POS_END ) {
							state->word = JSOX_WORD_POS_RESET;
						}
						state->completed = TRUE;
						retval = 1;
					}
				}
				//lprintf( "Is complete already?%d", state->completed );
			}
			else {
				// put these back into the stack.
				//lprintf( "put buffers back into queues..." );
				PrequeLink( state->inBuffers, input );
				PrequeLink( state->outQueue, output );
  // if returning buffers, then obviously there's more in this one.
				retval = 2;
			}
		}
		if( state->completed )
			break;
 // while DequeInput
	}
	if( !state->status ) {
		// some error condition; cannot resume parsing.
		return -1;
	}
	if( state->completed ) {
		if( state->val.value_type != JSOX_VALUE_UNSET ) {
			pushValue( state, state->elements, &state->val );
			JSOX_RESET_STATE_VAL();
		}
		state->completed = FALSE;
	}
	return retval;
}
PDATALIST jsox_parse_get_data( struct jsox_parse_state *state ) {
	PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
	state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
	if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
	else state->elements[0]->Cnt = 0;
	return result[0];
}
const char *jsox_get_parse_buffer( struct jsox_parse_state *pState, const char *buf ) {
	int idx;
	PJSOX_PARSE_BUFFER buffer;
	for( idx = 0; ; idx-- )
		while( buffer = (PJSOX_PARSE_BUFFER)PeekLinkEx( pState->outBuffers, idx ) ) {
			if( !buffer ) break;
			if( ((uintptr_t)buf) >= ((uintptr_t)buffer->buf) && ((uintptr_t)buf) < ((uintptr_t)buffer->pos) )
				return buffer->buf;
		}
	lprintf( "FAILED TO FIND BUFFER TO RETURN" );
	return NULL;
}
void _jsox_dispose_message( PDATALIST *msg_data )
{
	struct jsox_value_container *val;
	INDEX idx;
	if( !msg_data ) return;
	DATA_FORALL( (*msg_data), idx, struct jsox_value_container*, val )
	{
		// names and string buffers for JSON parsed values in a single buffer
		// associated with the root message.
		//if( val->name ) Release( val->name );
		//if( val->string ) Release( val->string );
		if( val->contains )
			_jsox_dispose_message( val->_contains );
	}
	// quick method
	DeleteDataList( msg_data );
	DeleteFromSet( PDATALIST, jxpsd.dataLists, msg_data );
}
static uintptr_t jsox_FindDataList( void*p, uintptr_t psv ) {
	if( ((PPDATALIST)p)[0] == (PDATALIST)psv )
		return (uintptr_t)p;
	return 0;
}
void jsox_dispose_message( PDATALIST *msg_data ) {
	uintptr_t actual = ForAllInSet( PDATALIST, jxpsd.dataLists, jsox_FindDataList, (uintptr_t)msg_data[0] );
	_jsox_dispose_message( (PDATALIST*)actual );
	msg_data[0] = NULL;
}
void jsox_parse_clear_state( struct jsox_parse_state *state ) {
	if( state ) {
		PJSOX_PARSE_BUFFER buffer;
		while( buffer = (PJSOX_PARSE_BUFFER)PopLink( state->outBuffers ) ) {
			Deallocate( const char *, buffer->buf );
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		}
		while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
			Deallocate( const char*, buffer->buf );
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		}
		DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->inBuffers );
		//DeleteLinkQueue( &state->inBuffers );
		DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->outQueue );
		//DeleteLinkQueue( &state->outQueue );
		DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->outBuffers );
		//DeleteLinkStack( &state->outBuffers );
		{
			char *buf;
			INDEX idx;
			LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
				Deallocate( char*, buf );
			}
			DeleteFromSet( PLIST, jxpsd.listSet, state->outValBuffers );
			//DeleteList( &state->outValBuffers );
		}
		state->status = TRUE;
		state->parse_context = JSOX_CONTEXT_UNKNOWN;
		state->word = JSOX_WORD_POS_RESET;
		state->n = 0;
		state->col = 1;
		state->line = 1;
		state->gatheringString = FALSE;
		state->gatheringNumber = FALSE;
		{
			PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
			state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
			if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
			else state->elements[0]->Cnt = 0;
			//state->elements = CreateDataList( sizeof( state->val ) );
			jsox_dispose_message( result );
		}
	}
}
PTEXT jsox_parse_get_error( struct jsox_parse_state *state ) {
	if( !state )
		state = jxpsd.last_parse_state;
	if( !state )
		return NULL;
	if( state->pvtError ) {
		PTEXT error = VarTextGet( state->pvtError );
		return error;
	}
	return NULL;
}
void jsox_parse_dispose_state( struct jsox_parse_state **ppState ) {
	struct jsox_parse_state *state = (*ppState);
	struct jsox_parse_context *old_context;
	PJSOX_PARSE_BUFFER buffer;
	_jsox_dispose_message( state->elements );
	//DeleteDataList( &state->elements );
	while( buffer = (PJSOX_PARSE_BUFFER)PopLink( state->outBuffers ) ) {
		Deallocate( const char *, buffer->buf );
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	}
	{
		char *buf;
		INDEX idx;
		LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
			Deallocate( char*, buf );
		}
		DeleteFromSet( PLIST, jxpsd.listSet, state->outValBuffers );
		//DeleteList( &state->outValBuffers );
	}
	while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
		Deallocate( const char*, buffer->buf );
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	}
	DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->inBuffers );
	//DeleteLinkQueue( &state->inBuffers );
	DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->outQueue );
	//DeleteLinkQueue( &state->outQueue );
	DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->outBuffers );
	//DeleteLinkStack( &state->outBuffers );
	DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, state->context );
	while( (old_context = (struct jsox_parse_context *)PopLink( state->context_stack )) ) {
		//lprintf( "warning unclosed contexts...." );
		DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
	}
	if( state->context_stack )
		DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->context_stack );
		//DeleteLinkStack( &state->context_stack );
	DeleteFromSet( JSOX_PARSE_STATE, jxpsd.parseStates, state );
	//Deallocate( struct jsox_parse_state *, state );
	(*ppState) = NULL;
}
LOGICAL jsox_parse_message( const char * msg
	, size_t msglen
	, PDATALIST *_msg_output ) {
	struct jsox_parse_state *state = jsox_begin_parse();
	//static struct jsox_parse_state *_state;
	state->complete_at_end = TRUE;
	int result = jsox_parse_add_data( state, msg, msglen );
	if( jxpsd._state ) jsox_parse_dispose_state( &jxpsd._state );
	if( result > 0 ) {
		(*_msg_output) = jsox_parse_get_data( state );
		jxpsd._state = state;
		//jsox_parse_dispose_state( &state );
		return TRUE;
	}
	(*_msg_output) = NULL;
	jxpsd.last_parse_state = state;
	jxpsd._state = state;
	return FALSE;
}
struct jsox_parse_state *jsox_get_message_parser( void ) {
	return jxpsd._state;
}
static void stepPath( const char **path ) {
	int skipped;
	do {
		skipped = 0;
		switch( path[0][0] ) {
		case '.':
		case '/':
		case '\\':
		case ' ':
			path[0]++;
			skipped = 1;
			break;
		}
	} while( skipped );
}
struct jsox_value_container *jsox_get_parsed_array_value( struct jsox_value_container *val, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
) {
	if( path[0] == '[' )
		path++;
	int64_t index = IntCreateFromTextRef( &path );
	if( path[0] == ']' )
		path++;
	struct jsox_value_container * member = (struct jsox_value_container*)GetDataItem( &val->contains, (int)index );
	stepPath( &path );
	if( !path[0] ) {
		callback( psv, member );
		return member;
	}
	else {
		if( member->value_type == JSOX_VALUE_ARRAY ) {
			return jsox_get_parsed_array_value( member, path, callback, psv );
		}
		else if( member->value_type == JSOX_VALUE_OBJECT ) {
			return jsox_get_parsed_object_value( member, path, callback, psv );
		}
		else {
			lprintf( "Path across pimitive value...." );
		}
	}
	return NULL;
}
struct jsox_value_container *jsox_get_parsed_object_value( struct jsox_value_container *val, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
) {
	INDEX idx;
	struct jsox_value_container * member;
	DATA_FORALL( val->contains, idx, struct jsox_value_container *, member ) {
		if( StrCmpEx( member->name, path, member->nameLen ) == 0 ) {
			const char *subpath = path + member->nameLen;
			stepPath( &subpath );
			if( !subpath[0] ) {
				callback( psv, member );
				return member;
			}
			else {
				if( member->value_type == JSOX_VALUE_ARRAY ) {
					return jsox_get_parsed_array_value( member, subpath, callback, psv );
				}
				else if( member->value_type == JSOX_VALUE_OBJECT ) {
					return jsox_get_parsed_object_value( member, subpath, callback, psv );
				}
				else {
					lprintf( "Path across pimitive value...." );
				}
			}
		}
	}
	return NULL;
}
struct jsox_value_container *jsox_get_parsed_value( PDATALIST pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
) {
	INDEX idx;
	struct jsox_value_container * val;
	DATA_FORALL( pdlMessage, idx, struct jsox_value_container *, val ) {
		if( !path || !path[0] ) {
			callback( psv, val );
			return val;
		}
		if( val->value_type == JSOX_VALUE_OBJECT ) {
			return jsox_get_parsed_object_value( val, path, callback, psv );
		}
		else if( val->value_type == JSOX_VALUE_ARRAY ) {
			return jsox_get_parsed_array_value( val, path, callback, psv );
		}
		else {
			if( path && path[0] ) {
				lprintf( "Error; path across a primitive value" );
			}
		}
	}
	return NULL;
}
#undef GetUtfChar
#undef __GetUtfChar
#undef _zero
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#ifdef _WIN64
#ifndef __64__
#define __64__
#endif
#endif
#ifdef WIN32
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x501
#endif
#endif
// debugging only gets you the ordering(priority) logging and something else...
// useful logging is now controlled with l.flags.bLog
#define DISABLE_DEBUG_REGISTER_AND_DISPATCH
//#define DEBUG_SHUTDOWN
#define LOG_ALL 0
//
// core library load
//    all procs scheduled, initial = 0
// Application starts, invokes preloads
//    additional libraries load, scheduling because of suspend
//    library load completes by invoking the newly registered list
// final core application schedulging happens, after initial preload completes
//    additional preload scheduligin happens( not suspended, is initial)
//#define DEBUG_CYGWIN_START
//#ifndef __LINUX__
#define IS_DEADSTART
#ifdef __LINUX__
#include <signal.h>
#endif
#ifdef WIN32
 // GetConsoleWindow()
#include <wincon.h>
#endif
/*
 * Create: James Buckeyne
 *
 * Purpose: Provide a general structure to register names of
 *   routines and data structures which may be consulted
 *   for runtime linking.  Aliases and other features make this
 *   a useful library for tracking interface registration...
 *
 *  The namespace may be enumerated.
 */
#ifndef PROCEDURE_REGISTRY_LIBRARY_DEFINED
#define PROCEDURE_REGISTRY_LIBRARY_DEFINED
#ifdef PROCREG_SOURCE
#define PROCREG_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PROCREG_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#ifdef __cplusplus_cli
//using namespace System;
#endif
#   define _INTERFACE_NAMESPACE namespace Interface {
#   define _INTERFACE_NAMESPACE_END }
#define PROCREG_NAMESPACE namespace sack { namespace app { namespace registry {
#define _PROCREG_NAMESPACE namespace registry {
#define _APP_NAMESPACE namespace app {
#define PROCREG_NAMESPACE_END }}}
//extern "C"  {
#else
#   define _INTERFACE_NAMESPACE
#   define _INTERFACE_NAMESPACE_END
#define _PROCREG_NAMESPACE
#define _APP_NAMESPACE
#define PROCREG_NAMESPACE
#define PROCREG_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deadstart is support which differs per compiler, but allows
   applications access a C++ feature - static classes with
   constructors that initialize at loadtime, but, have the
   feature that you can create threads. Deadstart code is run
   after the DLL load lock under windows that prevents creation
   of threads; however, deadstart is run before main. Deadstart
   routines can have a priority. Certain features require others
   to be present always. This allows explicit control of
   priority unlink using classes with static constructors, which
   requires ordering of objects to provide linking order. Also
   provides a similar registration mechanism for atexit, but
   extending with priority. Deadstop registrations are done
   sometime during normal C atexit() handling, but may be
   triggered first by calling BAG_Exit.
   Registry offers support to register functions, and data under
   a hierarchy of names. Names are kept in a string cache, which
   applications can take benefit of. Strings will exist only a
   single time. This table could be saved, and a look-aside
   table for language translation purposes. Registry is the
   support that the latest PSI relies on for registering event
   callbacks for controls. The registry was always used, but,
   the access to it was encapsulated by DoRegisterControl
   registering the appropriate methods.                          */
	_APP_NAMESPACE
   /* Contains methods dealing with registering routines and values
      in memory. Provisions are available to save the configuration
      state, but the best that can be offered here would be a
      translation tool for text strings. The namespace is savable,
      but most of the content of the registration space are short
      term pointers. Namespace containing registry namespace.
      old notes - very discongruant probably should delete them.
      Process name registry
      it's a tree of names.
      there are paths, and entries
      paths are represented as class_name
      PCLASSROOT is also a suitable class name
      PCLASSROOT is defined as a valid CTEXTSTR.
      there is (apparently) a name that is not valid as a path name
      that is TREE
      guess.
      POINTER in these two are equal to (void(*)(void)) but -
      that's rarely the most useful thing... so
      name class is a tree of keys... /\<...\>
      psi/control/## might contain procs Init Destroy Move
      RegAlias( "psi/control/3", "psi/control/button"
      ); psi/control/button and psi/control/3 might reference the
      same routines
      psi/frame Init Destroy Move memlib Alloc Free
      network/tcp
      I guess name class trees are somewhat shallow at the moment
      not going beyond 1-3 layers
      names may eventually be registered and reference out of body
      services, even out of box...
      the values passed as returntype and parms/args need not be
      real genuine types, but do need to be consistant between the
      registrant and the requestor... this provides for full name
      dressing, return type and paramter type may both cause
      overridden functions to occur...                              */
_PROCREG_NAMESPACE
#ifndef REGISTRY_STRUCTURE_DEFINED
	// make these a CTEXTSTR to be compatible with name_class...
#ifdef __cplusplus
	// because of name mangling and stronger type casting
	// it becomes difficult to pass a tree_def_tag * as a CTEXTSTR classname
	// as valid as this is.
	typedef struct tree_def_tag const * PCLASSROOT;
#else
	typedef CTEXTSTR PCLASSROOT;
#endif
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#else
	typedef struct tree_def_tag const * PCLASSROOT;
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#endif
/* CheckClassRoot reads for a path of names, but does not create
   it if it does not exist.                                      */
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR class_name );
/* \Returns a PCLASSROOT of a specified path. The path may be
   either a PCLASSROOT or a text string indicating the path. the
   Ex versions allow passing a base PCLASSROOT path and an
   additional subpath to get. GetClassRoot will always create
   the path if it did not exist before, and will always result
   with a root.
   Remarks
   a CTEXTSTR (plain text string, probably wide character if
   compiled unicode) and a PCLASSROOT are always
   interchangeable. Though you may need a forced type cast, I
   have defined both CTEXTSTR and PCLASSROOT function overloads
   for c++ compiled code, and C isn't so unkind about the
   conversion. I think problem might lie that CTEXTSTR has a
   const qualifier and PCLASSROOT doesn't (but should).
   Example
   <code lang="c++">
   PCLASSROOT root = GetClassRoot( "psi/resource" );
   // returns the root of all resource names.
   </code>
   <code>
   PCLASSROOT root2 = GetClassRootEx( "psi/resource", "buttons" );
   </code>                                                         */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class );
#ifdef __cplusplus
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class );
#endif
/* Fills a string with the path name to the specified node */
PROCREG_PROC( int, GetClassPath )( TEXTSTR out, size_t len, PCLASSROOT root );
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename );
/* Get[First/Next]RegisteredName( "classname", &amp;data );
   these operations are not threadsafe and multiple thread
   accesses will cause mis-stepping
   These functions as passed the address of a POINTER. this
   POINTER is for the use of the browse routines and should is
   meaningless to he calling application.
   Parameters
   root :       The root to search from
   classname :  A sub\-path from the root to search from
   data :       the address of a pointer that keeps track of
                information about the search. (opaque to user)
   Example
   Usage:
   <code lang="c++">
   CTEXTSTR result;
   POINTER data = NULL;
   for( result = GetFirstRegisteredName( "some/class/path", &amp;data );
        \result;
        \result = GetNextRegisteredName( &amp;data ) )
   {
        // result is a string name of the current node.
        // can use that name and GetRegistered____ (function/int/value)
        if( NameHasBranches( &amp;data ) ) // for consitancy in syntax
        {
            // consider recursing through tree, name becomes a valid classname for GetFirstRegisteredName()
        }
   }
   </code>                                                                                                  */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data );
#ifdef __cplusplus
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
	PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data );
#endif
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data );
/* Steps to the next registered name being browsed. Is passed
   only the pointer to data. See GetFirstRegisteredName for
   usage.
   See Also
   <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, sack::app::registry::GetFirstRegisteredNameEx Function> */
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data );
/* When using GetFirstRegisteredName and GetNextRegisteredName
   to browse through names, this function is able to get the
   current PCLASSROOT of the current node, usually you end up
   with just the content of that registered name.
   \result with the current node ( useful for pulling registered
   subvalues like description, or file and line )
                                                                 */
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data );
#ifdef __cplusplus
//PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, POINTER *data );
//PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( POINTER *data );
#endif
// while doing a scan for registered procedures, allow applications to check for branches
//PROCREG_PROC( int, NameHasBranches )( POINTER *data );
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data );
// while doing a scan for registered procedures, allow applications to ignore aliases...
PROCREG_PROC( int, NameIsAlias )( PCLASSROOT *data );
/*
 * RegisterProcedureExx(
 *
 */
 // root name or PCLASSROOT of base path
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
 // an additional path on root
													  , CTEXTSTR name_class
 // the name of the value entry saved in the tree
													  , CTEXTSTR public_name
 // the text return type of this function - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR returntype
 // name of the library this symbol is in - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR library
 // actual C function name in library - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR name
 // preferably the raw argument string of types and no variable references "([type][,type]...)"
													  , CTEXTSTR args
 // file and line of the calling application.  May be no parameter in release mode.
													  DBG_PASS
													  );
/*
 * RegisterProcedureEx( root       // root path
 *                    , name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedureEx(root,nc,n,rtype,proc,args)  RegisterProcedureExx( (root),(nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * RegisterProcedure( name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedure(nc,n,rtype,proc,args)  RegisterProcedureExx( NULL, (nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * Branches on the tree may be aliased together to form a single branch
 *
 */
				// RegisterClassAlias( "psi/control/button", "psi/control/3" );
				// then the same set of values can be referenced both ways with
				// really only a single modified value.
/* parameters to RegisterClassAliasEx are the original name, and the new alias name for the origianl branch*/
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias );
/* <combine sack::app::registry::RegisterClassAliasEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                              */
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR newalias );
// root, return, public, args, address
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR parms
																  );
#define ReadRegisteredProcedure( root,rt,a) ((rt(CPROC*)a)ReadRegisteredProcedureEx(root,#rt,#a))
/* Gets a function that has been registered. */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
#define GetRegisteredProcedureExx(root,nc,rt,n,a) ((rt (CPROC*)a)GetRegisteredProcedureExxx(root,nc,#rt,n,#a))
#define GetRegisteredProcedure2(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
#define GetRegisteredProcedureNonCPROC(nc,rtype,name,args) (rtype (*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													, PCLASSROOT name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
													, PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
                                       , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#endif
//#define RegisterFunctionExx( r,nc,p,rt,proc,ar ) RegisterFunctionExx( r,nc,p,rt,proc,ar,TARGETNAME,NULL DBG_SRC )
//#define RegisterFunctionEx(r,nc,pn,rt,proc,args,lib,rn) RegisterFunctionExx(r,nc,pn,rt,proc,args,lib,rn DBG_SRC)
#define RegisterFunctionEx( root,proc,rt,pn,a) RegisterFunctionExx( root,NULL,pn,rt,(PROCEDURE)(proc),a,NULL,NULL DBG_SRC )
#define RegisterFunction( nc,proc,rt,pn,a) RegisterFunctionExx( (PCLASSROOT)NULL,nc,pn,rt,(PROCEDURE)(proc),a,TARGETNAME,NULL DBG_SRC )
#define SimpleRegisterMethod(r,proc,rt,name,args) RegisterFunctionExx(r,NULL,name,rt,(PROCEDURE)proc,args,NULL,NULL DBG_SRC )
#define GetRegisteredProcedure(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, #name, #args )
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value );
/* \ \
   Parameters
   root :        Root class to start searching from
   name_class :  An additional sub\-path to get the name from
   name :        the name within the path specified
   bIntVal :     a true/false whether to get the string or
                 integer value from the specified node.
   Returns
   A pointer to a string if bIntVal is not set. (NULL if there
   was no string).
   Otherwise will be an int shorter than or equal to the size of
   a pointer, which should be cast to an int if bIntVal is set,
   and there is a value registered there. Probably 0 if no
   value, so registered 0 value and no value is
   indistinguisable.                                             */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
PROCREG_PROC( int, RegisterIntValueEx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
#endif
/* This is like GetRegisteredValue, but takes the address of the
   type to return into instead of having to cast the final
   \result.
   if bIntValue, result should be passed as an (&amp;int)        */
PROCREG_PROC( int, GetRegisteredStaticValue )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name
															, CTEXTSTR *result
															, int bIntVal );
#define GetRegisteredStaticIntValue(r,nc,name,result) GetRegisteredStaticValue(r,nc,name,(CTEXTSTR*)result,TRUE )
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name );
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name );
#endif
typedef void (CPROC*OpenCloseNotification)( POINTER, uintptr_t );
#define PUBLIC_DATA( public, struct, open, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataType( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)close ); }
#define PUBLIC_DATA_EX( public, struct, open, update, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataTypeEx( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)update, (OpenCloseNotification)close ); }
#define GET_PUBLIC_DATA( public, type, instname )    (type*)CreateRegisteredDataType( "system/data/structs", public, instname )
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , OpenCloseNotification open
												 , OpenCloseNotification close );
/* Registers a structure as creatable in shared memory by name.
   So a single name of the structure can be used to retrieve a
   pointer to one created.
   Example
   \ \
   <code lang="c++">
   POINTER p = CreateRegisteredDataType( "My types", "my_registered_type", "my instance" );
   // p will result to a region of type 'my_registered_type' called 'my_instance'
   // if it did not exist, it will be created, otherwise the one existing is returned.
   </code>
   Parameters
   root :          optional root name (ex version uses this)
   classname :     path to the type
   name :          name of the type to create an instance of
   instancename :  a name for the instance created.                                         */
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename );
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
													, CTEXTSTR classname
													, CTEXTSTR name
													, uintptr_t size
													, OpenCloseNotification Open
													, OpenCloseNotification Close );
/* <combine sack::app::registry::CreateRegisteredDataType@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                */
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename );
/* Outputs through syslog a tree dump of all names registered. */
PROCREG_PROC( void, DumpRegisteredNames )( void );
/* Dumps through syslog all names registered from the specified
   root point. (instead of dumping the whole tree)              */
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root );
PROCREG_PROC( int, SaveTree )( void );
PROCREG_PROC( int, LoadTree )( void );
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
/* Releases an interface. When interfaces are registered, they
   register with a OnGetInterface and an OnDropInterface
   callback so that it may do additional work to cleanup from
   giving you a copy of the interface.
   Example
   <code lang="c++">
   POINTER p = GetInterface( "image" );
   DropInterface( p );
   </code>                                                     */
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_x );
PROCREG_PROC( POINTER, GetInterface_v4 )( CTEXTSTR pServiceName, LOGICAL ReadConfig, int quietFail DBG_PASS );
#define GetInterfaceV4( a, b )  GetInterface_v4( a, FALSE, b DBG_SRC )
/* \Returns the pointer to a registered interface. This is
   typically a structure that contains pointer to functions. Takes
   a text string to an interface. Interfaces are registered at a
   known location in the registry tree.                            */
PROCREG_PROC( POINTER, GetInterfaceDbg )( CTEXTSTR pServiceName DBG_PASS );
#define GetInterface(n) GetInterfaceDbg( n DBG_SRC )
#define GetRegisteredInterface(name) GetInterface(name)
PROCREG_PROC( LOGICAL, RegisterInterfaceEx )( CTEXTSTR name, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS );
//PROCREG_PROC( LOGICAL, RegisterInterface )(CTEXTSTR name, POINTER( CPROC*load )(void), void(CPROC*unload)(POINTER));
#define RegisterInterface(n,l,u) RegisterInterfaceEx( n,l,u DBG_SRC )
// unregister a function, should be smart and do full return type
// and parameters..... but for now this only references name, this indicates
// that this has not been properly(fully) extended, and should be layered
// in such a way as to allow this function work in it's minimal form.
PROCREG_PROC( int, ReleaseRegisteredFunctionEx )( PCLASSROOT root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													  );
#define ReleaseRegisteredFunction(nc,pn) ReleaseRegisteredFunctionEx(NULL,nc,pn)
/* This is a macro used to paste two symbols together. */
#define paste_(a,b) a##b
#define paste(a,b) paste_(a,b)
#ifdef __cplusplus
#define EXTRA_PRELOAD_SYMBOL _
#else
#define EXTRA_PRELOAD_SYMBOL
#endif
#define DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),EXTRA_PRELOAD_SYMBOL),line), SQL_PRELOAD_PRIORITY ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)
/* Dekware uses this macro.
     passes preload priority override.
	 so it can register new internal commands before initial macros are run.
*/
#define DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),EXTRA_PRELOAD_SYMBOL),line), priority ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
/* This macro indirection is to resolve inner macros like "" around text.  */
#define DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)
/*
    This method is used by PSI/Intershell.
	no description
*/
#define DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button##EXTRA_PRELOAD_SYMBOL,line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)
/*
#define _0_DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   static returntype _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes)	  _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
// this macro is used for ___DefineRegistryMethodP. Because this is used with complex names
// an extra define wrapper of priority_preload must be used to fully resolve paramters.
/*
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIOR_PRELOAD( paste(Register##name##Button##EXTRA_PRELOAD_SYMBOL,line), priority ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
*/
/* <combine sack::app::registry::SimpleRegisterMethod>
   General form to build a registered procedure. Used by simple
   macros to create PRELOAD'ed registered functions. This flavor
   requires the user to provide 'static' and a return type that
   matches the return type specified in the macro. This makes
   usage most C-like, and convenient to know what the return
   value of a function should be (if any).
   Parameters
   priority :    The preload priority to load at.
   task :        process level name registry. This would be
                 "Intershell" or "psi" or some other base prefix.
                 The prefix can contain a path longer than 1
                 level.
   name :        This is the function name to build. (Can be used
                 for link debugging sometimes)
   classtype :   class of the name being registered
   methodname :  name of the routine to register
   returntype :  the literal type of the return type of this
                 function (void, int, PStruct* )
   argtypes :    Argument signature of the routine in parenthesis
   line :        this is usually filled with __LINE__ so that the
                 same function name (name) will be different in
                 different files (even in the same file)
   Remarks
   This registers a routine at the specified preload priority.
   Registers under [task]/[classname]/methodname. The name of
   the registered routine from a C perspective is [name][line]. This
   function is not called directly, but will only be referenced
   from the registered name.
   Example
   See <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, GetFirstRegisteredNameEx> */
/*
#define _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _2___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes)	  _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
#define DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button##EXTRA_PRELOAD_SYMBOL,line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase "/" methodname, paste(name,line)	  , #returntype, subname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes)	  DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,__LINE__)
/* attempts to use dynamic linking functions to resolve passed
   global name if that fails, then a type is registered for this
   global, and an instance created, so that that instance may be
   reloaded again, otherwise the data in the main application is
   used... actually we should deprecate the dynamic loading
   part, and just register the type.
   SimpleRegisterAndCreateGlobal Simply registers the type as a
   global variable type. Allows creation of the global space
   later.
   Parameters
   name :         name of the pointer to global type to create.<p />text
                  string to register this created global as.
   ppGlobal :     address of the pointer to global memory.
   global_size :  size of the global area to create
   Example
   <code lang="c++">
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   PRELOAD( Init )
   {
       SimpleRegisterAndCreateGlobal( global );
   }
   </code>                                                               */
PROCREG_PROC( void, RegisterAndCreateGlobal )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name );
/* <combine sack::app::registry::RegisterAndCreateGlobal@POINTER *@uintptr_t@CTEXTSTR>
   \ \                                                                                   */
#define SimpleRegisterAndCreateGlobal( name )	 RegisterAndCreateGlobal( (POINTER*)&name, sizeof( *name ), #name )
/* Init routine is called, otherwise a 0 filled space is
   returned. Init routine is passed the pointer to the global
   and the size of the global block the global data block is
   zero initialized.
   Parameters
   ppGlobal :     Address of the pointer to the global region
   global_size :  size of the global region to create
   name :         name of the global region to register (so
                  future users get back the same data area)
   Init :         function to call to initialize the region when
                  created. (doesn't have to be a global. Could be
                  used to implement types that have class
                  constructors \- or not, since there's only one
                  instance of a global \- this is more for
                  singletons).
   Example
   <code>
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   </code>
   <code lang="c++">
   void __cdecl InitRegion( POINTER region, uintptr_t region_size )
   {
       // do something to initialize 'region'
   }
   PRELOAD( InitGlobal )
   {
       SimpleRegisterAndCreateGlobalWithInit( global, InitRegion );
   }
   </code>                                                          */
PROCREG_PROC( void, RegisterAndCreateGlobalWithInit )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Init)(POINTER,uintptr_t) );
/* <combine sack::app::registry::RegisterAndCreateGlobalWithInit@POINTER *@uintptr_t@CTEXTSTR@void __cdecl*InitPOINTER\,uintptr_t>
   \ \                                                                                                                              */
#define SimpleRegisterAndCreateGlobalWithInit( name,init )	 RegisterAndCreateGlobalWithInit( (POINTER*)&name, sizeof( *name ), #name, init )
/* a tree dump will result with dictionary names that may translate automatically. */
/* This has been exported as a courtesy for StrDup.
 * this routine MAY result with a translated string.
 * this routine MAY result with the same pointer.
 * this routine MAY need to be improved if MANY more strdups are replaced
 * Add a binary tree search index when large.
 * Add a transaltion tree index at the same time.
 */
PROCREG_PROC( CTEXTSTR, SaveNameConcatN )( CTEXTSTR name1, ... );
// no space stripping, saves literal text
PROCREG_PROC( CTEXTSTR, SaveText )( CTEXTSTR text );
PROCREG_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::app::registry;
#endif
#endif
#ifndef SQL_OPTIONS_DEFINED
#define SQL_OPTIONS_DEFINED
/* more documentation at end */
/*
 *
 *   Creator: Panther   #implemented in Dekware
 *   Modified by: Jim Buckeyne #ported to service SQL via proxy.
 *   Returned to sack by: Jim Buckeyne
 *                  # stripped application specific
 *                  # features, returned to SACK.
 *
 *  Provides a simple, intuitive interface to SQL.  Used sensibly,
 *  provides garbage collection of resources.
 *
 *  Commands without an ODBC specifier are the perferred method to
 *  use this interface.  This allows the internal system to maintain
 *  a primary and a redundant backup connection to provide transparent
 *  reliability to the application.
 *
 *  Provides some slick table creation routines
 *     - check for existance, and drop  (CTO_DROP)
 *     - check for existance, and match (CTO_MATCH)
 *     - check for existance, and merge (CTO_MERGE)
 *     - create table if not exist.
 *
 *  Latest additions provide ...RecordQuery... functions which
 *  result with a const CTEXTSTR * of results;  (ie, result[0] = (CTEXTSTR)result1 )
 *  also available are the column names from the query.
 *  I strongly recommend passing NULL always to the field names, and
 *  using sensible enumerators that follow the query definition.
 *
 *  (c)Freedom Collective (Jim Buckeyne 2000-2016)
 *
 */
#ifndef PSSQL_STUB_DEFINED
/* multiple inclusion protection symbol */
#define PSSQL_STUB_DEFINED
#if defined( SQLSTUB_SOURCE ) || defined( SQLPROXY_LIBRARY_SOURCE )
#define PSSQL_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSSQL_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _SQL_NAMESPACE   namespace sql {
#define _SQL_NAMESPACE_END   }
#define SQL_NAMESPACE   namespace sack { namespace sql {
#define SQL_NAMESPACE_END } }
#else
#define _SQL_NAMESPACE
#define _SQL_NAMESPACE_END
#define SQL_NAMESPACE
#define SQL_NAMESPACE_END
#endif
SACK_NAMESPACE
/* SQL access library. This provides a simple access to ODBC
   connections, and to sqlite. If no database is specified,
   there is an internal database that can be used. These methods
   on the PODBC connection are NOT thread safe. Multiple threads
   shall never use the same PODBC; they can use seperate PODBC
   connections. Under linux this links to unixODBC.
   DoSQLCommandf
   DoSQLRecordQueryf
   GetSQLRecord
   ConnectToDatabase
   DoSQLCommandf
   DoSQLRecordQueryf
   FetchSQLRecord
   There is a configuration file for the default SQL connection,
   this is kept in a file 'sql.config' which is processed with
   ProcessConfigurationFile(); If this file does not exist, it
   will be automatically created with default values.
   (Need to describe this sql.config file)                       */
_SQL_NAMESPACE
/* <combine PSSQL_PROC>
   \ \                    */
#define SQLPROXY_PROC PSSQL_PROC
/* This is the connection object that provides interface to the
   database. Can be NULL to specify the default connection
   interface. See namespace <link sack::sql, sql>.
   An ODBC connection handles commands as a stack. Each command
   is done as a temporary entry on the stack. A query is done as
   an entry on the stack, but the entry remains on the stack
   until the final result is retrieved or an early PopODBC is
   called.
   The structure of this is such that if a command is slow to a
   database, it would be possible to stack commands that are
   temporary and pending until the database connection is
   restored.
   Example
   <code lang="c++">
   int f( void )
   {
       // results from the query
       CTEXTSTR *results;
       // connect.
       PODBC odbc = ConnectToDatabase( "system_dsn_name" );
       // do a command, does a temporary entry on the stack, unless the database is slow
       SQLCommandf( odbc, "create temporary table my_test_table( ID int, value int )" );
       // start a new entry on the command stack.
       SQLRecordQueryf( odbc, NULL, &amp;results, NULL, "select 1+1" );
       // when this command is done, it is stacked on the query.
       SQLCommandf( odbc, "insert into my_test_table (value) values(%d)", 1234 );
       // at this point there is technically 2 entries on the command stack until the next
       // FetchSQLResult( odbc, &amp;results );
   }
	</code>                                                                                 */
#if !defined( __GNUC__ ) || !defined( SQLSTUB_SOURCE )
   // GCC doesn't identify this as exactly the same declaration
	typedef struct odbc_handle_tag *PODBC;
#endif
typedef struct odbc_handle_tag ODBC;
// recently added {} container braces for structure element
#define FIELDS(n) {( sizeof( n ) / sizeof( FIELD ) ), n}
/* a field definition can be a rename, and contain prior names,
   so that the rename can be tracked and migrated appropraitely.
   Unfortuntaly this sort of operation only affects this code,
   and not all auxiliary code.                                   */
#define MAX_PREVIOUS_FIELD_NAMES 4
/* <combine sack::sql::required_field_tag>
   <code lang="c++">
     FIELD fields[] = { { "ID", "int" }, ... };
   </code>                                            */
typedef struct required_field_tag
{
	/* This is the name of the column described in this table. */
	CTEXTSTR name;
	/* pointer to a string describing the type of this column.  */
	CTEXTSTR type;
	/* extra information about the field... grab all addtional
	   information like 'NOT NULL' "default 'zxa'" to describe a
	   field. Sometimes target databases don't understand extra
	   \parameters, and these can be translated as required or
	   ignored.                                                  */
	CTEXTSTR extra;
	// if you have renamed this column more than 1
	// times - you really need to stop messing around
	// and get a life.
	CTEXTSTR previous_names[MAX_PREVIOUS_FIELD_NAMES];
} FIELD, *PFIELD;
#if !defined( _MSC_VER ) || ( _MSC_VER >= 800 )
/* A macro to append a NULL automatically to a list of strings.
   Example
   <code lang="c++">
   CTEXTSTR strings[] = { KEY_COLUMNS( "one", "two", "three" ) };
   </code>
   strings will be set to 4 elements with the 3 strings listed
   in KEY_COLUMNS plus a NULL string.                             */
#define KEY_COLUMNS(...) { __VA_ARGS__, NULL }
#endif
/* sets the count and the array of a statically declared
   required_table_tag.
   Example
   <code lang="c++">
   </code>
   <code>
   FIELD fields[5];
   DB_KEY_DEF keys[3];
   TABLE table = { "table_name", FIELDS( fields ), TABLE_KEYS( keys ) };
   </code>
   This creates a static table definition with the name
   "table_name" and 5 fields with 3 keys. fields[] = { } is
   usally the declartion. Also DB_KEY_DEF keys[] = { ... }; for
   keys.
                                                                         */
#define TABLE_KEYS(n) {( sizeof( n ) / sizeof( DB_KEY_DEF ) ), n}
/* maximum columns that can be specified for a multicolumn index
   in required_key_def.                                          */
#define MAX_KEY_COLUMNS 8
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  DB_KEY_DEF;
enum uniqueResolutions {
  // no on conflict specification.
	UNIQRES_UNSET = 0,
	UNIQRES_REPLACE,
	UNIQRES_IGNORE,
	UNIQRES_FAIL,
	UNIQRES_ABORT,
	UNIQRES_ROLLBACK
};
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  *PDB_KEY_DEF;
struct required_key_def
{
	/* Flags describing attributes of this key */
	/* <combine sack::sql::required_key_def::flags@1>
	   \ \                                            */
	struct {
		/* this defines the primary key for the table */
		BIT_FIELD bPrimary : 1;
		/* the key is meant to be unique. */
		BIT_FIELD bUnique : 1;
		BIT_FIELD uniqueResolution : 3;
	} flags;
	/* Name of the key column. Can be NULL if primary. */
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
#ifdef __cplusplus
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = NULL; }
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = 0; }
	/* Just another required_key_def constructor. */
	required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2, CTEXTSTR colname3 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = colname3; colnames[3] = 0; }
#else
#define required_key_def( a,b,c,...) { {a,b}, c, {__VA_ARGS__} }
#endif
};
 /* Describes a key column of a table.
      <code lang="c++">
      DB_KEY_DEF keys[] = { { "lockey", KEY_COLUMNS("hall_id","charity_id") } };
      </code>                                                                    */
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  DB_CONSTRAINT_DEF;
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  *PDB_CONSTRAINT_DEF;
struct required_constraint_def
{
	struct {
		BIT_FIELD cascade_on_delete : 1;
		BIT_FIELD cascade_on_update : 1;
		BIT_FIELD restrict_on_delete : 1;
		BIT_FIELD restrict_on_update : 1;
		BIT_FIELD noaction_on_delete : 1;
		BIT_FIELD noaction_on_update : 1;
		BIT_FIELD setnull_on_delete : 1;
		BIT_FIELD setnull_on_update : 1;
		BIT_FIELD setdefault_on_delete : 1;
		BIT_FIELD setdefault_on_update : 1;
		BIT_FIELD foreign_key : 1;
	} flags;
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
	CTEXTSTR references;
 // uhm up to 5 colnames...
	CTEXTSTR foriegn_colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
 // Describes a constraint clause
};
/* Example
   By default, CreateTable( CTEXTSTR tablename, CTEXTSTR
   filename ) which reads a 'create table' statement from a file
   to create a table, this now parses the create table structure
   into an internal structure TABLE which has FIELDs and
   DB_KEY_DEFs. This structure is now passed to CheckODBCTable
   which is able to compare the structure with the table
   definition available from the database via DESCRIBE TABLE,
   and then update the table in the database to match the TABLE
   definition.
   One can use the table structure to define tables instead of
   maintaining external files... and without having to create a
   temporary external file which could then contain a create
   table statement to create the table.
   <code>
   // declare some fields...
   FIELD some_table_field_array_name[] = { { "field one", "int", NULL }
   , { "field two", "varchar(100)", NULL }
   , { "ID field", "int", "auto_increment" }
   , { "some other field", "int", "NOT NULL default '8'" }
   };
   // define some keys...
   DB_KEY_DEF some_table_key_array_name[] = { { .flags = { .bPrimary = 1 }, NULL, {"ID Field"} }
   , { {0}, "namekey", { "field two", NULL } }
   };
   </code>
   // the structure for DB_KEY_DEF takes an array of column
   names used to define the key, there should be a NULL to end
   the list. The value after the array of field names is called
   'null' which should always be set to NULL. If these are
   declared in global data space, then any unset value will be
   initialized to zero.
   <code>
   TABLE some_table_var_name = { "table name", FIELDS( some_table_field_array_name ), TABLE_KEYS( some_table_key_array_name ), 1 );
    LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
        PODBC odbc - may be left NULL to use the default database connection.
        PTABLE table - a pointer to a TABLE structure which has been initialized.
        uint32_t options - zero or more of  the following symbols or'ed together.
                   \#define CTO_MATCH 4  // attempt to figure out alter statements to drop or add columns to exact match definition
                   \#define CTO_MERGE 8  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
   </code>
   Then some routine later
   <code>
   {
      ...
      CheckODBCTable( NULL, &amp;some_table_var_name, CTO_MERGE );
      ..
   }
   </code>
   * ---------------------------------------------------------- *
   alternatively tables may be checked and updated using the
   following code, given an internal constant text string that
   is the create table statement, this may be parsed into a
   PTABLE structure which the resulting table can be used in
   CheckODBCTable();
   <code>
   static CTEXTSTR create_player_info = "CREATE TABLE `players_info` ("
         "  `player_id` int(11) NOT NULL auto_increment,           "
         "  PRIMARY KEY  (`player_id`),                            "
         ")                               ";
   PTABLE table = GetFieldsInSQL( create_player_info, FALSE );
   CheckODBCTable( NULL, table, CTO_MERGE );
   DestroySQLTable( table );
   </code>                                                                                                                          */
struct required_table_tag
{
	/* This is the name of the table. */
	CTEXTSTR name;
	/* describes the columns (fields) in a table. */
	struct pssql_table_fields {
		/* number of fields in the array pointed at by field. */
		int count;
		/* pointer to an array of FIELD. */
		PFIELD field;
	} fields;
	/* Describes the keys on the table.  */
	/* <combine sack::sql::required_table_tag::keys@1>
	   \ \                                             */
	struct pssql_table_key {
		/* number of keys pointed at by key. */
		int count;
      /* pointer to an array of DB_REQ_KEY. */
      PDB_KEY_DEF key;
	} keys;
	struct pssql_table_constraint {
		int count;
		PDB_CONSTRAINT_DEF constraint;
	} constraints;
	/* <combine sack::sql::required_table_tag::flags@1>
	   \ \                                              */
	/* flags controlling the table. */
		struct pssql_table_flags {
         // set this if defined dynamically (from getfields in SQL)
		BIT_FIELD bDynamic : 1;
		/* This is a table that is allocated in memory, static table
		   definitions should leave this 0.                          */
		BIT_FIELD bTemporary : 1;
		/* Issue the create statement always, but include 'if not
		   exists'. Don't try and compare the table structure.    */
		BIT_FIELD bIfNotExist : 1;
	} flags;
   /* name of another table that already exists. Creates this table
      using that table's description.                               */
   CTEXTSTR create_like_table_name;
   /* name of the database that contains this table. */
   CTEXTSTR database;
   /* an additional field that can specify the database storage
      engine to use. (Hmm maybe use this to specify sqlite target?) */
   CTEXTSTR type;
   /* This is an additional field to add as a description to the
      database if supported by the target database.              */
   CTEXTSTR comment;
};
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag TABLE;
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag *PTABLE;
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTableEx)( PODBC odbc, PTABLE table, uint32_t options DBG_PASS );
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTable)( PODBC odbc, PTABLE table, uint32_t options );
/* <combine sack::sql::CheckODBCTableEx@PODBC@PTABLE@uint32_t options>
   \ \                                                            */
#define CheckODBCTable(odbc,t,opt) CheckODBCTableEx(odbc,t,opt DBG_SRC )
/* Enable or disable logging SQL to the sql.log file and to the
   application's log.
   Parameters
   odbc :      connection to disable logging on
   bDisable :  if TRUE disables logging, else restores logging. */
PSSQL_PROC( void, SetSQLLoggingDisable )( PODBC odbc, LOGICAL bDisable );
#ifndef SQLPROXY_INCLUDE
// result is FALSE on error
// result is TRUE on success
PSSQL_PROC( int, DoSQLCommandEx )( CTEXTSTR command DBG_PASS);
#endif
/* <combine sack::sql::DoSQLCommandEx@CTEXTSTR command>
   \ \                                                  */
#define DoSQLCommand(c) DoSQLCommandEx(c DBG_SRC )
/* Generate a commit for any outstanding transactions. Commit
   syntax is variable depending on the connection. Connections
   also have the feature to auto generate begin transaction, and
   flush after a period of idle.
   Parameters
   odbc :  connection to database to commit                      */
PSSQL_PROC( void, SQLCommit )( PODBC odbc );
/* generates the begin transaction for a commection.
   Parameters
   odbc :  connection to database to start a transaction        */
PSSQL_PROC( void, SQLBeginTransact )( PODBC odbc );
// parameters to this are pairs of "name", type, "value"
//  type == 0 - value is text, do not quote
//  type == 1 - value is text, add quotes appropriate for database
//  type == 2 - value is an integer, do not quote
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
#ifndef SQLPROXY_INCLUDE
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnection )( PODBC );
#endif
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnectionEx )( PODBC DBG_PASS );
/* <combine sack::sql::OpenSQLConnectionEx@PODBC>
   \ \                                            */
#define OpenSQLConnect(o) OpenSQLConnectionEx( o DBG_SRC )
// should pass to this a &(CTEXTSTR) which starts as NULL for result.
// result is FALSE on error
// result is TRUE on success, and **result is updated to
// contain the resulting data.
PSSQL_PROC( int, DoSQLQueryEx )( CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::DoSQLQueryEx@CTEXTSTR@CTEXTSTR *result>
   \ \                                                         */
#define DoSQLQuery(q,r) DoSQLQueryEx( q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
#define DoSQLRecordQuery(q,r,c,f) SQLRecordQueryEx( NULL,q,r,c,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define DoSQLQueryRecord(q,r,c)   DoSQLRecordQuery(q,r,c,NULL)
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLQueryRecord(o,q,r,c)   SQLRecordQuery(o,q,r,c,NULL)
/* <combine sack::sql::GetSQLRecord@CTEXTSTR **>
   \ \                                           */
#define GetSQLResultRecord(r,c)   GetSQLRecord(c)
/* <combine sack::sql::FetchSQLResult@PODBC@CTEXTSTR *>
   \ \                                                  */
PSSQL_PROC( int, GetSQLResult )( CTEXTSTR *result );
/* <combine sack::sql::FetchSQLRecord@PODBC@CTEXTSTR **>
   \ \                                                   */
PSSQL_PROC( int, GetSQLRecord )( CTEXTSTR **result );
/* Gets the last result on the default ODBC connection.
   Parameters
   result\ :  address of a string pointer to get set to the error
              string.
   Example
   <code>
   {
      CTEXTSTR error;
      GetSQLError( &amp;error );
      printf( "Error: %s", error );
   }
   </code>                                                        */
PSSQL_PROC( int, GetSQLError )( CTEXTSTR *result );
/* This is a test command that tests to see if the default
   database connection is able to work.                    */
PSSQL_PROC( int, IsSQLReady )( void );
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
PSSQL_PROC( int, PushSQLQuery )( void );
/* <combine sack::sql::PopODBCEx@PODBC>
   \ \                                  */
PSSQL_PROC( void, PopODBC )( void );
#ifndef SQLPROXY_INCLUDE
/* Clear the top non temporary sql statement from the PODBC
   stack.
   Parameters
   odbc :  connection to remove the statement from.
   Remarks
   A SQLCommand is temporary, a SQLQuery or a PushODBC is not. Pop
   MAY be used to clear a query early, but it is recommended to
   read to the end of it instead.                                  */
PSSQL_PROC( void, PopODBCExx )( PODBC, LOGICAL DBG_PASS );
PSSQL_PROC( void, PopODBCEx )( PODBC );
/* <combine sack::sql::PopODBCExx@PODBC@LOGICAL>
   \ \                                           */
#define PopODBCEx(o) PopODBCExx(o,FALSE DBG_SRC)
/* <combine sack::sql::PopODBCEx>
   \ \                            */
#define PopODBC() PopODBCExx(NULL,FALSE DBG_SRC)
#endif
/* This terminates a query on the PODBC stack. (It was mentioned
   in pop odbc that it could be used to terminate a query, but
   that will log that a pop is being done without a push. This
   is the proper way to prematurely end a query.)
   Parameters
   odbc :  connection to end a query on.                         */
PSSQL_PROC( void, SQLEndQuery )( PODBC odbc );
// release any open queries on the database... all result
// sets are now invalid... uhmm what about things like fields?
// could be messy...
PSSQL_PROC( void, ReleaseODBC )( PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
#ifndef SQLPROXY_INCLUDE
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   date :    string to parse
   year :    pointer to an int that will receive the year portion
             of the date
   month :   pointer to an int that will receive the month
             portion of the date
   day :     pointer to an int that will receive the day portion
             of the date
   hour :    pointer to an int that will receive the hours
             portion of the date
   minute :  pointer to an int that will receive the minutes
             portion of the date
   second :  pointer to an int that will receive the second
             portion of the date
   msec :    pointer to an int that will receive the milli\-second
             portion of the date
   nsec :    pointer to an int that will receive the nano second portion
             of the date                                                 */
PSSQL_PROC( void, ConvertSQLDateEx )( CTEXTSTR date
												  , int *year, int *month, int *day
												  , int *hour, int *minute, int *second
												  , int *msec, int32_t *nsec
												  , int *zone_hr, int *zone_mn
												  );
#endif
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDate( date, y,m,d) ConvertSQLDateEx( date,y,m,d,NULL,NULL,NULL,NULL,NULL)
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDateTime( date, y,mo,d,h,mn,s) ConvertSQLDateEx( date,y,mo,d,h,mn,s,NULL,NULL)
//------------------------------
// this set of functions will auto create a suitable name table
// providing table_name_id and table_name_name as the columns to query by standard
// previous defaults where "id" and "name" which results in inability to use natural join
//
PSSQL_PROC( INDEX, FetchSQLNameID )( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name );
/* A specialized function which takes a name, looks in a SQL
   table on the default database connection for in column
   'name', and returns the value in the 'ID' column. This
   function may create a table with the required fields. This
   table is very bad, if you have 3 tables all with the same
   'name' column reverse engineering and natural join clauses
   fail.
   Parameters
   table_name :  name of the table to get the name's ID from.
   name :        name to lookup its ID for.
   Returns
   the ID of the name or INVALID_INDEX if not found.          */
PSSQL_PROC( INDEX, GetSQLNameID )( CTEXTSTR table_name, CTEXTSTR name );
/* Still a bad function to use.... just don't.
   Parameters
   odbc :        _nt_
   table_name :  _nt_
   iName :       _nt_                          */
PSSQL_PROC( CTEXTSTR, FetchSQLName )( PODBC odbc, CTEXTSTR table_name, INDEX iName );
/* A specialized function which takes an ID, looks in a SQL
   table on the default database connection for in column 'ID',
   and returns the value in the 'name' column. This function may
   create a table with the required fields. This table is very
   bad, if you have 3 tables all with the same 'name' column
   reverse engineering and natural join clauses fail.
   Parameters
   table_name :  name of the database table to read from
   iName :       ID of the name to get                           */
PSSQL_PROC( CTEXTSTR, GetSQLName )( CTEXTSTR table_name, INDEX iName );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \
   Note
   If database connection is not specified or is NULL, uses the
   default SQL connection.                                                                         */
PSSQL_PROC( INDEX, ReadNameTableExEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTableExx( name,table,col,namecol,bCreate) ReadNameTableExEx( name,table,col,namecol,bCreate DBG_SRC )
//column name if NOT specified will be 'ID'
PSSQL_PROC( INDEX, ReadNameTableEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTable(n,t,c) ReadNameTableExEx( n,t,c, "name",TRUE DBG_SRC )
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
PSSQL_PROC( int, ReadFromNameTableEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS);
/* TRUE if name in result... again if !colname colname = 'ID'
   Parameters
   odbc :       connection to use
   id :         ID of the name to read
   table :      table to read from
   id_column :  name of the column that contains the ID
   colname :    name of the column that is where the name is
   result\ :    pointer to a CTEXTSTR which will be filled with
                the name in the table                           */
PSSQL_PROC( int, ReadFromNameTableExEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_column, CTEXTSTR colname, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
#define ReadFromNameTableExx(id,t,ic,nc,r) ReadFromNameTableExEx(id,t,ic,nc,r DBG_SRC )
/* <combine sack::sql::ReadFromNameTableEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                        */
#define ReadFromNameTable(id,t,c,r) ReadFromNameTableEx(id,t,c,"name",r DBG_SRC )
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( TEXTSTR, SQLReadNameTableKeyExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( INDEX, SQLReadNameTableExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTableExx( odbc,name,table,col,namecol,bCreate) SQLReadNameTableExEx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTable(o,n,t,c) SQLReadNameTableExEx( o,n,t,c,"name",TRUE DBG_SRC )
/* Reads a table that's assumed to be a primary key ID and a
   name sort of dictionary table. This also maintains an
   \internal cache of names queried, since it is assumed words
   in a dictionary don't move or change.
   Parameters
   odbc :      odbc connection to use
   name :      name to get the index of
   table :     table to get the index from
   col :       column name of the ID columns (macros allow this to
               be defaulted)
   namecol :   column name of the name column (macros allow this to
               be defaulted)
   bCreate :   If the name doesn't exist, setting this to TRUE will
               insert the new name, else return will be
               INVALID_INDEX.
   bQuote :    Indicates if the name should be quoted (else use no
               quotes)
   DBG_PASS :  _nt_                                                 */
PSSQL_PROC( INDEX, GetNameIndexExtended)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate, int bQuote DBG_PASS );
/* <combine sack::sql::GetNameIndexExtended@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int@int bQuote>
   \ \                                                                                                */
PSSQL_PROC( INDEX, GetNameIndexExx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndexEx( odbc,name,table,col,namecol,bCreate) GetNameIndexExx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndex(o,n,t,c) GetNameIndexExx( o,n,t,c,"name",TRUE DBG_SRC )
// table and col are not used if a MySQL backend is used...
// they are needed to get the last ID from a postgresql backend.
PSSQL_PROC( INDEX, GetLastInsertIDEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertID(t,c) GetLastInsertIDEx(t,c DBG_SRC )
/* Gets the ID of the primary key from the prior insert. This
   value can be used in subsequent inserts to relate detail
   records to a master.
   Parameters
   odbc :    database connection
   table :   if NULL, just get's the connection's last insert
             into whatever table. PostgreSQL requires a table
             name and column name to get the last insert for. So,
             proper portability for certain databases may use
             this parameter.
   column :  if NULL, just get's the connection's last insert id
             from the auto increment primary key. PostgreSQL
             requires a table name and column name to get the
             last insert for. So, proper portability for certain
             databases may use this parameter.
   Returns
   a 64 bit row identifier.                                       */
PSSQL_PROC( INDEX, FetchLastInsertIDEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertID(o,t,c) FetchLastInsertIDEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertKey(o,t,c) FetchLastInsertKeyEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
PSSQL_PROC( CTEXTSTR, FetchLastInsertKeyEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
PSSQL_PROC( CTEXTSTR, GetLastInsertKeyEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertKey(t,c) GetLastInsertKeyEx(t,c DBG_SRC )
// CreateTable Options (CTO_)
enum CreateTableOptions {
   // drop old table before create.
 CTO_DROP  = 1,
  // attempt to figure out alter statements to drop or add columns to exact match definition
 CTO_MATCH = 4,
  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
 CTO_MERGE = 8,
 // log changes to "changes.sql"
		CTO_LOG_CHANGES = 16
};
/* \ \
   Parameters
   odbc :          database connection to check table in
   filename :      name of file containing sql CREATE TABLE
                   statements.
   templatename :  name of the table specified by the CREATE
                   TABLE statement.
   tablename :     table name to use when actually creating this.
                   May be different from template table name.
   options :       Options from CreateTableOptions.               */
PSSQL_PROC( int, SQLCreateTableEx )(PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::SQLCreateTableEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                                        */
#define SQLCreateTable( odbc, file, table ) SQLCreateTableEx(odbc,file,table,table,0)
/* Creates a table in a database by reading an external file
   containing the table definition. It can also perform
   iterative updates to table structure if the template
   definition adds or deletes columns.
   Parameters
   filename :      filename to read the template from
   templatename :  name of the table in the create table template
                   statement.
   tablename :     the name of the table to create (may be
                   different than template)
   options :       Options from CreateTableOptions.
   Returns
   TRUE if success.
   FALSE if failure. (No further information)                     */
PSSQL_PROC( int, CreateTableEx )( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::CreateTableEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                               */
#define CreateTable( file, table ) CreateTableEx(file,table,table,0)
// results in a static buffer with escapes filled in for characterws
// which would otherwise conflict with string punctuators.
PSSQL_PROC( TEXTSTR ,EscapeStringEx )( CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeString(s) EscapeStringEx( s DBG_SRC )
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeStringOpt(s,q) EscapeSQLBinaryExx( NULL,s,StrLen(s),NULL, q DBG_SRC )
/* \ \
   Parameters
   odbc :  connection to escape the string appropriately for. Different
           database engines require different string escapes.
   name :  string to escape
   Returns
   a TEXTSTR that is the content of the string passed properly
   escaped.
   it is appropriate to Release( result );
   Example
   This is difficult to describe coorectly, since in C, you have
   to do escaping on the parameters anyhow....
   <code lang="c++">
   {
       TEXTSTR result = EscapeSQLString( "\\"test \\'escape\\'" );
       printf( "original : %s\\n"
               "result   : %s\\n"
             , "\\"test \\'escape\\'"
             , \result );
   }
   </code>
   \Output
   <code lang="c++">
   original : "test 'escape'
   \result   : \\"test \\'escape\\'
   </code>                                                              */
PSSQL_PROC( TEXTCHAR *,EscapeSQLStringEx )( PODBC odbc, CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeSQLStringEx@PODBC@CTEXTSTR name>
   \ \                                                        */
#define EscapeSQLString(odbc, s) EscapeSQLStringEx( odbc, s DBG_SRC )
// the following functions return an allcoated buffer which the application must Release()
PSSQL_PROC( TEXTSTR ,EscapeBinaryEx )( CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinary(b,bl) EscapeBinaryEx(b,bl DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinaryOpt(b,bl,q) EscapeSQLBinaryExx(NULL,b,bl,NULL,q DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
PSSQL_PROC( TEXTSTR,EscapeSQLBinaryExx )( PODBC odbc, CTEXTSTR blob, size_t bloblen, size_t *resultLen, LOGICAL bQuote DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
//PSSQL_PROC( TEXTSTR,EscapeSQLBinaryEx )( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinary(odbc,blob,len) EscapeSQLBinaryExx( odbc,blob,len, NULL, FALSE DBG_SRC )
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinaryOpt(odbc,blob,len,q) EscapeSQLBinaryExx( odbc,blob,len,NULL,q DBG_SRC )
#define EscapeSQLBinaryLen(odbc,blob,len,resLen,q) EscapeSQLBinaryExx( odbc,blob,len,resLen, q DBG_SRC )
/* Remove escape sequences which are inserted into a text
   string. (for things like quotes and binary characters?)
   Parameters
   name :  string to remove string escapes from
   Returns
   a copy of the string without quotes. This result should be
   freed with Release when user is done with it.              */
PSSQL_PROC( TEXTSTR ,RevertEscapeString )( CTEXTSTR name );
/* Remove escape sequences which are inserted into a binary
   string.
   Parameters
   blob :     pointer to data to remove binary escape sequences
              from
   bloblen :  length of the data block to handle
   Returns
   a pointer to the string without escapes. (Even though it says
   binary, it's still to and from text?) This result should be
   freed with Release when user is done with it.                 */
PSSQL_PROC( TEXTSTR ,RevertEscapeBinary )( CTEXTSTR blob, size_t *bloblen );
/* Parse a Blob string stored as hex... that is text character
   0-9 and A-F.
   Parameters
   blob :    pointer to the string containing the blob string
   buffer :  target buffer for data
   buflen :  length of target buffer                           */
PSSQL_PROC( TEXTSTR , DeblobifyString )( CTEXTSTR blob, TEXTSTR buffer, size_t buflen );
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   timestring :     string to parse
   endtimestring :  pointer to a pointer to a string to receive
                    the position of the character after the
                    timestring.
   year :           pointer to an int that will receive the year
                    portion of the date
   month :          pointer to an int that will receive the month
                    portion of the date
   day :            pointer to an int that will receive the day
                    portion of the date
   hour :           pointer to an int that will receive the hours
                    portion of the date
   minute :         pointer to an int that will receive the
                    minutes portion of the date
   second :         pointer to an int that will receive the
                    second portion of the date
   Returns
   A true/false status whether the string passed was a valid
   time string (?).                                               */
PSSQL_PROC( int, ConvertDBTimeString )( CTEXTSTR timestring
                                      , CTEXTSTR *endtimestring
                                      , int *pyr, int *pmo, int *pdy
                                      , int *phr, int *pmn, int *psc );
#ifndef SQLPROXY_INCLUDE
/* Issue a command to a SQL database. Things like Update and
   Insert are commands.
   Parameters
   odbc :     database connection to perform the command on. If
              NULL uses the default global connection.
   command :  text string to send to the database to execute.
   Returns
   TRUE if the statement succeeds.
   FALSE if the statement fails. See FetchSQLError.             */
PSSQL_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS);
#endif
PSSQL_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS);
/* <combine sack::sql::SQLCommandEx@PODBC@CTEXTSTR command>
   \ \                                                      */
#define SQLCommand(o,c) SQLCommandEx(o,c DBG_SRC )
#define SQLCommandLen(o,c,len) SQLCommandExx(o,c,len DBG_SRC )
   /* Begin collecting insert statements for batch output.
   Parameters
   odbc :  database connection to start collecting inserts for */
PSSQL_PROC( int, SQLInsertBegin )( PODBC odbc );
/* Generate a SQL insert statement from a variable parameter
   list.
   Parameters
   odbc :   connection to generate an insert on
   table :  table to insert into
   args :   a list of fields.
   Remarks
   args each column is a set of 3 parameters; the first
   parameter is the name of the column to insert into, the
   second is a value 0 or 1 whether to quote the value or not,
   and a string pointer.
   Inserts may be batched together and flushed as a whole to the
   database connection.                                          */
PSSQL_PROC( int, vSQLInsert )( PODBC odbc, CTEXTSTR table, va_list args );
/* Generate an insert to the database. Inserts to a single table
   can be cached internally and flushed.
   Parameters
   odbc :   database connection to use
   table :  name of table to insert into
   ... :    sets of column paramters.                            */
PSSQL_PROC( int, SQLInsert )( PODBC odbc, CTEXTSTR table, ... );
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
/* Flushes all cached inserts collected on a database
   connection.
   Parameters
   odbc :  database connection to flush inserts       */
PSSQL_PROC( int, SQLInsertFlush )( PODBC odbc );
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   query :    the string query to do
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code lang="c++">
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQuery( odbc, "select 1,2,3", &amp;result );
   printf( "result : %s" );
   </code>
   \Output
   <code lang="c++">
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQuery                                                */
PSSQL_PROC( int, SQLQueryEx )( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::SQLQueryEx@PODBC@CTEXTSTR@CTEXTSTR *result>
   \ \                                                             */
#define SQLQuery(o,q,r) SQLQueryEx( o,q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
PSSQL_PROC( int, SQLRecordQueryEx )( PODBC odbc
                                   , CTEXTSTR query
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , CTEXTSTR **fields DBG_PASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   PDATALIST* :  pointer to datalist pointer which will contain struct jsox_value_container.
			 for each result in this list until VALUE_UNDEFINED is used.
		.name is the field name (constant)
		.string is the text, value_type is the value type (so numbers can stay numbers)
	pdlParams : parameters to bind to the query.  (struct json_value_container types)
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_js )( PODBC odbc
	, CTEXTSTR query
	, size_t queryLen
	, PDATALIST *pdlResults
	, PDATALIST pdlParams
	DBG_PASS );
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   resultLengths : pointer to a size_t* that will contain an array of
              lengths of the result values.
   fields :   address of a pointer to strings which will get the
              field names
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_v4 )( PODBC odbc
                                   , CTEXTSTR query
                                   , size_t queryLength
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , size_t **resultLengths
                                   , CTEXTSTR **fields
                                   , PDATALIST pdlParameters
                                   DBG_PASS);
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQuery(o,q,prn,r,f) SQLRecordQueryEx( o,q,prn,r,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryExx@PODBC@CTEXTSTR@size_t@int *@CTEXTSTR **@size_t *@CTEXTSTR **fields>
   \ \                                                                                      */
#if defined _DEBUG || defined _DEBUG_INFO
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f, __FILE__,__LINE__ )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields ,file,line )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL ,file,line )
#else
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f  )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL )
#endif
   /* Gets the next result from a query.
   Parameters
   odbc :     database connection that the query was executed on
   result\ :  address of the result variable.
   Example
   See SQLRecordQueryf.                                          */
PSSQL_PROC( int, FetchSQLResult )( PODBC, CTEXTSTR *result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
              \internal static connection.
   result\ :  address of a CTEXTSTR *; to set to an array of
              CTEXTSTR results.
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecord )( PODBC, CTEXTSTR **result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
			  \internal static connection.
   result\ :  (unchanged; is same list as original)
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecordJS )(PODBC odbc, PDATALIST *ppdlRecord);
/* Gets the last result on the specified ODBC connection.
   Parameters
   odbc :     connection to get the last error of
   result\ :  address of a string pointer to receive the error
              \result.
   Example
   <code lang="c++">
   {
      CTEXTSTR error;
      FetchSQLError( NULL, &amp;error );
   </code>
   <code>
      printf( "Error: %s", error );
   </code>
   <code lang="c++">
   }
   </code>                                                     */
PSSQL_PROC( int, FetchSQLError )( PODBC, CTEXTSTR *result );
#ifndef SQLPROXY_INCLUDE
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpenEx )( PODBC DBG_PASS );
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpen )( PODBC );
/* <combine sack::sql::IsSQLOpenEx@PODBC>
   \ \                                    */
#define IsSQLOpen(odbc) IsSQLOpenEx(odbc DBG_SRC )
/* An PODBC connection handles commands as a stack, this saves
   the current query state (that you want to still get results
   from), so you can start a new query within the outer query.
   Parameters
   odbc :  database connection to save the current query state. */
PSSQL_PROC( int, PushSQLQueryExEx )(PODBC DBG_PASS);
PSSQL_PROC( int, PushSQLQueryEx )(PODBC);
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
// no application support for username/password, sorry, trust thy odbc layer, please
PSSQL_PROC( PODBC, ConnectToDatabase )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBC )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBCEx )( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass );
PSSQL_PROC( void, SQLDropODBC )( PODBC odbc );
PSSQL_PROC( void, SQLDropAndCloseODBC )( CTEXTSTR dsn );
#endif
// default parameter to require is the global flag RequireConnection from sql.config....
PSSQL_PROC( PODBC, ConnectToDatabaseExx )( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS );
PSSQL_PROC( PODBC, ConnectToDatabaseEx )( CTEXTSTR DSN, LOGICAL bRequireConnection );
#define ConnectToDatabaseEx( dsn, required ) ConnectToDatabaseExx( dsn, required DBG_SRC )
#define ConnectToDatabase( dsn ) ConnectToDatabaseExx( dsn, FALSE DBG_SRC )
/* Close a database connection. Releases all resources
   associated with the odbc connection.
   Parameters
   odbc :  connection to database to close. Should not be NULL.  */
PSSQL_PROC( void, CloseDatabase)(PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
/* ODBC only (sqlite no support?). Gets the types of data that
   the ODBC connection supports.
   Parameters
   odbc :  database connection to get the types from.
   Example
   <code>
   PODBC odbc = NULL; // or do a ConnectToDatabsae
   CTEXTSTR result; // the singular line result
   if( FetchSQLTypes(odbc) )
       while( FetchSQLResult( &amp;result ) &amp;&amp; result )
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>
   <code lang="c++">
   if( GetSQLTypes() )
       while( GetSQLResult( &amp;result ) &amp;&amp; result )
   </code>
   <code>
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>                                                      */
PSSQL_PROC( int, FetchSQLTypes )( PODBC );
#define PSSQL_VARARG_PROC(a,b,c)  PSSQL_PROC(a,b)c; typedef a(CPROC * __f_##b)c; PSSQL_PROC( __f_##b, __##b )(DBG_VOIDPASS)
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_VARARG_PROC( int, DoSQLRecordQueryf ,( int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define DoSQLRecordQueryf   (__DoSQLRecordQueryf( DBG_VOIDSRC ))
/* <combine sack::sql::SQLQueryf@PODBC@CTEXTSTR *@CTEXTSTR@...>
   \ \                                                          */
PSSQL_VARARG_PROC( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define DoSQLQueryf   (__DoSQLQueryf( DBG_VOIDSRC ))
/* This does a command to the database as a formatted command.
   This allows the user to simply specify the command and
   \parameters, and not also maintain a buffer to build the
   string into before passing the string to the ODBC connection
   as a command.
   Parameters
   fmt :  format string appropriate for vsnprintf. ... \: extra
          \parameters to fill the format string.
   See Also
   SQLCommandf
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from GetSQLError.
	*/
PSSQL_VARARG_PROC( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) );
#define DoSQLCommandf   (__DoSQLCommandf( DBG_VOIDSRC ))
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     database connection to perform the query on
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names. May be ommited if you don't want to
              know the names. (is less work internally if this is
              not built).
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   <code lang="c++">
   PODBC odbc = ConnectToDatabase( "MySQL" );
   CTEXTSTR *results;
   CTEXTSTR *column_names;
   int columns;
   for( SQLRecordQueryf( odbc, &amp;columns, &amp;results, &amp;column_names
                       , "select a,b,c from %s where %s=%s"
                       , "table_name"
                       , "column_name"
                       , "'value'"
                       );
        results;
        FetchSQLRecord( odbc, &amp;results ) )
   {
      int n;
       // draw a seperator between rows returned
      printf( " ----- record data ----- \\n" );
      for( n = 0; n \< columns; n++ )
      {
         printf( "Result column '%s' = '%s'\\n", column_name[n], results[n] );
      }
   }
   CloseDatabase( odbc );
   </code>
   If the default connection is used, odbc can be NULL in the
   prior example, or the for staement could be
   <code>
   for( DoSQLRecordQueryf( &amp;columns, &amp;results, &amp;column_names
                         , "select a,b,c from %s where %s=%s"
                         , "table_name"
                         , "column_name"
                         , "'value'"
                         );
        results;
        GetSQLRecord( &amp;results ) )
   {
   }
   </code>                                                                     */
//PSSQL_PROC( int, SQLRecordQueryf )( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... );
PSSQL_VARARG_PROC( int, SQLRecordQueryf, ( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf   (__SQLRecordQueryf( DBG_VOIDSRC ))
PSSQL_VARARG_PROC( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf_v2   (__SQLRecordQueryf_v2( DBG_VOIDSRC ))
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   query :    the string query to do
   ... :      extra parameters for the query format string
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code>
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQueryf( odbc, &amp;result, "select %d,%d,%d", 1, 2, 3 );
   printf( "result : %s" );
   </code>
   \Output
   <code>
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQueryf                                               */
PSSQL_VARARG_PROC( int, SQLQueryf ,( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define SQLQueryf   (__SQLQueryf( DBG_VOIDSRC ))
/* This performs a command on a SQL connection.
   Parameters
   odbc :  database connection to do the command on
   fmt :   format string as appropriate for vsnprintf
   ... :   extra arguments as required by the format string
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from FetchSQLError.
                                                            */
PSSQL_VARARG_PROC( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) );
#define SQLCommandf   (__SQLCommandf( DBG_VOIDSRC ))
/* Function signature for the callback when the SQL layer can
   log a status about a database connection (connection,
   disconnected, failed...) See SQLSetFeedbackHandler.        */
typedef void (CPROC *HandleSQLFeedback)(CTEXTSTR message);
// register a feedback message for startup messages
//  allows external bannering of status... perhaps this can handle failures
//  and disconnects also...
PSSQL_PROC( void, SQLSetFeedbackHandler )( HandleSQLFeedback handler );
/* Parses a CREATE TABLE statement and builds a PTABLE from it.
   Parameters
   cmd :         a CREATE TABLE sql command. It is a little
                 sqlite/mysql centric, and may fail on column
                 types for SQL Server.
   writestate :  if writestate is TRUE, a file called
                 'sparse.txt' will be generated with a C
                 structure of the Create Table statement passed. This
                 \file could then be used to copy into code, and
                 have a code\-static definition instead of going
                 from the create table statement.
   Returns
   a PTABLE which represents the create table statement.              */
PSSQL_PROC( PTABLE, GetFieldsInSQLEx )( CTEXTSTR cmd, int writestate DBG_PASS );
/* <combine sack::sql::GetFieldsInSQLEx@CTEXTSTR@int writestate>
   \ \                                                           */
#define GetFieldsInSQL(c,w) GetFieldsInSQLEx( c, w DBG_SRC )
//PSSQL_PROC( PTABLE, GetFieldsInSQL )( CTEXTSTR cmd, int writestate);
// this is used to destroy the table returned by GetFieldsInSQL
PSSQL_PROC( void, DestroySQLTable )( PTABLE table );
// allow setting and getting of a bit of user data associated with the PODBC...
// though this can result in memory losses at the moment, cause there is no notification
// that the PODBC has gone away, and that the user needs to remove his data...
PSSQL_PROC( uintptr_t, SQLGetUserData )( PODBC odbc );
/* A PODBC may have a user data assigned to it.
   Parameters
   odbc :  connection to set the data for; shouldn't be NULL.
   psv :   user data to assign to the database connection.
   See Also
   SQLGetUserData                                             */
PSSQL_PROC( void, SQLSetUserData )( PODBC odbc, uintptr_t );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  */
PSSQL_PROC( CTEXTSTR, GetGUID )( void );
/* Returns a text string GUID, This uses UuidCreateSequential  */
PSSQL_PROC( CTEXTSTR, GetSeqGUID )( void );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  This tring is the constant 0 guid */
PSSQL_PROC( CTEXTSTR, GuidZero )( void );
/* convert a string GUID to a binary representation of 16 bytes.
   litte_endian will byte-swap the grouped portions of numbers in a guid so they can be printed appropriately*/
PSSQL_PROC( uint8_t*, GetGUIDBinaryEx )( CTEXTSTR guid, LOGICAL litte_endian );
#define GetGUIDBinary(g) GetGUIDBinaryEx(g, TRUE )
struct guid_binary {
	union {
		struct {
			uint8_t bytes[16];
			uint8_t zero[2];
		} b;
		struct {
			uint32_t l1;
			uint16_t w1;
			uint16_t w2;
			uint16_t w3;
			uint64_t ll1;
		} d;
	} u;
};
// snprintf( buf, 256, guid_format, guid_param_pass(&guid_binary) )
// snprintf( buf, 256, guid_format, guid_param_pass(binary_buffer_result) )
#define guid_format "%08" _32fx "-%04" _16fx "-%04" _16fx "-%04" _16fx "-%012" _64fx
#define guid_param_pass(n) ((struct guid_binary*)(n))->u.d.l1,((struct guid_binary*)(n))->u.d.w1,((struct guid_binary*)(n))->u.d.w2,((struct guid_binary*)(n))->u.d.w3,((struct guid_binary*)(n))->u.d.ll1
/* some internal stub-proxy linkage for generating remote
   responders..
   This was work in progress for providing a msgsvr service to
   SQL. One of the implementations of this library was across a
   windows message queue using ATOM types to transport results
   and commands. Was going to implement this on the abstract
   msgqueue interface.                                          */
typedef struct responce_tag
{
	struct {
		BIT_FIELD bSingleLine : 1;
		BIT_FIELD bMultiLine : 1;
		BIT_FIELD bFields : 1;
	} flags;
	PVARTEXT result_single_line;
	int nLines;
	CTEXTSTR *pLines;
	CTEXTSTR *pFields;
} SQL_RESPONCE, *PSQL_RESPONCE;
/* *WORK IN PROGRESS* function call signature for callback method passed to
   RegisterResponceHandler.                              */
typedef void (CPROC *result_responder)( int responce
									  , PSQL_RESPONCE result );
/* *WORK IN PROGRESS*
   result_responder :  callback function to get called with sql
                       global status messages.
   See Also
   <link sack::sql::result_responder, Result Responder Type>    */
PSSQL_PROC( void, RegisterResponceHandler )( result_responder );
/* Thread protect means to use critical sections to protect this
   connection against multiple thread access. Recommended usage
   is to not use a PODBC with more than one thread in the first
   place.
   Parameters
   odbc :     connection to enable; if null, references the
              \internal static connection.
   bEnable :  TRUE to enable, FALSE to disable.                  */
PSSQL_PROC( void, SetSQLThreadProtect )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
   to trigger this process early.
   Parameters
   odbc :     connection to set auto transact on
   bEnable :  TRUE to enable, FALSE to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransact )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
	to trigger this process early.
	if Callback is set, automatically enables AutoTransact
   if Callback is NULL, automatically clears AutoTransact
   Parameters
   odbc :     connection to set auto transact on
   callback :  not NULL to enable, NULL to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransactCallback )( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is closed (allowing the file to be
   not-in-use during idle). PODBC odject remains valid, and
   connection to database is re-enabled on next usage.
   Parameters
   odbc :     connection to enable auto close behavior on
   bEnable :  TRUE to enable auto close FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoClose )( PODBC odbc, LOGICAL bEnable );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is issued a PRAGMA wal_checkpoint
   Parameters
   odbc :     connection to enable auto checkpoint behavior on
   bEnable :  TRUE to enable auto checkpoint FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoCheckpoint )( PODBC odbc, LOGICAL bEnable );
/* returns the current value of auto checkpoint mode on a conneciton
   Parameters
   odbc :     connection to enable auto checkpoint behavior on */
PSSQL_PROC( LOGICAL, GetSQLAutoCheckpoint )( PODBC odbc );
/* A function to apply a time offset for fiscal time
   calculations; sometimes the day doesn't end at midnight, but
   a shift might last until 5 in the morning.
   Parameters
   odbc :            connection to get the appropriate SQL
                     expression for
   BeginOfDayType :  name of the type of beginning of the day
   default_begin :   the default time when a day begins.
   Note
   default_begin is a format sort of like a time. If this is a
   simple integer 5 then it's 5:00am, if it's more than 100,
   then it's assumed to be hours and minutes so 530 would be
   5:30 in the monring. this is also stored in the option
   databse, so the default value can be overridden; if the SQL
   value has a ':' in it then it is parsed as hours and minutes.
   Negative time may be used to indicate that the day begins
   before the day ends (-2 would be day end at 10pm).            */
PSSQL_PROC( CTEXTSTR, GetSQLOffsetDate )( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin );
/* Performs a low level backup of one database to another.  This API supports
   sqlite3 connections ONLY.
   Parameters
   source :            original database to copy from
   dest :    database to copy to
   */
PSSQL_PROC( LOGICAL, BackupDatabase )( PODBC source, PODBC dest );
/* return the underlaying native connection handle of the database connection
 */
// deprecated during dev, instead added function hook exports
//PSSQL_PROC( POINTER, GetODBCHandle )( PODBC odbc );
/* set a handler to be triggered when SQLite Database finds corruption type error...
 */
PSSQL_PROC( void, SetSQLCorruptionHandler )( PODBC odbc, void (CPROC*f)(uintptr_t psv, PODBC odbc), uintptr_t psv );
/* Utility function to parse DSN according to sack sqlite vfs rules... */
PSSQL_PROC( void, ParseDSN )( CTEXTSTR dsn, char **vfs, char **vfsInfo, char **dbFile );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#ifdef __cplusplus
SQL_NAMESPACE_END
#endif
struct sqlite3_value;
struct sqlite3_context;
#ifdef __cplusplus
SQL_NAMESPACE
#endif
PSSQL_PROC( int, PSSQL_AddSqliteFunction )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteProcedure )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteAggregate )( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( POINTER, PSSQL_GetSqliteFunctionData )( struct sqlite3_context*context );
PSSQL_PROC( void, PSSQL_ResultSqliteText )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteBlob )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteDouble )( struct sqlite3_context*context, double val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt )( struct sqlite3_context*context, int val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt64 )( struct sqlite3_context*context, int64_t val );
PSSQL_PROC( void, PSSQL_ResultSqliteNull )( struct sqlite3_context*context );
enum sqlite_data_types {
	PSSQL_TYPE_INTEGER= 1,
	PSSQL_TYPE_FLOAT= 2,
	PSSQL_TYPE_TEXT = 3,
	PSSQL_TYPE_BLOB  = 4,
	PSSQL_TYPE_NULL = 5,
};
PSSQL_PROC( enum sqlite_data_types, PSSQL_GetSqliteValueType )( struct sqlite3_value *val );
PSSQL_PROC( void, PSSQL_GetSqliteValueText )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueBlob )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueDouble )( struct sqlite3_value *val, double *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt )( struct sqlite3_value *val, int *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt64 )( struct sqlite3_value *val, int64_t *result );
PSSQL_PROC( const char *, PSSQL_GetColumnTableName )( PODBC odbc, int col );
PSSQL_PROC( const char *, PSSQL_GetColumnTableAliasName )( PODBC odbc, int col );
PSSQL_PROC( void, PSSQL_GetSqliteValue )( struct sqlite3_value *val, const char **text, int *textLen );
#endif
SQL_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::sql;
#endif
#endif
#if 0
#endif
// sqloptint.h leaves namespace open.
// these headers should really be collapsed.
#ifndef SQL_GET_OPTION_DEFINED
#define SQL_GET_OPTION_DEFINED
#ifdef __cplusplus
#define _OPTION_NAMESPACE namespace options {
#define _OPTION_NAMESPACE_END }
#define USE_OPTION_NAMESPACE	 using namespace sack::sql::options;
#else
#define _OPTION_NAMESPACE
#define _OPTION_NAMESPACE_END
#define USE_OPTION_NAMESPACE
#endif
SACK_NAMESPACE
   _SQL_NAMESPACE
	/* Contains methods for saving and recovering options from a
	   database. If enabled, will use a local option.db sqlite
	   database. Use EditOptions application to modify options. Can
	   use any database connection, but sql.config file will specify
	   'option.db' to start.                                         */
	_OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE SACK_NAMESPACE _SQL_NAMESPACE _OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE_END _OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
#ifdef SQLGETOPTION_SOURCE
#define SQLGETOPTION_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SQLGETOPTION_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifndef __NO_INTERFACES__
   _INTERFACE_NAMESPACE
/* Defines a set of functions that can be registered as an
   interface, and the interface can be used for saving options. Module
   ideas might be to save into the windows registry system or
   into INI files.                                                     */
typedef struct option_interface_tag
{
   // these provide simple section, key, value queries.
	METHOD_PTR( size_t, GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame );
	METHOD_PTR( int32_t, GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
	METHOD_PTR( size_t, GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer );
	METHOD_PTR( int32_t, GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
   // these provide an additional level of abstraction - the ini file
	METHOD_PTR( LOGICAL, WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
	METHOD_PTR( int32_t, WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
	METHOD_PTR( LOGICAL, WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
	METHOD_PTR( int32_t, WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
   // these offer(expose) the option to be quiet
	METHOD_PTR( size_t, GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( size_t, GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
	METHOD_PTR( LOGICAL, WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush );
	METHOD_PTR( LOGICAL, WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL commit );
} *POPTION_INTERFACE;
#define GetOptionInterface() ((POPTION_INTERFACE)GetInterface( "options" ))
//POPTION_INTERFACE GetOptionInterface( void );
//void DropOptionInterface( POPTION_INTERFACE );
#ifndef DEFAULT_OPTION_INTERFACE
#define DEFAULT_OPTION_INTERFACE ((!pOptionInterface)?(pOptionInterface=GetOptionInterface()):pOptionInterface)
#ifdef USES_OPTION_INTERFACE
static POPTION_INTERFACE pOptionInterface;
#ifdef __WATCOMC__
static void UseInterface( void )
{
	// use the value of this function and set pOptionInterface with it
	// makes pOptionInterface marked as used so is UseInterface.
	// Visual Studio pucked on this because converting a function pointer to data pointer
   // but this function should never be called.
   pOptionInterface = (POPTION_INTERFACE)UseInterface;
}
#endif
#endif
#endif
   _INTERFACE_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::sql::options::Interface;
#endif
#endif
#define OptGetPrivateProfileString   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileString)
#define OptGetPrivateProfileInt      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileInt)
#define OptGetProfileString          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileString)
#define OptGetProfileInt             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileInt)
#define OptWritePrivateProfileString METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileString)
#define OptWritePrivateProfileInt    METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileInt)
#define OptWriteProfileString        METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileString)
#define OptWriteProfileInt           METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileInt)
#define OptGetPrivateProfileStringEx   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileStringEx)
#define OptGetPrivateProfileIntEx      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileIntEx)
#define OptGetProfileStringEx          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileStringEx)
#define OptGetProfileIntEx             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileIntEx)
#define OptWritePrivateProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileStringEx)
#define OptWriteProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileStringEx)
SACK_OPTION_NAMESPACE_END
#endif
SACK_OPTION_NAMESPACE
typedef struct sack_option_tree_family_node *POPTION_TREE_NODE;
typedef struct sack_option_tree_family *POPTION_TREE;
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
/* All gets eventually end up here. This function gets a value
   from a database. Functions which return an 'int' use this
   function, but has extra processing to convert the text into a
   number; also if the text is 'Y', or 'y' then the option's int
   value is 1.
   Parameters
   pSection :     Path of the option to retrieve.
   pOptname :     Actual option name to retrieve.
   pDefaultbuf :  Default value if the option doesn't exist
                  already.
   pBuffer :      Pointer to the buffer to get the result
   nBuffer :      size of the result buffer in characters (not
                  bytes).
   pININame :     This is the upper level name. If a function
                  does not have a pININame, then the name
                  "DEFAULT' is used. (pass NULL here for
                  non\-private)
   bQuiet :       Boolean, if configured to prompt the user for
                  option values, this overrides the default to
                  disable prompting.                             */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionStringEx )(PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush);
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL bFlush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIfile, LOGICAL flush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer,  CTEXTSTR app);
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pININame
																				, LOGICAL bQuiet
																				 DBG_PASS
																				);
#ifdef __NO_OPTIONS__
#define SACK_GetProfileInt( s,e,d ) (d)
#define SACK_GetProfileString( s,e,d,b,n ) ((d)?StrCpyEx( b,d,n ):0)
#endif
#define SACK_GetPrivateOptionString( odbc, section, option, default_buf, buf, buf_size, ini_name )	   SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionStringEx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet DBG_SRC )
#define SACK_GetOptionString( odbc, section, option, default_buf, buf, buf_size )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, FALSE DBG_SRC )
#define SACK_GetOptionStringEx( odbc, section, option, default_buf, buf, buf_size, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet DBG_PASS );
#define SACK_GetPrivateOptionInt( odbc, section, option, default_val, ini_name )	   SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionIntEx( odbc, section, option, default_val, ini_name, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, quiet DBG_SRC )
#define SACK_GetOptionInt( odbc, section, option, default_val )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, FALSE DBG_SRC )
#define SACK_GetOptionIntEx( odbc, section, option, default_val, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void );
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( POPTION_TREE, GetOptionTreeExxx )( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
/* Sets the option database to use (does not prevent
   preload/deadstart code from using the old database) but this
   can be used for comparison utilities.
   Parameters
   odbc :  The PODBC connection to use.
   See Also
   PODBC                                                        */
SQLGETOPTION_PROC( POPTION_TREE, SetOptionDatabase )( PODBC odbc );
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void );
SQLGETOPTION_PROC( void, SetOptionDatabaseOption )( PODBC odbc );
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void );
SQLGETOPTION_PROC( void, EndBatchUpdate )( void );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexExx )( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( size_t, GetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR value );
SQLGETOPTION_PROC( size_t, GetOptionStringValue )( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len );
SQLGETOPTION_PROC( LOGICAL, SetOptionStringValue )( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot );
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
 // flush the map cache.
SQLGETOPTION_PROC( void, ResetOptionMap )( PODBC odbc );
SQLGETOPTION_PROC( PODBC, GetOptionODBCEx )( CTEXTSTR dsn DBG_PASS );
SQLGETOPTION_PROC( void, DropOptionODBCEx )( PODBC odbc DBG_PASS );
SQLGETOPTION_PROC( PODBC, GetOptionODBC )( CTEXTSTR dsn );
SQLGETOPTION_PROC( void, DropOptionODBC )( PODBC odbc );
#define GetOptionODBC( b) GetOptionODBCEx( b DBG_SRC )
#define DropOptionODBC(a) DropOptionODBCEx( a DBG_SRC )
SQLGETOPTION_PROC( void, FindOptions )( PODBC odbc, PLIST *result_list, CTEXTSTR name );
_OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
	USE_OPTION_NAMESPACE
#endif
#ifdef __NO_BAG__
#undef lprintf
#define lprintf printf
#define BAG_Exit exit
#else
#endif
//#define lprintf(f,...) printf(f "\n",##__VA_ARGS__)
//#define _lprintf(n) lprintf
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
SACK_DEADSTART_NAMESPACE
//#undef PRELOAD
EXPORT_METHOD void RunDeadstart( void );
typedef struct startup_proc_tag {
	DeclareLink( struct startup_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} STARTUP_PROC, *PSTARTUP_PROC;
typedef struct shutdown_proc_tag {
	DeclareLink( struct shutdown_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} SHUTDOWN_PROC, *PSHUTDOWN_PROC;
struct deadstart_local_data_
{
	// this is a lot of procs...
	int nShutdownProcs;
#define nShutdownProcs l.nShutdownProcs
	SHUTDOWN_PROC shutdown_procs[512];
#define shutdown_procs l.shutdown_procs
	int bInitialDone;
#define bInitialDone l.bInitialDone
	LOGICAL bInitialStarted;
#define bInitialStarted l.bInitialStarted
	int bSuspend;
#define bSuspend l.bSuspend
	int bDispatched;
//#define bDispatched l.bDispatched
	PSHUTDOWN_PROC shutdown_proc_schedule;
#define shutdown_proc_schedule l.shutdown_proc_schedule
 // count of used procs...
	int nProcs;
#define nProcs l.nProcs
	STARTUP_PROC procs[1024];
#define procs l.procs
	PSTARTUP_PROC proc_schedule;
#define proc_schedule l.proc_schedule
	struct
	{
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bLog : 1;
	} flags;
};
#ifdef UNDER_CE
#  ifndef __STATIC_GLOBALS__
#    define __STATIC_GLOBALS__
#  endif
#endif
#ifndef __STATIC_GLOBALS__
static struct deadstart_local_data_ *deadstart_local_data;
#define l (*deadstart_local_data)
#else
static struct deadstart_local_data_ deadstart_local_data;
#define l (deadstart_local_data)
#endif
EXPORT_METHOD void RunExits( void )
{
	InvokeExits();
}
static void InitLocal( void )
{
#ifndef __STATIC_GLOBALS__
	if( !deadstart_local_data )
	{
		SimpleRegisterAndCreateGlobal( deadstart_local_data );
	}
#endif
	if( !l.flags.bInitialized )
	{
		//atexit( RunExits );
		l.flags.bInitialized = 1;
	}
}
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
#define ENQUE_STARTUP_DBG_SRC DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc DBG_PASS )
#else
#define ENQUE_STARTUP_DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc )
#endif
{
	PSTARTUP_PROC check;
	PSTARTUP_PROC last;
		if( proc->next || proc->me )
		{
			if( ( (*proc->me) = proc->next ) )
				proc->next->me = proc->me;
		}
		for( last = check = (*root); check; check = check->next )
		{
			// if the current one being added is less then the one in the list
			// then the one in the list becomes the new one's next...
			if( proc->priority < check->priority )
			{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
				_lprintf(DBG_RELAY)( "%s(%d) is to run before %s and after %s first is %s"
						 , proc->func
						 , proc - procs
						 , check->func
						 , (check->me==root)?"Is First":((PSTARTUP_PROC)check->me)->func
						 , (*root)?(*root)->func:"First"
						 );
#endif
				proc->next = check;
				proc->me = check->me;
				(*check->me) = proc;
				check->me = &proc->next;
				break;
			}
			last = check;
		}
		if( !check )
		{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
			lprintf( "%s(%d) is to run after all"
					 , proc->func
					 , proc - procs
					 );
#endif
			proc->next = NULL;
			if( last )
			{
				last->next = proc;
				proc->me = &last->next;
			}
			else
			{
				(*root) = proc;
				proc->me = root;
			}
		}
}
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityStartupProc( void (CPROC*proc)(void), CTEXTSTR func,int priority, void *use_label DBG_PASS )
{
	int use_proc;
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		lprintf( "Register %s@" DBG_FILELINEFMT_MIN " %d", func DBG_RELAY, priority);
	if( nProcs == 1024 )
	{
		for( use_proc = 0; use_proc < 1024; use_proc++ )
			if( !procs[use_proc].bUsed )
				break;
		if( use_proc == 1024 )
		{
			lprintf( "Used all 1024, and, have 1024 startups total scheduled." );
			DebugBreak();
		}
	}
	else
		use_proc = nProcs;
	procs[use_proc].proc = proc;
	procs[use_proc].func = func;
#ifdef _DEBUG
	procs[use_proc].file = pFile;
	procs[use_proc].line = nLine;
#endif
	procs[use_proc].priority = priority;
	procs[use_proc].bUsed = 1;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].next = NULL;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].me = NULL;
	EnqueStartupProc( &proc_schedule, procs + use_proc ENQUE_STARTUP_DBG_SRC );
	if( nProcs < 1024 )
		nProcs++;
	/*
	if( nProcs == 1024 )
	{
		lprintf( "Excessive number of startup procs!" );
		DebugBreak();
	}
	*/
	if( bInitialDone && !bSuspend )
	{
#define ONE_MACRO(a,b) a,b
#ifdef _DEBUG
		_xlprintf(LOG_NOISE,pFile,nLine)( "Initial done, not suspended, dispatch immediate." );
#endif
		InvokeDeadstart();
	}
	//lprintf( "Total procs %d", nProcs );
}
#ifdef __LINUX__
// this handles the peculiarities of fork() and exit()
void ClearDeadstarts( void )
{
	// this is reserved for the sole use of
	// fork() success and then exec() failing...
	// when oh wait - __attribute__((destructor))
	// if( registered_pid != getppid() )
	shutdown_proc_schedule = NULL;
	// be rude - yes we lose resources. but everything goes away cause
	// this is just a clone..
}
#endif
#ifndef UNDER_CE
#  if defined( WIN32 )
#    ifndef __cplusplus_cli
static BOOL WINAPI CtrlC( DWORD dwCtrlType )
{
	switch( dwCtrlType )
	{
	case CTRL_BREAK_EVENT:
	case CTRL_C_EVENT:
		InvokeExits();
		// allow C api to exit, whatever C api we're using
		// (allows triggering atexit functions)
		exit(3);
		return TRUE;
	case CTRL_CLOSE_EVENT:
		break;
	case CTRL_LOGOFF_EVENT:
		break;
	case CTRL_SHUTDOWN_EVENT:
		break;
	}
	// default... return not processed.
	return FALSE;
}
#    endif
#  endif
#  ifndef WIN32
static void CtrlC( int signal )
{
	exit(3);
}
#  endif
#endif
// wow no such thing as static-izing this... it's
// always retrieved with dynamic function loading, therefore
// MUST be exported if at all possible.
// this one is used when a library is loaded.
void InvokeDeadstart( void )
{
	PSTARTUP_PROC proc;
	PSTARTUP_PROC resumed_proc;
	//if( !bInitialDone /*|| bDispatched*/ )
	//   return;
	InitLocal();
	if( bInitialStarted )
		return;
	bInitialStarted = 1;
	// allowing initial start to be set lets final resume do this invoke.
	if( bSuspend )
	{
		if( l.flags.bLog )
 //-V595
			lprintf( "Suspended, first proc is %s", proc_schedule?proc_schedule->func:"No First" );
		return;
	}
#ifdef WIN32
	if( !bInitialDone && !l.bDispatched )
	{
#  ifndef UNDER_CE
		if( GetConsoleWindow() )
		{
#    ifndef __cplusplus_cli
			//MessageBox( NULL, "!!--!! CtrlC", "blah", MB_OK );
			SetConsoleCtrlHandler( CtrlC, TRUE );
#    endif
		}
		else
		{
			//MessageBox( NULL, "!!--!! NO CtrlC", "blah", MB_OK );
 // do nothing if we're no actually a console window. this should fix ctrl-c not working in CMD prompts launched by MILK/InterShell
			;
		}
#  endif
	}
#endif
	while( ( proc = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
	{
		// need to set this to point to new head of list... it's not in proc_schedule anymore
		//proc->me = &proc;
		if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		{
#ifdef _DEBUG
			lprintf( "Dispatch %s@%s(%d)p:%d ", proc->func,proc->file,proc->line, proc->priority );
#else
			lprintf( "Dispatch %s@p:%d ", proc->func, proc->priority );
#endif
		}
		{
			l.bDispatched = 1;
#ifdef _DEBUG
			if( proc->proc
#  ifndef __LINUX__
#    if  __WATCOMC__ >= 1280
				&& !IsBadCodePtr( (int(STDCALL*)(void))proc->proc )
#    elif defined( __64__ )
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#    else
//				&& !IsBadCodePtr( (int STDCALL(*)(void))proc->proc )
#    endif
#  endif
			  )
#endif
			{
				proc->proc();
			}
			proc->bUsed = 0;
			l.bDispatched = 0;
		}
		// look to see if anything new was scheduled.  Grab the list, add it to the one's we're processing.
		{
			{
				PSTARTUP_PROC newly_scheduled_things;
				proc->me = &proc;
				resumed_proc = proc;
				if( ( newly_scheduled_things = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
				{
					newly_scheduled_things->me = &newly_scheduled_things;
					//lprintf( "------------------  newly scheduled startups; requeue old startups into new list ------------------ " );
					while( newly_scheduled_things )
					{
						EnqueStartupProc( &proc, newly_scheduled_things ENQUE_STARTUP_DBG_SRC );
					}
				}
				else
					resumed_proc = NULL;
			}
			proc_schedule = proc;
			proc_schedule->me = &proc_schedule;
		}
		if( resumed_proc )
			UnlinkThing( resumed_proc );
		else
			UnlinkThing( proc );
	}
	bInitialStarted = 0;
}
void MarkRootDeadstartComplete( void )
{
	bInitialDone = 1;
}
#ifndef __NO_OPTIONS__
// options initializes at SQL+1
PRIORITY_PRELOAD( InitDeadstartOptions, NAMESPACE_PRELOAD_PRIORITY+1 )
{
#ifdef DISABLE_DEBUG_REGISTER_AND_DISPATCH
#  ifndef __NO_OPTIONS
	l.flags.bLog = SACK_GetProfileIntEx( "SACK/Deadstart", "Logging Enabled?", 0, TRUE );
#  else
	l.flags.bLog = 0;
#  endif
#else
	l.flags.bLog = 1;
#endif
}
#endif
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityShutdownProc( void (CPROC*proc)(void), CTEXTSTR func, int priority,void *use_label DBG_PASS )
{
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		(deadstart_local_data
#else
		 (1
#endif
		  && l.flags.bLog ))
		lprintf( "Exit Proc %s(%p) from " DBG_FILELINEFMT_MIN " registered..."
				 , func
				 , proc DBG_RELAY );
	shutdown_procs[nShutdownProcs].proc = proc;
	shutdown_procs[nShutdownProcs].func = func;
#ifdef _DEBUG
	shutdown_procs[nShutdownProcs].file = pFile;
	shutdown_procs[nShutdownProcs].line = nLine;
#endif
	shutdown_procs[nShutdownProcs].bUsed = 1;
	shutdown_procs[nShutdownProcs].priority = priority;
	{
		PSHUTDOWN_PROC check;
		for( check = shutdown_proc_schedule; check; check = check->next )
		{
			if( shutdown_procs[nShutdownProcs].priority >= check->priority )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "%s(%d) is to run before %s(%d) %s"
						 , shutdown_procs[nShutdownProcs].func
						 , nShutdownProcs
						 , check->file
						 , check->line
						 , check->func );
#endif
				shutdown_procs[nShutdownProcs].next = check;
				shutdown_procs[nShutdownProcs].me = check->me;
				(*check->me) = shutdown_procs + nShutdownProcs;
				check->me = &shutdown_procs[nShutdownProcs].next;
				break;
			}
		}
		if( !check )
			LinkLast( shutdown_proc_schedule, PSHUTDOWN_PROC, shutdown_procs + nShutdownProcs );
		//lprintf( "first routine is %s(%d)"
		//		 , shutdown_proc_schedule->func
		//		 , shutdown_proc_schedule->line );
	}
	nShutdownProcs++;
	//lprintf( "Total procs %d", nProcs );
}
void InvokeExits( void )
{
	// okay well since noone previously scheduled exits...
	// this runs a prioritized list of exits - all within
	// a single moment of exited-ness.
	PSHUTDOWN_PROC proc;
	// shutdown is much easier than startup cause more
	// procedures shouldn't be added as a property of shutdown.
	// don't allow shutdown procs to schedule more shutdown procs...
	// although in theory we could; if the first list contained
	// ReleaseAllMemory(); then there is no memory.
	if(
#ifndef __STATIC_GLOBALS__
		deadstart_local_data &&
#endif
			( proc = (PSHUTDOWN_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&shutdown_proc_schedule, 0 ) ) != NULL
		  )
	{
		// just before all memory goes away
		// global memory goes away (including mine) so deadstart_local_data is invalidated.
#ifndef __STATIC_GLOBALS__
		struct deadstart_local_data_ *local_pointer = (struct deadstart_local_data_*)(((uintptr_t)deadstart_local_data)-sizeof(PLIST));
#endif
		PSHUTDOWN_PROC proclist = proc;
		// link list to myself..
#ifndef __STATIC_GLOBALS__
		Hold( local_pointer );
#endif
		proc->me = &proclist;
		while( ( proc = proclist ) )
		{
#if defined( DEBUG_SHUTDOWN )
			lprintf( "Exit Proc %s(%p)(%d) priority %d from %s(%d)..."
			       , proc->func
			       , proc->proc
			       , proc - shutdown_procs
			       , proc->priority
			       , proc->file
			       , proc->line );
#endif
			if( proc->priority == 0 )
			{
				//atexit( proc->proc );
				//continue;
			}
			// don't release this stuff... memory might be one of the autoexiters.
			UnlinkThing( proc );
			if( proc->proc
#ifndef __LINUX__
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#endif
			  )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "Dispatching..." );
#endif
				proc->proc();
			}
			// okay I have the whol elist... so...
#ifdef DEBUG_SHUTDOWN
			lprintf( "Okay and that's done... next is %p %p", proclist, shutdown_proc_schedule );
#endif
		}
		// nope by this time memory doesn't exist anywhere.
		//Release( local_pointer );
		//shutdown_proc_schedule = proc;
	}
#ifndef __STATIC_GLOBALS__
	deadstart_local_data = (struct deadstart_local_data_*)NULL;
#endif
	//shutdown_proc_schedule = NULL;
}
void DispelDeadstart( void )
{
	shutdown_proc_schedule = NULL;
}
#ifdef __cplusplus
ROOT_ATEXIT(AutoRunExits)
{
	InvokeExits();
}
#endif
void SuspendDeadstart( void )
{
	bSuspend++;
}
void ResumeDeadstart( void )
{
	bSuspend--;
	if( !bSuspend )
	{
		if( bInitialDone )
			InvokeDeadstart();
	}
}
SACK_DEADSTART_NAMESPACE_END
SACK_NAMESPACE
// linked into BAG to provide a common definition for function Exit()
// this then invokes an exit in the mainline program (if available)
void BAG_Exit( int code )
{
#ifndef __cplusplus_cli
	InvokeExits();
#endif
#undef exit
	exit( code );
}
// legacy linking code - might still be usin this for linux...
LOGICAL is_deadstart_complete( void )
{
	//extern uint32_t deadstart_complete;
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
//deadstart_complete;
		return bInitialDone;
#endif
	return FALSE;
}
SACK_NAMESPACE_END
SACK_DEADSTART_NAMESPACE
LOGICAL IsRootDeadstartStarted( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialStarted;
	return 0;
#else
	return bInitialStarted;
#endif
}
LOGICAL IsRootDeadstartComplete( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialDone;
	return 0;
#else
	return bInitialDone;
#endif
}
#ifndef __STATIC__
#ifndef __WATCOMC__
#if !defined( __cplusplus_cli )
#if !defined( NO_DEADSTART_DLLMAIN ) && !defined( BUILD_PORTABLE_EXECUTABLE )
#  if !defined( __LINUX__ ) && !defined( __GNUC__ )
#    ifdef __cplusplus
extern "C"
#    endif
__declspec(dllexport)
	BOOL WINAPI DllMain(  HINSTANCE hinstDLL,
   DWORD fdwReason,
   LPVOID lpvReserved
		   )
{
	if( fdwReason == DLL_PROCESS_DETACH )
		InvokeExits();
	return TRUE;
}
#  else
void RootDestructor(void) __attribute__((destructor));
void RootDestructor( void )
{
	InvokeExits();
}
#  endif
#endif
#endif
#endif
#endif
#undef l
SACK_DEADSTART_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
//   DEBUG_SYMBOLS
// had some problems with OpenSpace opening a shared region under win98
// Apparently if a create happens with a size of 0, the name of the region
// becomes unusable, until a reboot happens.
//#define DEBUG_OPEN_SPACE
// this variable controls whether allocate/release is logged.
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#define NO_UNICODE_C
//#define USE_SIMPLE_LOCK_ON_OPEN
#ifdef __LINUX__
#include <fcntl.h>
#include <sys/mman.h>
#endif
#ifdef _MSC_VER
#ifndef UNDER_CE
#endif
#endif
#define DEFINE_MEMORY_STRUCT
/* A header for doing .NET /CLR compatiblity changes. Things
   like fopen needing to be _fopen_s and junk.               */
#ifndef FILE_DOT_NET_COMPAT
/* Header multiple inclusion protection symbol. */
#define FILE_DOT_NET_COMPAT
/*
 *  Created By Jim Buckeyne
 *
 *  Purpose:
 *    Provides some cross platform/library functionatlity for
 *  filesystem activities.
 *  - File dates, times, stuff like that
 *  - make paths, change paths
 *  - path parsing (like strchr, strrchr, but looking for closest / or \)
 *  - scan a directory for a set of files... using a recursive callback method
 */
#ifndef FILESYSTEM_UTILS_DEFINED
/* Header multiple inclusion protection symbol. */
#define FILESYSTEM_UTILS_DEFINED
#if _MSC_VER >= 1600
#include <share.h>
#endif
#if !defined( UNDER_CE )
#if !defined( __LINUX__ )
#include <io.h>
#else
#define LPFILETIME uint64_t*
#define FILETIME uint64_t
#endif
#endif
/* uhmm in legacy usage this was not CPROC, but was unspecified */
#define FILESYS_API CPROC
// DOM-IGNORE-BEGIN
#ifdef FILESYSTEM_LIBRARY_SOURCE
#  define FILESYS_PROC EXPORT_METHOD
#else
#  define FILESYS_PROC IMPORT_METHOD
#endif
// DOM-IGNORE-END
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _FILESYS_NAMESPACE  namespace filesys {
/* Define the ending symbol for file system namespace. */
#define _FILESYS_NAMESPACE_END }
/* Defined the namespace of file montior utilities. File monitor
   provides event notification based on file system changes.     */
#define _FILEMON_NAMESPACE  namespace monitor {
/* Define the end symbol for file monitor namespace. */
#define _FILEMON_NAMESPACE_END }
#else
#define _FILESYS_NAMESPACE
#define _FILESYS_NAMESPACE_END
#define _FILEMON_NAMESPACE
#define _FILEMON_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define FILESYS_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define FILESYS_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE
/* Define end file monitor namespace. */
#define FILEMON_NAMESPACE_END _FILEMON_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* Defines the file montior namespace when compiling C++. */
#define FILEMON_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE _FILEMON_NAMESPACE
SACK_NAMESPACE
/* \File system abstractions. A few things like get current path
   may or may not exist on a function.
   Primarily this defines functions 'pathchr' and 'pathrchr'
   which resemble 'strchr' and 'strrchr' but search a string for
   a path character. A path character is either a / or a \\.
   Also in this area is file monitoring functions which support
   methods on windows and linux to get event notifications when
   directories and, by filtering, files that have changed.
                                                                 */
_FILESYS_NAMESPACE
	enum ScanFileFlags {
 // go into subdirectories
SFF_SUBCURSE    = 1,
 // return directory names also
SFF_DIRECTORIES = 2,
 // don't concatenate base with filename to result.
SFF_NAMEONLY    = 4,
 // when matching filename - do not match case.
SFF_IGNORECASE  = 8,
 // don't concatenate base with filename to result, but do build path relative to root specified
SFF_SUBPATHONLY    = 16,
	};
 // flags sent to Process when called with a matching name
enum ScanFileProcessFlags{
 // is a directory...
SFF_DIRECTORY  = 1,
 // this is a drive...
		SFF_DRIVE      = 2,
};
struct file_system_mounted_interface;
/* Extended external file system interface to be able to use external file systems */
struct file_system_interface {
                                                  //filename
	void* (CPROC *open)(uintptr_t psvInstance, const char *, const char *);
                                                 //file *
	int (CPROC *_close)(void *);
                    //file *, buffer, length (to read)
	size_t (CPROC *_read)(void *,void *, size_t);
                    //file *, buffer, length (to write)
	size_t (CPROC *_write)(void*,const void *, size_t);
	size_t (CPROC *seek)( void *, size_t, int whence);
	void  (CPROC *truncate)( void *);
	int (CPROC *_unlink)( uintptr_t psvInstance, const char *);
 // get file size
	size_t (CPROC *size)( void *);
 // get file current position
	size_t (CPROC *tell)( void *);
	int (CPROC *flush )(void *kp);
	int (CPROC *exists)( uintptr_t psvInstance, const char *file );
	LOGICAL (CPROC*copy_write_buffer)(void );
	struct find_cursor *(CPROC *find_create_cursor )( uintptr_t psvInstance, const char *root, const char *filemask );
	int (CPROC *find_first)( struct find_cursor *cursor );
	int (CPROC *find_close)( struct find_cursor *cursor );
	int (CPROC *find_next)( struct find_cursor *cursor );
	char * (CPROC *find_get_name)( struct find_cursor *cursor );
	size_t (CPROC *find_get_size)( struct find_cursor *cursor );
	LOGICAL (CPROC *find_is_directory)( struct find_cursor *cursor );
	LOGICAL (CPROC *is_directory)( uintptr_t psvInstance, const char *cursor );
	LOGICAL (CPROC *rename )( uintptr_t psvInstance, const char *original_name, const char *new_name );
	uintptr_t (CPROC *ioctl)( uintptr_t psvInstance, uintptr_t opCode, va_list args );
	uintptr_t (CPROC *fs_ioctl)(uintptr_t psvInstance, uintptr_t opCode, va_list args);
	uint64_t( CPROC *find_get_ctime )(struct find_cursor *cursor);
	uint64_t( CPROC *find_get_wtime )(struct find_cursor *cursor);
};
/* \ \
   Parameters
   mask :      This is the mask used to compare
   name :      this is the name to compare against using the mask.
   keepcase :  if TRUE, must match case also.
   Returns
   TRUE if name is matched by mask. Otherwise returns FALSE.
   Example
   <code lang="c++">
   if( CompareMask( "*.exe", "program.exe", FALSE ) )
   {
       // then program.exe is matched by the mask.
   }
   </code>
   Remarks
   The mask support standard 'globbing' characters.
   ? matches one character
   \* matches 0 or more characters
   otherwise the literal character must match, unless comparing
   case insensitive, in which case 'A' == 'a' also.                */
FILESYS_PROC  int FILESYS_API  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase );
// ScanFiles usage:
//   base - base path to scan
//   mask - file mask to process if NULL or "*" is everything "*.*" must contain a .
//   pInfo is a pointer to a void* - this pointer is used to maintain
//        internal information...
//   Process is called with the full name of any matching files
//   subcurse is a flag - set to go into all subdirectories looking for files.
// There is no way to abort the scan...
FILESYS_PROC  int FILESYS_API  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
		   , uintptr_t psvUser, LOGICAL begin_sub_path, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  ScanFiles ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
           , uintptr_t psvUser );
FILESYS_PROC  void FILESYS_API  ScanDrives ( void (CPROC *Process)(uintptr_t user, CTEXTSTR letter, int flags)
										  , uintptr_t user );
// pass the pointer (pInfo) from aobve; get find_cursor.
FILESYS_PROC struct find_cursor * FILESYS_API GetScanFileCursor( void *pInfo );
// result is length of name filled into pResult if pResult == NULL && nResult = 0
// the result will the be length of the name matching the file.
FILESYS_PROC  int FILESYS_API  GetMatchingFileName ( CTEXTSTR filemask, enum ScanFileFlags flags, TEXTSTR pResult, int nResult );
// searches a path for the last '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathrchr ( CTEXTSTR path );
#ifdef __cplusplus
FILESYS_PROC  TEXTSTR FILESYS_API  pathrchr ( TEXTSTR path );
#endif
// searches a path for the first '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathchr ( CTEXTSTR path );
// returns pointer passed (if it worked?)
FILESYS_PROC  TEXTSTR FILESYS_API  GetCurrentPath ( TEXTSTR path, int buffer_len );
FILESYS_PROC  int FILESYS_API  SetCurrentPath ( CTEXTSTR path );
/* Creates a directory. If parent pieces of the directory do not
   exist, those parts are created also.
   Example
   <code lang="c#">
   MakePath( "c:\\where\\I'm/going/to/store/data" );
   </code>                                                       */
FILESYS_PROC  int FILESYS_API  MakePath ( CTEXTSTR path );
/* A boolean result function whether a specified name is a
   directory or not. (if not, assumes it's a file).
   Example
   <code lang="c#">
   if( IsPath( "c:/windows" ) )
   {
       // if yes, then c:\\windows is a directory.
   }
   </code>                                                 */
FILESYS_PROC LOGICAL  FILESYS_API  IsPath ( CTEXTSTR path );
FILESYS_PROC LOGICAL  FILESYS_API  IsAbsolutePath( CTEXTSTR path );
FILESYS_PROC  uint64_t     FILESYS_API  GetFileWriteTime ( CTEXTSTR name );
FILESYS_PROC  uint64_t     FILESYS_API  GetTimeAsFileTime ( void );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileWriteTime( CTEXTSTR name, uint64_t filetime );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileTimes( CTEXTSTR name
  // last modification time.
															  , uint64_t filetime_create
 // last modification time.
															  , uint64_t filetime_modify
  // last modification time.
															  , uint64_t filetime_access
															  );
FILESYS_PROC  void    FILESYS_API  SetDefaultFilePath ( CTEXTSTR path );
FILESYS_PROC  INDEX   FILESYS_API  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_prepend_path ( INDEX group, CTEXTSTR filename );
/* This is a new feature added for supporting systems without a
   current file location. This gets an integer ID of a group of
   files by name.
   the name 'default' is used to specify files to go into the
   'current working directory'
	There are some special symbols.
	. = use CurrentPath
	@ = use program path base
   ^ = use program startup path (may not be current)
   Parameters
   groupname :     name of the group
   default_path :  the path of the group, if the name is not
                   found.
   Returns
   the ID of a file group.
   Example
   <code lang="c++">
   int group = GetFileGroup( "fonts", "./fonts" );
   </code>                                                      */
FILESYS_PROC INDEX FILESYS_API  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path );
FILESYS_PROC TEXTSTR FILESYS_API GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPath( CTEXTSTR path );
FILESYS_PROC LOGICAL FILESYS_API SetFileLength( CTEXTSTR path, size_t length );
/* \Returns the size of the file.
   Parameters
   name :  name of the file to get information about
   Returns
   \Returns the size of the file. or -1 if the file did not
   exist.                                                   */
FILESYS_PROC  size_t FILESYS_API  GetSizeofFile ( TEXTCHAR *name, uint32_t* unused );
#ifndef __ANDROID__
/* An extended function, which returns a uint64_t bit time
   appropriate for the current platform. This is meant to
   replace 'stat'. It can get all commonly checked attributes of
   a file.
   Parameters
   name :              name of the file to get information about
   lpCreationTime :    pointer to a FILETIME type to get creation
                       time. can be NULL.
   lpLastAccessTime :  pointer to a FILETIME type to get access
                       time. can be NULL.
   lpLastWriteTime :   pointer to a FILETIME type to get write
                       time. can be NULL.
   IsDirectory :       pointer to a LOGICAL to receive indicator
                       whether the file was a directory. can be
                       NULL.
   Returns
   \Returns the size of the file. or -1 if the file did not
	exist.                                                         */
FILESYS_PROC  uint32_t FILESYS_API  GetFileTimeAndSize ( CTEXTSTR name
													, LPFILETIME lpCreationTime
													,  LPFILETIME lpLastAccessTime
													,  LPFILETIME lpLastWriteTime
													, int *IsDirectory
													);
FILESYS_PROC void FILESYS_API ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime );
FILESYS_PROC uint64_t FILESYS_API ConvertFileTimeToInt( const FILETIME *filetime );
#endif
// can use 0 as filegroup default - single 'current working directory'
#ifndef NEED_OLDNAMES
#define _NO_OLDNAMES
#endif
//#ifdef UNDER_CE
# ifndef O_RDONLY
#define O_RDONLY       0x0000
#define O_WRONLY       0x0001
#define O_RDWR         0x0002
#define O_APPEND       0x0008
#define O_CREAT        0x0100
#define O_TRUNC        0x0200
#define O_EXCL         0x0400
#endif
#ifndef __ANDROID__
#  ifndef S_IRUSR
#    define S_IRUSR 1
#    define S_IWUSR 2
#  endif
#endif
//# endif
#ifndef __LINUX__
FILESYS_PROC  HANDLE FILESYS_API  sack_open ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_set_eof ( HANDLE file_handle );
FILESYS_PROC  long  FILESYS_API   sack_tell( INDEX file_handle );
FILESYS_PROC  HANDLE FILESYS_API  sack_openfile ( INDEX group, CTEXTSTR filename, OFSTRUCT *of, int flags );
FILESYS_PROC  HANDLE FILESYS_API  sack_creat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  int FILESYS_API  sack_close ( HANDLE file_handle );
FILESYS_PROC  int FILESYS_API  sack_lseek ( HANDLE file_handle, int pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_read ( HANDLE file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_write ( HANDLE file_handle, CPOINTER buffer, int size );
#endif
FILESYS_PROC  INDEX FILESYS_API  sack_iopen ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  INDEX FILESYS_API  sack_iopenfile ( INDEX group, CTEXTSTR filename, int opts, int flags );
FILESYS_PROC  INDEX FILESYS_API  sack_icreat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_iset_eof ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_iclose ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_ilseek ( INDEX file_handle, size_t pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_iread ( INDEX file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_iwrite ( INDEX file_handle, CPOINTER buffer, int size );
/* internal (c library) file system is registered as prority 1000.... lower priorities are checked first for things like
  ScanFiles(), fopen( ..., "r" ), ... exists(), */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_mount_filesystem( const char *name, struct file_system_interface *, int priority, uintptr_t psvInstance, LOGICAL writable );
FILESYS_PROC void FILESYS_API sack_unmount_filesystem( struct file_system_mounted_interface *mount );
// get a mounted filesystem by name
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_mounted_filesystem( const char *name );
// returrn inteface used on the mounted filesystem.
FILESYS_PROC struct file_system_interface * FILESYS_API sack_get_mounted_filesystem_interface( struct file_system_mounted_interface * );
FILESYS_PROC uintptr_t FILESYS_API sack_get_mounted_filesystem_instance( struct file_system_mounted_interface *mount );
/* sometimes you want scanfiles to only scan external files...
  so this is how to get that mount */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_default_mount( void );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted... */
FILESYS_PROC  FILE* FILESYS_API  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fsopenEx ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted...
   if mode is write/create only the first writable file system is used...
*/
FILESYS_PROC  FILE* FILESYS_API  sack_fsopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode );
FILESYS_PROC  struct file_system_interface * FILESYS_API sack_get_filesystem_interface( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_default_filesystem_interface( struct file_system_interface *fsi );
FILESYS_PROC  void FILESYS_API sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi );
FILESYS_PROC  int FILESYS_API  sack_fclose ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount );
FILESYS_PROC  size_t FILESYS_API  sack_fseek ( FILE *file_file, size_t pos, int whence );
FILESYS_PROC  size_t FILESYS_API  sack_ftell ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fsize ( FILE *file_file );
FILESYS_PROC  LOGICAL FILESYS_API  sack_existsEx ( const char * filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  LOGICAL FILESYS_API  sack_exists ( const char *file_file );
// tests if the text passed is a directory or path to a file... for a specific mount.
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi );
// tests if the text passed is a directory or path to a file... for all mounts
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPath( const char * filename );
FILESYS_PROC  size_t FILESYS_API  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_fgets ( TEXTSTR  buffer, size_t size,FILE *file_file );
FILESYS_PROC  int FILESYS_API  sack_fflush ( FILE *file );
FILESYS_PROC  int FILESYS_API  sack_ftruncate ( FILE *file );
FILESYS_PROC int FILESYS_API sack_vfprintf( FILE *file_handle, const char *format, va_list args );
FILESYS_PROC int FILESYS_API sack_fprintf( FILE *file, const char *format, ... );
FILESYS_PROC int FILESYS_API sack_fputs( const char *format, FILE *file );
FILESYS_PROC  int FILESYS_API  sack_unlinkEx ( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_unlink ( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_rmdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_rename ( CTEXTSTR file_source, CTEXTSTR new_name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_application( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_producer( CTEXTSTR name );
FILESYS_PROC  uintptr_t FILESYS_API  sack_ioctl( FILE *file, uintptr_t opCode, ... );
FILESYS_PROC  uintptr_t FILESYS_API  sack_fs_ioctl( struct file_system_mounted_interface *mount, uintptr_t opCode, ... );
#ifndef NO_FILEOP_ALIAS
#  ifndef NO_OPEN_MACRO
# define open(a,...) sack_iopen(0,a,##__VA_ARGS__)
# define set_eof(a)  sack_iset_eof(a)
#  endif
#ifdef WIN32
#if !defined( SACK_BAG_EXPORTS ) && !defined( BAG_EXTERNALS ) && !defined( FILESYSTEM_LIBRARY_SOURCE )
# define _lopen(a,...) sack_open(0,a,##__VA_ARGS__)
# define tell(a)      sack_tell(a)
# define lseek(a,b,c) sack_ilseek(a,b,c)
# define _llseek(a,b,c) sack_lseek(a,b,c)
# define HFILE HANDLE
# undef HFILE_ERROR
# define HFILE_ERROR INVALID_HANDLE_VALUE
# define creat(a,...)  sack_icreat( 0,a,##__VA_ARGS__ )
# define close(a)  sack_iclose(a)
# define OpenFile(a,b,c) sack_openfile(0,a,b,c)
# define _lclose(a)  sack_close(a)
# define read(a,b,c) sack_iread(a,b,c)
# define write(a,b,c) sack_iwrite(a,b,c)
# define _lread(a,b,c) sack_read(a,b,c)
# define _lwrite(a,b,c) sack_write(a,b,c)
# define _lcreat(a,b) sack_creat(0,a,b)
# define remove(a)   sack_unlink(0,a)
# define unlink(a)   sack_unlink(0,a)
#endif
#endif
 //NO_FILEOP_ALIAS
#endif
#ifdef __LINUX__
#define SYSPATHCHAR "/"
#else
#define SYSPATHCHAR "\\"
#endif
FILESYS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::filesys;
#endif
#endif
#ifdef __cplusplus_cli
#define Fopen( result, name, opts ) { char *tmp1 = CStrDup( name ); char *tmp2 = CStrDup( opts ); result = fopen( tmp1, tmp2 ); Deallocate( char *, tmp1 ); Deallocate( char *, tmp2 ); }
#if asdfasdlfkajsdflkj
#define fputs( msg, file ) { char *tmp = CStrDup( msg ); fputs( tmp, file ); Release( tmp ); }
#define unlink( name ) { char *tmp = CStrDup( name ); unlink( tmp ); Release( tmp ); }
#define rename( name1, name2 ) { char *tmp1 = CStrDup( name1 ); char *tmp2 = CStrDup( name2 ); rename( tmp1, tmp2 ); Release( tmp1 ); Release( tmp2 ); }
#define fprintf Fprintf
#endif
//int Fprintf( FILE *file, CTEXTSTR fmt, ... );
/*
using namespace Win32;
#define CreateEvent(a,b,c,d) Win32::Kernel::CreateEvent((SECURITY_ATTRIBUTES)a,b,c,d)
#define OpenEvent(a,b,c)     Win32::Kernel::OpenEvent(a,b,c)
#define Sleep(a)             Win32::Kernel::Sleep(a)
#define GetTickCount()       Win32::Kernel::GetTickCount()
#define GetCurrentProcessId() Win32::Kernel::GetCurrentProcessId()
#define GetCurrentThreadId()  Win32::Kernel::GetCurrentThreadId()
#define GetLastError()  Win32::Kernel::GetLastError()
#define SetEvent(a) Win32::Kernel::SetEvent(a)
#define ResetEvent(a) Win32::Kernel::ResetEvent(a)
#define CloseHandle(a) Win32::Kernel::CloseHandle(a)
#define WaitForSingleObject(a,b) Win32::Kernel::WaitForSingleObject(a,b)
#define PeekMessage(a,b,c,d,e)  Win32::User::PeekMessage(a,b,c,d,e)
#define DispatchMessage(a)   Win32::User::DispatchMessage(a)
#define GetModuleFileName(a,b) Win32::Kernel::GetModuleFileName(a,b)
*/
#if 0
typedef struct MyFile MYFILE;
MYFILE *Fopen( CTEXTSTR filename, CTEXTSTR mode );
int Fread( POINTER data, int count, int size, MYFILE *file );
int Fwrite( POINTER data, int count, int size, MYFILE *file );
int Fclose( MYFILE *file );
int Fseek( MYFILE *file, int64_t pos, int whence );
uint64_t Ftell( MYFILE *file );
MYFILE *Fdopen( int fd, CTEXTSTR mode );
int Ferror( MYFILE *file );
int Fflush( MYFILE *file );
int Rewind( MYFILE *file );
int Fputc( int c, MYFILE *file );
int Fgets( TEXTSTR buf, int buflen, MYFILE *file );
int Fputs( CTEXTSTR but, MYFILE *file );
int Unlink( CTEXTSTR filename );
int Rename( CTEXTSTR from, CTEXTSTR to );
#define rename Rename
#define unlink Unlink
#define FILE MYFILE
#define fopen Fopen
#define fseek Fseek
#define fclose Fclose
#define fprintf Fprintf
#define ftell Ftell
#define fread Fread
#define fwrite Fwrite
//#define fdopen Fdopen
#define ferror Ferror
#define fflush Fflush
#define rewind Rewind
#define fputc Fputc
#define fgets Fgets
#define fputs Fputs
#endif
#else
/* A macro which can be translated into microsoft so-called safe
   methods.                                                      */
#define Fopen( result, name, opts ) result = sack_fopen( 0, name, opts )
//#define MYFILE  FILE
//#define Fopen   fopen
//#define Fread   fread
//#define Fwrite  fread
//#define Fclose  fclose
//#define Fprintf fprintf
//#define Fseek   fseek
//#define Ftell   ftell
#endif
#endif
// end with a newline please.
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
// If you change this structure please change the public
// reference of this structure, and please, do hand-count
// the bytes to set there... so not include this file
// to get the size.  The size there should be the worst
// case - debug or release mode.
#ifdef NO_PRIVATE_DEF
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
	//PDATAQUEUE pPriorWaiters;
#ifdef DEBUG_CRITICAL_SECTIONS
	uint32_t bCollisions ;
	CTEXTSTR pFile;
	uint32_t  nLine;
#endif
};
typedef struct critical_section_tag CRITICALSECTION;
#endif
#ifdef __cplusplus
	}
}
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
PREFIX_PACKED struct malloc_chunk_tag
{
   // if 0 - block is free
	uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
	uint16_t dwPad;
#ifdef __64__
	uint32_t pad;
#endif
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
PREFIX_PACKED struct heap_chunk_tag
{
            // if 0 - block is free
	uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
	uint16_t dwPad;
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag * pRoot;
	DeclareLink( struct heap_chunk_tag );
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	}
}
#endif
#endif
#endif
#include <ctype.h>
#if defined __ANDROID__
#include <linux/ashmem.h>
#endif
#ifdef _MSC_VER
//>= 900
#include <crtdbg.h>
#include <new.h>
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
#endif
#ifdef __64__
#define CLEAR_MEMORY_TAG 0xDEADBEEFDEADBEEFULL
#define FREE_MEMORY_TAG 0xFACEBEADFACEBEADULL
#define LEAD_PROTECT_TAG 0xbabecafebabecafeULL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafebeefcafeULL
#else
#define CLEAR_MEMORY_TAG 0xDEADBEEFUL
#define FREE_MEMORY_TAG 0xFACEBEADUL
#define LEAD_PROTECT_TAG 0xbabecafeUL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafeUL
#endif
#ifdef g
#  undef g
#endif
#ifdef __64__
#  define makeULong(n) (~(n##ULL))
#else
#  define makeULong(n) (~(n##UL))
#endif
static uintptr_t masks[33] = { makeULong(0), makeULong(0), makeULong(1), 0
  // 4
                  , makeULong(3), 0, 0, 0
   // 8
	              , makeULong(7), 0, 0, 0, 0, 0, 0, 0
 // 16
	              , makeULong(15), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  // 32
	              , makeULong(31) };
#define BASE_MEMORY (POINTER)0x80000000
// golly allocating a WHOLE DOS computer to ourselves? how RUDE
#define SYSTEM_CAPACITY  g.dwSystemCapacity
#define MALLOC_CHUNK_SIZE(pData) ( (pData)?( ( ( (uint16_t*)(pData))[-1] ) + offsetof( MALLOC_CHUNK, byData ) ):0 )
//#define CHUNK_SIZE(pData) ( ( (pData)?( (uint16_t*)(pData))[-1]:0 ) +offsetof( CHUNK, byData ) ) )
#define CHUNK_SIZE ( offsetof( CHUNK, byData ) )
#define MEM_SIZE  ( offsetof( MEM, pRoot ) )
// using lower level syslog bypasses some allocation requirements...
//#undef lprintf
//#undef _lprintf
#ifndef NO_LOGGING
#  ifdef _DEBUG
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, FILELINE_FILELINEFMT f,_pFile,_nLine,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); } }
#    define ll__lprintf( a ) {const TEXTCHAR *_pFile = pFile; int _nLine = nLine; _lprintf2
#  else
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); } }
#    define ll__lprintf( a ) { _lprintf2
#  endif
#else
#  define lprintf( f,... )
#endif
// last entry in space tracking array will ALWAYS be
// another space tracking array (if used)
// (32 bytes)
typedef struct space_tracking_structure {
	PMEM pMem;
#ifdef _WIN32
	HANDLE  hFile;
	HANDLE  hMem;
#else
	struct {
		uint32_t bTemporary : 1;
	} flags;
	int hFile;
#endif
	uintptr_t dwSmallSize;
	DeclareLink( struct space_tracking_structure );
} SPACE, *PSPACE;
typedef struct space_pool_structure {
	DeclareLink( struct space_pool_structure );
	SPACE spaces[(4096 - sizeof( struct space_pool_structure * )
		- sizeof( struct space_pool_structure ** ))
		/ sizeof( SPACE )];
} SPACEPOOL, *PSPACEPOOL;
#define MAX_PER_BLOCK (4096 - sizeof( struct space_pool_structure *)	 - sizeof( struct space_pool_structure **) )	  / sizeof( SPACE )
#ifdef _WIN32
//(0x10000 * 0x1000) //256 megs?
#define FILE_GRAN g.si.dwAllocationGranularity
#else
#define FILE_GRAN g.pagesize
#endif
struct global_memory_tag {
 // basic OS block grabbed for allocation
	size_t dwSystemCapacity;
//#ifdef _DEBUG
// may define one or the other of these but NOT both
	int bDisableDebug;
	int bDisableAutoCheck;
	int bLogCritical;
	//#endif
	size_t nMinAllocateSize;
	int pagesize;
	int bLogAllocate;
	int bLogAllocateWithHold;
  // this option couldn't work; different block tracking methods are incompatible
	LOGICAL bCustomAllocer;
	LOGICAL bInit;
	LOGICAL allowLogging;
	PSPACEPOOL pSpacePool;
#ifdef _WIN32
	SYSTEM_INFO si;
#endif
 // don't add our tracking to ourselves...
	int InAdding;
 // set if anybody starts to DIG.
	uint32_t bMemInstanced;
	LOGICAL deadstart_finished;
	PMEM pMemInstance;
};
#ifdef __STATIC__
static struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
													, 0
													, 0
													, 0
													, 0
													, 0
																	  , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
#  define g (global_memory_data)
#else
#  ifdef _DEBUG
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 0
#    ifdef DEBUG_CRITICAL_SECTIONS
															, 1
#    else
															, 0
#    endif
															, 0
															, 0
															, 0
															, 0
															 , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  else
/* disable debug*/
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
 /* log crit */
 /* min alloc size */
															, 0, 0, 0
															, 0
															, 0
  // custom allocer
															, USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  endif
#define g global_memory_data
#endif
#ifndef NO_LOGGING
#  define ODSEx(s,pFile,nLine) SystemLogFL( s DBG_RELAY )
//#define ODSEx(s,pFile,nLine) SystemLog( s )
#  define ODS(s)  SystemLog(s)
#else
#  define ODSEx(s,file,line)
#  define ODS(s)
#endif
#define MAGIC_SIZE sizeof( void* )
#ifdef __64__
#define BLOCK_TAG(pc)  (*(uint64_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 0123456789ABCDEF
#define TAG_FORMAT_MODIFIER "ll"
#define BLOCK_TAG_ID 0xefcdab8967452301LL
#else
#define BLOCK_TAG(pc)  (*(uint32_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 12345678
#define TAG_FORMAT_MODIFIER "l"
#define BLOCK_TAG_ID 0x78563412L
#endif
// file/line info are at the very end of the physical block...
// block_tag is at the start of the padding...
#define BLOCK_FILE(pc) (*(CTEXTSTR*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE*2))
#define BLOCK_LINE(pc) (*(int*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE))
#ifndef _WIN32
#endif
PRIORITY_PRELOAD( Deadstart_finished_enough, GLOBAL_INIT_PRELOAD_PRIORITY + 1 )
{
	g.deadstart_finished = 1;
	//g.bLogAllocate = 1;
}
PRIORITY_PRELOAD( InitGlobal, DEFAULT_PRELOAD_PRIORITY )
{
#ifndef __NO_OPTIONS__
	g.bLogCritical = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Log critical sections", g.bLogCritical, TRUE );
	g.bLogAllocate = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Enable Logging", g.bLogAllocate, TRUE );
	if( g.bLogAllocate )
		ll_lprintf( "Memory allocate logging enabled." );
	g.bLogAllocateWithHold = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Enable Logging Holds", g.bLogAllocateWithHold, TRUE );
	//USE_CUSTOM_ALLOCER = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Custom Allocator", USE_CUSTOM_ALLOCER, TRUE );
	g.bDisableDebug = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Disable Debug", !USE_DEBUG_LOGGING, TRUE );
#else
	//g.bLogAllocate = 1;
#endif
	g.nMinAllocateSize = 32;
	g.allowLogging = 1;
}
#if __GNUC__
//#  pragma message( "GNUC COMPILER")
#  ifndef __ATOMIC_RELAXED
#    define __ATOMIC_RELAXED 0
#  endif
#  ifndef __GNUC_VERSION
#    define __GNUC_VERSION ( __GNUC__ * 10000 ) + ( __GNUC_MINOR__ * 100 )
#  endif
#  if  ( __GNUC_VERSION >= 40800 ) || defined(__MAC__) || defined( __EMSCRIPTEN__ )
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
///  for some reason __GNUC_VERSION doesn't exist from android ?
#  elif defined __ARM__ || defined __ANDROID__
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
#  else
inline uint32_t DoXchg( volatile uint32_t* p, uint32_t val ) { __asm__( "lock xchg (%2),%0" :"=a"(val) : "0"(val), "c"(p) ); return val; }
inline uint64_t DoXchg64( volatile int64_t* p, uint64_t val ) { __asm__( "lock xchg (%2),%0" :"=a"(val) : "0"(val), "c"(p) ); return val; }
#    define XCHG( p,val) ( ( sizeof( val ) > sizeof( uint32_t ) )?DoXchg64( (volatile int64_t*)p, (uint64_t)val ):DoXchg( (volatile uint32_t*)p, (uint32_t)val ) )
#  endif
//#  endif
#else
#  define XCHG(p,val)  LockedExchange( p, val )
#endif
//-------------------------------------------------------------------------
#if !defined( HAS_ASSEMBLY ) || defined( __CYGWIN__ )
uint32_t  LockedExchange( volatile uint32_t* p, uint32_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if ( defined( _WIN32 ) || defined( WIN32 ) ) && !defined( __ANDROID__ )
#  if !defined(_MSC_VER)
	return InterlockedExchange( (volatile LONG *)p, val );
#  else
	//return _InterlockedExchange_HLEAcquire( (volatile long*)p, val );
	return _InterlockedExchange( (volatile long*)p, val );
	// windows wants this as a LONG not ULONG
	//return InterlockedExchange( (volatile LONG *)p, val );
#  endif
#else
 //&& !( defined __ARM__ || defined __ANDROID__ )
#  if ( defined( __LINUX__ ) )
	return XCHG( p, val );
	//   return __atomic_exchange_n(p,val,__ATOMIC_RELAXED);
#  else
	{
		// swp is the instruction....
		uint32_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
uint32_t LockedIncrement( volatile uint32_t* p ) {
#ifdef _WIN32
	return InterlockedIncrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_add_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint32_t LockedDecrement( volatile uint32_t* p ) {
#ifdef _WIN32
	return InterlockedDecrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_sub_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint64_t  LockedExchange64( volatile uint64_t* p, uint64_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if defined WIN32 && !defined __ANDROID__
#ifdef _MSC_VER
#ifdef __64__
	uint64_t prior = (uint64_t)InterlockedExchange64( (volatile __int64 *)p, (int64_t)val );
#else
	// because the value is a LONG (signed) it has to be made unsigned of the same lenght (ULONG) then extended (uint64_t).
	// otherwise the sign extension was a bug.
	uint64_t prior = (uint64_t)(ULONG)InterlockedExchange( (DWORD*)p, (DWORD)val ) | ((uint64_t)InterlockedExchange( ((DWORD*)p) + 1, (DWORD)(val >> 32) ) << 32);
#endif
#else
	uint64_t prior = InterlockedExchange( (volatile LONG*)p, (int32_t)val ) | InterlockedExchange( ((volatile LONG*)p) + 1, (uint32_t)(val >> 32) );
#endif
	return prior;
#else
#  if defined __GNUC__
#     if !defined( __ANDROID__ ) || ( ANDROID_NDK_TARGET_PLATFORM > 16 )
//__atomic_exchange_n(p,val,__ATOMIC_RELAXED);
	return XCHG( p, val );
#else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#endif
#  else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
#endif
//-------------------------------------------------------------------------
#ifdef DEBUG_CRITICAL_SECTIONS
#if 0
static void DumpSection( PCRITICALSECTION pcs )
{
	ll_lprintf( "Critical Section....." );
	ll_lprintf( "------------------------------" );
	ll_lprintf( "Update: %08x", pcs->dwUpdating );
	ll_lprintf( "Current Process: %16" _64fx, pcs->dwThreadID );
	ll_lprintf( "Next Process:    %16" _64fx, pcs->dwThreadWaiting );
	ll_lprintf( "Last update: %s(%d)", pcs->pFile ? pcs->pFile : "unknown", pcs->nLine );
}
#endif
#endif
#ifdef __cplusplus
 // namespace memory {
}
 // begin timer namespace
	namespace timers {
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
		uint32_t  CriticalSecOwners( PCRITICALSECTION pcs )
		{
			return pcs->dwLocks;
		}
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		int32_t  EnterCriticalSecNoWaitEx( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS )
		{
			THREAD_ID dwCurProc;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )("Attempt enter critical Section %" _64fx " %" _64fx " %" _64fx " %08" _32fx
					, pcs->dwThreadID
					, pcs->dwThreadWaiting
					, (prior?(*prior):-1)
					, pcs->dwLocks);
#  endif
#endif
			// need to aquire lock on section...
			// otherwise our old mechanism allowed an enter in another thread
			// to falsely identify the section as its own while the real owner
			// tried to exit...
			if( XCHG( &pcs->dwUpdating, 1 ) )
				return -1;
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				// section is unowned...
				if( pcs->dwThreadWaiting )
				{
					// someone was waiting for it...
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( prior ) {
							if( !(*prior) ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )("waiter is not myself... this is more recent than him... claim now. %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// this would stack me on top anyway so just allow the waitier to keep waiting....
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
								pcs->pFile[pcs->nPrior] = pFile;
								pcs->nLine[pcs->nPrior] = nLine;
#  else
								pcs->pFile[pcs->nPrior] = __FILE__;
								pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
								pcs->nLineCS[pcs->nPrior] = __LINE__;
								pcs->isLock[pcs->nPrior] = 1;
								pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
								pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )("waiter is not myself... AND am in stack of waiter. %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// prior is set, so someone has set their prior to me....
								pcs->dwUpdating = 0;
								return 0;
							}
						}
						else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
							ll__lprintf( DBG_RELAY )("Waiter which is quick-wait does not sleep; claiming section... %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
							pcs->pFile[pcs->nPrior] = pFile;
							pcs->nLine[pcs->nPrior] = nLine;
#  else
							pcs->pFile[pcs->nPrior] = __FILE__;
							pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
							pcs->nLineCS[pcs->nPrior] = __LINE__;
							pcs->isLock[pcs->nPrior] = 1;
							pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
							pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						}
					}
 //  waiting is me
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						ll_lprintf( "@@@ Woke up after waiting, set prior waiter as next waiter... %" _64fx, prior ? (*prior) : -1LL );
#endif
						if( prior && (*prior) ) {
							if( (*prior) == 1 ) {
								pcs->dwThreadWaiting = 0;
							}
							else
								pcs->dwThreadWaiting = (*prior);
							(*prior) = 0;
						}
						else
							pcs->dwThreadWaiting = 0;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
					}
				}
				else {
					if( prior && *prior ) {
						// shouldn't happen, if there's no waiter set, then there shouldn't be a prior.
						if( *prior != 1 )
							DebugBreak();
					}
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
					ll_lprintf( "Claimed critical section." );
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
					pcs->pFile[pcs->nPrior] = pFile;
					pcs->nLine[pcs->nPrior] = nLine;
#  else
					pcs->pFile[pcs->nPrior] = __FILE__;
					pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
					pcs->nLineCS[pcs->nPrior] = __LINE__;
					pcs->isLock[pcs->nPrior] = 1;
					pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
					pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				}
 // claim the section and return success
				pcs->dwThreadID = dwCurProc;
				pcs->dwLocks = 1;
				pcs->dwUpdating = 0;
				return 1;
			}
			else if( dwCurProc == pcs->dwThreadID )
			{
				// otherwise 1) I won the thread already... (threadID == me )
				pcs->dwLocks++;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( "Locks are %08" _32fx, pcs->dwLocks );
#    endif
				if( (pcs->dwLocks & 0xFFFFF) > 1 )
				{
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
					if( g.bLogCritical > 0 && g.bLogCritical < 2 )
						_xlprintf( 1 DBG_RELAY )("!!!!  %p  Multiple Double entry! %" _32fx, pcs, pcs->dwLocks);
#    endif
				}
#  endif
#  ifdef _DEBUG
				pcs->pFile[pcs->nPrior] = pFile;
				pcs->nLine[pcs->nPrior] = nLine;
#  else
				pcs->pFile[pcs->nPrior] = __FILE__;
				pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
				pcs->nLineCS[pcs->nPrior] = __LINE__;
				pcs->isLock[pcs->nPrior] = 1;
				pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
				pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				pcs->dwUpdating = 0;
				return 1;
			}
			//if( !(AND_SECTION_LOGGED_WAIT(pcs->dwLocks)) )
			{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
				pcs->dwLocks |= SECTION_LOGGED_WAIT;
				if( g.bLogCritical )
					ll_lprintf( "Waiting on critical section owned by %s(%d) %08lx %." _64fx, (pcs->pFile) ? (pcs->pFile) : "Unknown", pcs->nLine, pcs->dwLocks, pcs->dwThreadID );
#endif
			}
			// if the prior is wanted to be saved...
			if( prior )
			{
				if( *prior )
				{
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( !pcs->dwThreadWaiting ) {
							ll_lprintf( "@@@ Someone stole the critical section that we were wiating on before we reentered. fail. %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
							DebugBreak();
							// go back to sleep again.
							pcs->dwThreadWaiting = dwCurProc;
						}
						else {
							if( (*prior) == pcs->dwThreadWaiting ) {
								ll_lprintf( "prior is thread wiaiting (normal?!) %" _64fx " %" _64fx, pcs->dwThreadWaiting, *prior );
								DebugBreak();
								(*prior) = 0;
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll_lprintf( "Someone stole the critical section that we were wiating on before we reentered. fail. %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
#endif
							}
						}
						// assume that someone else kept our waiting ID...
						// cause we're not the one waiting, and we have someone elses ID..
						// we are awake out of order..
						pcs->dwUpdating = 0;
						return 0;
					}
					else {
						// waiting is the current threadproc; but someone claimed the section ahead of this.
					}
				}
				else if( pcs->dwThreadWaiting != dwCurProc )
				{
					if( pcs->dwThreadWaiting ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( "@@@ Setting prior to % " _64fx " and prior was %" _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = pcs->dwThreadWaiting;
					}
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( "@@@ Setting prior to % " _64fx " and prior was %" _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = 1;
					}
					pcs->dwThreadWaiting = dwCurProc;
				}
			}
			else
			{
				// else no prior... so don't set the dwthreadwaiting...
			}
			pcs->dwUpdating = 0;
			return 0;
		}
#endif
		//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		static LOGICAL LeaveCriticalSecNoWakeEx( PCRITICALSECTION pcs DBG_PASS )
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSecNoWakeEx( pcs DBG_SRC )
		{
			THREAD_ID dwCurProc;
			while( XCHG( &pcs->dwUpdating, 1 ) )
				Relinquish();
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
#  ifdef LOG_DEBUG_CRITICAL_SECTIONS
#    ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )("Locked %p for leaving...", pcs);
#    endif
#  endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( DBG_FILELINEFMT "Leaving a blank critical section" DBG_RELAY );
				DebugBreak();
				//while( 1 );
				pcs->dwUpdating = 0;
				return FALSE;
			}
#ifdef DEBUG_CRITICAL_SECTIONS
			//if( g.bLogCritical > 1 )
			// ll_lprintf( DBG_FILELINEFMT ( "Leaving %" _64fx"x %" _64fx"x %p" ) DBG_RELAY ,pcs->dwThreadID, dwCurProc, pcs );
#endif
			if( pcs->dwThreadID == dwCurProc )
			{
				pcs->dwLocks--;
				if( AND_SECTION_LOGGED_WAIT(pcs->dwLocks) )
				{
					if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
					{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 0;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						pcs->dwLocks = 0;
#endif
						pcs->dwThreadID = 0;
						pcs->dwUpdating = 0;
 // allow whoever was waiting to go now...
						Relinquish();
						return TRUE;
					}
				}
				else
				{
					if( !pcs->dwLocks ) {
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						pcs->dwThreadID = 0;
					}
				}
				// don't wake the prior (if there is one sleeping)
				// pcs->dwThreadID = 0;
			}
			else
			{
#ifdef DEBUG_CRITICAL_SECTIONS
				{
					_xlprintf( 0 DBG_RELAY )("Sorry - you can't leave a section owned by %" _64fx " %08lx %s(%d)..."
						, pcs->dwThreadID
						, pcs->dwLocks
						, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : "Unknown", pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]);
					DebugBreak();
				}
#else
				lprintf( "Sorry - you can't leave a section you don't own..." );
				DebugBreak();
#endif
				pcs->dwUpdating = 0;
				return FALSE;
			}
			// allow other locking threads immediate access to section
			// but I know when that happens - since the waiting process
			// will flag - SECTION_LOGGED_WAIT
			pcs->dwUpdating = 0;
			return TRUE;
		}
#else
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSection(pcs)
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
		void  InitializeCriticalSec( PCRITICALSECTION pcs )
		{
			memset( pcs, 0, sizeof( CRITICALSECTION ) );
			return;
		}
#endif
#ifdef __cplusplus
 // namespace timers {
	}
 // resume memory namespace
	namespace memory {
#endif
//-------------------------------------------------------------------------
#ifdef _DEBUG
 // last values from getmemstats...
static uint32_t dwBlocks;
static uint32_t dwFreeBlocks;
static uint32_t dwAllocated;
static uint32_t dwFree;
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
static void DoCloseSpace( PSPACE ps, int bFinal );
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
LOGICAL OpenRootMemory()
{
	uintptr_t size = sizeof( SPACEPOOL );
	uint32_t created;
	char spacename[32];
	if( g.pSpacePool != NULL )
	{
		// if local already has something, just return.
		return FALSE;
	}
#ifdef DEBUG_GLOBAL_REGISTRATION
	ll_lprintf( "Opening space..." );
#endif
#ifdef WIN32
	snprintf( spacename, sizeof( spacename ), "memory:%" _32fx, GetCurrentProcessId() );
#else
	snprintf( spacename, sizeof( spacename ), "memory:%08X", getpid() );
#endif
	// hmm application only shared space?
	// how do I get that to happen?
#ifdef __STATIC_GLOBALS__
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( NULL, NULL, 0, &size, &created );
#else
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( spacename, NULL, 0, &size, &created );
#endif
	// I myself must have a global space, which is kept sepearte from named spaces
	// but then... blah
	return created;
}
#endif
// hmm this runs
PRIORITY_ATEXIT(ReleaseAllMemory,ATEXIT_PRIORITY_SHAREMEM)
{
#if defined( __SKIP_RELEASE_OPEN_SPACES__ ) || defined( __NO_MMAP__ )
	// actually, under linux, it releases /tmp/.shared files.
	//ll_lprintf( "No super significant reason to release all memory blocks?" );
	//ll_lprintf( "Short circuit on memory shutdown." );
	return;
#else
	// need to try and close /tmp/.shared region files...  so we only close
	// temporary spaces
	PSPACEPOOL psp;
	PSPACE ps;
	while( ( psp = g.pSpacePool ) )
	{
		int i;
		// I didn't allocate at the root; someone else is responsible.
		if( psp->me != &g.pSpacePool )
			break;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			ps = psp->spaces + i;
			if( ps->pMem )
			{
				/*
				* if we do this, then logging will attempt to possibly use memory which was allocated from this?
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					ll_lprintf( "Space: %p mem: %p-%p", ps, ps->pMem, (uint8_t*)ps->pMem + ps->dwSmallSize );
					ll_lprintf( "Closing tracked space..." );
				}
#endif
*/
#ifndef _WIN32
				if( ps->flags.bTemporary )
#endif
					DoCloseSpace( ps, TRUE );
			}
		}
		if( !(*psp->me) )
			break;
		if( ( (*psp->me) = psp->next ) )
			psp->next->me = psp->me;
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		//ll_lprintf( "unmaping space tracking structure..." );
		munmap( ps, MAX_PER_BLOCK * sizeof( SPACE ) );
		//close( (int)ps->pMem );
		//if( ps->hFile >= 0 )
		//	close( ps->hFile );
#endif
	}
#endif
	g.bInit = FALSE;
}
//------------------------------------------------------------------------------------------------------
void InitSharedMemory( void )
{
#ifndef __NO_MMAP__
	if( !g.bInit )
	{
	// this would be really slick to do
	// especially in the case where files have been used
	// to back storage...
	// so please do make releaseallmemory smarter and dlea
	// only with closing those regions which have a file
		// backing, espcecially those that are temporary chickens.
		//atexit( ReleaseAllMemory );
#ifdef _WIN32
		GetSystemInfo( &g.si );
#else
		g.pagesize = sysconf(_SC_PAGESIZE);
#endif
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( "CHUNK: %d  MEM:%d", CHUNK_SIZE(0), MEM_SIZE );
#endif
  // onload was definatly a zero.
		g.bInit = TRUE;
		{
			if( OpenRootMemory() )
			{
				MemSet( g.pSpacePool, 0, sizeof( SPACEPOOL ) );
				g.pSpacePool->me = &g.pSpacePool;
#ifdef VERBOSE_LOGGING
				if( !g.bDisableDebug )
					Log1( "Allocated Space pool %lu", dwSize );
#endif
			}
		}
	}
	else
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			ODS( "already initialized?" );
#endif
	}
#endif
}
//------------------------------------------------------------------------------------------------------
// private
#ifndef __NO_MMAP__
static PSPACE AddSpace( PSPACE pAddAfter
#if defined( WIN32 ) || defined( __CYGWIN__ )
							, HANDLE hFile
							, HANDLE hMem
#else
							, int hFile
							, int hMem
#endif
							, POINTER pMem, uintptr_t dwSize, int bLink )
{
	PSPACEPOOL psp;
	PSPACEPOOL _psp = NULL;
	PSPACE ps;
	int i;
	if( !g.pSpacePool || g.InAdding )
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( "No space pool(%p) or InAdding(%d)", g.pSpacePool, g.InAdding );
#endif
		return NULL;
	}
	g.InAdding = 1;
	//_ps = NULL;
	psp = g.pSpacePool;
Retry:
	do {
		ps = psp->spaces;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			if( !ps[i].pMem )
			{
				ps += i;
				break;
			}
		}
		if( i == (MAX_PER_BLOCK-1) )
		{
			_psp = psp;
			psp = psp->next;
		}
		else
			break;
	} while( psp );
	if( !psp )
	{
		//DebugBreak(); // examine conditions for allocating new space block...
		dwSize = sizeof( SPACEPOOL );
		if( _psp )
		{
			psp = _psp->next = (PSPACEPOOL)OpenSpace( NULL, NULL, &dwSize );
			MemSet( psp, 0, dwSize );
			psp->me = &_psp->next;
		}
		goto Retry;
	}
	//Log7( "Managing space (s)%p (pm)%p (hf)%08" _32fx " (hm)%08" _32fx " (sz)%" _32f " %08" _32fx "-%08" _32fx ""
	//				, ps, pMem, (uint32_t)hFile, (uint32_t)hMem, dwSize
	//				, (uint32_t)pMem, ((uint32_t)pMem + dwSize)
	//				);
	ps->pMem = (PMEM)pMem;
	// okay yes I made this line ugly.
	ps->hFile =
#ifdef _WIN32
					(HANDLE)
#endif
								hFile;
#ifdef _WIN32
	ps->hMem = hMem;
#endif
	ps->dwSmallSize = dwSize;
	/*
	if( bLink )
	{
		while( AddAfter && AddAfter->next )
			AddAfter = AddAfter->next;
		//Log2( "Linked into space...%p after %p ", ps, AddAfter );
		if( AddAfter )
		{
			ps->me = &AddAfter->next;
			AddAfter->next = ps;
		}
		  ps->next = NULL;
	}
	*/
	g.InAdding = 0;
	return ps;
}
//------------------------------------------------------------------------------------------------------
PSPACE FindSpace( POINTER pMem )
{
	PSPACEPOOL psp;
	INDEX idx;
	for( psp = g.pSpacePool;psp; psp = psp->next)
		for( idx = 0; idx < MAX_PER_BLOCK; idx++ )
			if( psp->spaces[idx].pMem == pMem )
				return psp->spaces + idx;
	return NULL;
}
//------------------------------------------------------------------------------------------------------
static void DoCloseSpace( PSPACE ps, int bFinal )
{
	if( ps )
	{
		//Log( "Closing a space..." );
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		munmap( ps->pMem, ps->dwSmallSize );
		if( ps->flags.bTemporary && (ps->hFile >= 0) )
		{
			if( bFinal )
			{
				char file[256];
				char fdname[64];
				snprintf( fdname, sizeof(fdname), "/proc/self/fd/%d", (int)ps->hFile );
				file[readlink( fdname, file, sizeof( file ) )] = 0;
				remove( file );
			}
			close( (int)ps->hFile );
		}
#endif
		MemSet( ps, 0, sizeof( SPACE ) );
	}
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpaceEx ( POINTER pMem, int bFinal )
{
	DoCloseSpace( FindSpace( pMem ), bFinal );
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpace ( POINTER pMem )
{
	DoCloseSpace( FindSpace( pMem ), TRUE );
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  GetSpaceSize ( POINTER pMem )
{
	PSPACE ps;
	ps = FindSpace( pMem );
	if( ps )
		return ps->dwSmallSize;
	return 0;
}
#endif
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
uintptr_t GetFileSize( int fd )
{
	uintptr_t len = lseek( fd, 0, SEEK_END );
	lseek( fd, 0, SEEK_SET );
	return len;
}
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
 POINTER  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize, uint32_t* bCreated )
{
	POINTER pMem = NULL;
#ifdef USE_SIMPLE_LOCK_ON_OPEN
	static uint32_t bOpening;
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	static CRITICALSECTION cs;
	static int first = 1;
#endif
	int readonly = FALSE;
	if( !dwSize ) return NULL;
	if( !g.bInit )
	{
		//ODS( "Doing Init" );
		InitSharedMemory();
	}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		if( first )
		{
			InitializeCriticalSection( &cs );
			first = 0;
		}
		while( !EnterCriticalSecNoWait( &cs, NULL ) )
			Relinquish();
	}
#else
	while( XCHG( &bOpening, 1 ) )
		Relinquish();
#endif
	{
#ifdef __LINUX__
		char *filename = NULL;
		int fd = -1;
		int bTemp = FALSE;
		int exists = FALSE;
		if( !pWhat && !pWhere)
		{
#ifndef MAP_ANONYMOUS
#define MAP_ANONYMOUS 0x20
#endif
			pMem = mmap( 0, *dwSize
						 , PROT_READ|PROT_WRITE
						 , MAP_SHARED|MAP_ANONYMOUS
						 ,
#ifdef __QNX__
  // QNX Note; NOFD = -1
							NOFD
 // other systems were quite happy to have a 0 here for the handle.
#else
							0
#endif
						  , 0 );
			if( pMem == (POINTER)-1 )
			{
				if( errno == ENODEV ) {
					pMem = malloc( *dwSize );
				} else {
				ll_lprintf( "Something bad about this region sized %" _PTRSZVALfs "(%d)", *dwSize, errno );
				DebugBreak();
				}
			}
			if( pMem != (POINTER)-1 )
			{
				//ll_lprintf( "Clearing anonymous mmap %p %" _size_f "", pMem, *dwSize );
				MemSet( pMem, 0, *dwSize );
			}
		}
 // name doesn't matter, same file cannot be called another name
		else if( pWhere )
		{
			filename = (char*)pWhere;
		 }
		else if( pWhat )
		{
#ifndef __STATIC_GLOBALS__
			int len;
		         char tmpbuf[256];
#ifdef __ANDROID__
			//if( !IsPath( "./tmp" ) )
			//	if( !MakePath( "./tmp" ) )
			//		ll_lprintf( "Failed to create a temporary space" );
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "./tmp.shared.%s", pWhat );
#else
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "/tmp/.shared.%s", pWhat );
#endif
			bTemp = TRUE;
#endif
		}
		//ll_lprintf( "Open Space: %s", filename?filename:"anonymous" );
		if( !pMem && filename )
		{
#ifdef __ANDROID__
			//fd = ashmem_create_region( filename , size );
			if( pWhat )
			{
				fd = open(filename, O_RDWR);
				if (fd < 0 )
				{
					int ret;
					if( !(*dwSize ) )
					{
						ll_lprintf( "Region didn't exist... and no size... return" );
						return NULL;
					}
#   ifdef DEBUG_SHARED_REGION_CREATE
					ll_lprintf( "Shared region didn't already exist...: %s", filename );
#   endif
					fd = open("/dev/ashmem", O_RDWR);
					if( fd < 0 )
					{
						ll_lprintf( "Failed to open core device..." );
						return NULL;
					}
					if( bCreated )
						(*bCreated) = 1;
 // skip 11 for the "/dev/ashmem/"
					ret = ioctl(fd, ASHMEM_SET_NAME, filename + 12 );
					if (ret < 0)
					{
						ll_lprintf( "Failed to set the name of ashmem region: %s", filename + 12 );
						//							goto error;
					}
					ret = ioctl(fd, ASHMEM_SET_SIZE, (*dwSize) );
					if (ret < 0)
					{
						ll_lprintf( "Failed to set IOCTL size to %d", (*dwSize) );
						//goto error;
					}
					/*
					 {
						// unpin; pages will be pined to start (I think)
						struct ashmem_pin pin = {
							.offset = 0,
							.len    = (*dwSize)
						};
						ret = ioctl(fd, ASHMEM_UNPIN, &pin);
					}
					*/
				}
				else
				{
					if( bCreated )
						(*bCreated) = 1;
				}
			}
			else
#endif
			{
				mode_t prior;
				if( bCreated )
					(*bCreated) = 1;
				prior = umask( 0 );
				fd = open( filename, O_RDWR|O_CREAT|O_EXCL, 0600 );
				umask(prior);
			}
			if( fd == -1 )
			{
				//ll_lprintf( "open is %d %s %d", errno, filename, prior );
				// if we didn't create the file...
				// then it can't be marked as temporary...
				bTemp = FALSE;
				if( GetLastError() == EEXIST )
				{
					exists = TRUE;
					fd = open( filename, O_RDWR );
					bTemp = FALSE;
					if( bCreated )
						(*bCreated) = 0;
				}
				if( fd == -1 )
				{
					readonly = TRUE;
					fd = open( filename, O_RDONLY );
				}
				if( fd == -1 )
				{
					Log2( "Sorry - failed to open: %d %s"
						, errno
						, filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
			}
			if( exists )
			{
				if( GetFileSize( fd ) < (uintptr_t)*dwSize )
				{
					// expands the file...
					ftruncate( fd, *dwSize );
					//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				}
				else
				{
					// expands the size requested to that of the file...
					(*dwSize) = GetFileSize( fd );
				}
			}
			else
			{
				if( !*dwSize )
				{
					// can't create a 0 sized file this way.
 // not zero.
					(*dwSize) = 1;
					close( fd );
					unlink( filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
				//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				ftruncate( fd, *dwSize );
			}
			pMem = mmap( 0, *dwSize
			          , PROT_READ|(readonly?(0):PROT_WRITE)
			          , MAP_SHARED|((fd<0)?MAP_ANONYMOUS:0)
			          , fd, 0 );
			if( !exists && pMem )
			{
				MemSet( pMem, 0, *dwSize );
			}
		}
		if( pMem )
		{
			PSPACE ps = AddSpace( NULL, fd, 0, pMem, *dwSize, TRUE );
			if( ps )
				ps->flags.bTemporary = bTemp;
		}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = FALSE;
#endif
		//if(filename)Release( filename );
		return pMem;
#elif defined( _WIN32 )
#ifndef UNDER_CE
		LOGICAL didCreate = FALSE;
		HANDLE hFile;
		HANDLE hMem = NULL;
		*dwSize = ( ( (*dwSize) + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
		if( !pWhat && !pWhere )
		{
			//ll_lprintf( "ALLOCATE %" _64fx"d", (*dwSize)>>32, 0 );
			hMem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL
											, PAGE_READWRITE
											|SEC_COMMIT
#if __64__
 // dwSize is sometimes 64 bit... this should be harmless
											, (*dwSize)>>32
											, (*dwSize) & (0xFFFFFFFF)
#else
											, 0
											, (*dwSize)
#endif
 // which should be NULL... but is consistant
											, pWhat );
			if( !hMem )
			{
				//ll_lprintf( "Failed to allocate pagefile memory?! %p %d", *dwSize, GetLastError() );
				{
					POINTER p = malloc( *dwSize );
					//ll_lprintf(" but we could allocate it %p", p  );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return p;
				}
			}
			else
			{
			// created and this size is right...
				if( bCreated )
					(*bCreated) = TRUE;
			}
		}
		else if( pWhat )
		{
			hMem = OpenFileMapping( FILE_MAP_READ|FILE_MAP_WRITE
										, FALSE
										, pWhat );
			if( hMem )
			{
				if( bCreated )
					(*bCreated) = FALSE;
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Failed to open region named %s %d", pWhat, GetLastError() );
#endif
  // don't continue... we're expecting open-existing behavior
				if( (*dwSize) == 0 )
				{
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return FALSE;
				}
			}
		}
		hFile = INVALID_HANDLE_VALUE;
		// I would have hmem here if the file was validly opened....
		if( !hMem )
		{
			hFile = CreateFile( pWhere, GENERIC_READ|GENERIC_WRITE
									,FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
 // default security
									,NULL
									,(dwSize&&(*dwSize)) ? OPEN_ALWAYS : OPEN_EXISTING
 //|FILE_ATTRIBUTE_TEMPORARY
									,FILE_ATTRIBUTE_NORMAL
									//| FILE_FLAG_WRITE_THROUGH
									//| FILE_FLAG_NO_BUFFERING
									// must access on sector bournds
									// must read complete sectors
									//| FILE_FLAG_DELETE_ON_CLOSE
									, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "Create file %s result %d", pWhere, hFile );
			ll_lprintf( "File result is %ld (error %ld)", hFile, GetLastError() );
#endif
			if( hFile == INVALID_HANDLE_VALUE )
			{
				readonly = 1;
				if( ( dwSize && (!(*dwSize )) ) && ( GetLastError() == ERROR_PATH_NOT_FOUND || GetLastError() == ERROR_FILE_NOT_FOUND ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "File did not exist, and we're not creating the file (0 size passed)" );
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return NULL;
				}
				hFile = CreateFile( pWhere, GENERIC_READ
										,FILE_SHARE_READ|FILE_SHARE_DELETE
 // default security
										,NULL
										,OPEN_ALWAYS
 //|FILE_ATTRIBUTE_TEMPORARY
										,FILE_ATTRIBUTE_NORMAL
										//| FILE_FLAG_WRITE_THROUGH
										//| FILE_FLAG_NO_BUFFERING
										// must access on sector bournds
										// must read complete sectors
										//| FILE_FLAG_DELETE_ON_CLOSE
										, NULL );
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Create file %s result %d", pWhere, hFile );
#endif
				if( hFile != INVALID_HANDLE_VALUE ) {
 // lie...
					SetLastError( ERROR_ALREADY_EXISTS );
				}
			}
			else {
 // lie...
				SetLastError( ERROR_ALREADY_EXISTS );
			}
			if( hFile == INVALID_HANDLE_VALUE )
			{
				// might still be able to open it by shared name; even if the file share is disabled
				readonly = 0;
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "file is still invalid(alreadyexist?)... new size is %d %d on %p", (*dwSize), FILE_GRAN, hFile );
#endif
 // is INVALID_HANDLE_VALUE, but is consistant
				hMem = CreateFileMapping( hFile
												, NULL
												, (readonly?PAGE_READONLY:PAGE_READWRITE)
												/*|SEC_COMMIT|SEC_NOCACHE*/
#ifdef __64__
												, (uint32_t)((*dwSize)>>32)
#else
												, 0
#endif
												, (uint32_t)(*dwSize)
												, pWhat );
				if( hMem )
				{
					if( bCreated )
						(*bCreated) = 1;
					goto isokay;
				}
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Sorry - Nothing good can happen with a filename like that...%s %d", pWhat, GetLastError());
#endif
					 //bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
			if( GetLastError() == ERROR_ALREADY_EXISTS )
			{
				LARGE_INTEGER lSize;
				GetFileSizeEx( hFile, &lSize );
			// mark status for memory... dunno why?
				// in theory this is a memory image of valid memory already...
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Getting existing size of region..." );
#endif
				if( SUS_LT( lSize.QuadPart, LONGLONG, (*dwSize), uintptr_t ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "Expanding file to size requested." );
#endif
					didCreate = 1;
					SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
					SetEndOfFile( hFile );
				}
				else
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "Setting size to size of file (which was larger.." );
#endif
					(*dwSize) = (uintptr_t)(lSize.QuadPart);
				}
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "New file, setting size to requested %d", *dwSize );
#endif
				SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
				SetEndOfFile( hFile );
				didCreate = 1;
			}
			if( bCreated )
				(*bCreated) = didCreate;
			//(*dwSize) = GetFileSize( hFile, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "%s Readonly? %d  hFile %d", pWhat, readonly, hFile );
#endif
			hMem = CreateFileMapping( hFile
											, NULL
											, (readonly?PAGE_READONLY:PAGE_READWRITE)
											/*|SEC_COMMIT|SEC_NOCACHE*/
											, 0, 0
											, pWhat );
			if( pWhat && !hMem )
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Create of mapping failed on object specified? %d %p", GetLastError(), hFile );
#endif
				(*dwSize) = 1;
				CloseHandle( hFile );
				//bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
		}
	isokay:
      /*
		if( !hMem )
		{
			pMem = VirtualAlloc( address, (*dwSize), 0 ,PAGE_READWRITE );
			if( !VirtualLock( pMem, (*dwSize ) ) )
            DebugBreak();
		}
		else
      */
		{
			pMem = MapViewOfFileEx( hMem
										, FILE_MAP_READ| ((readonly)?(0):(FILE_MAP_WRITE))
  // offset high, low
										, 0, 0
	 // size of file to map
										, 0
 // don't specify load location... irrelavent...
										, (POINTER)address );
		}
	if( !pMem )
	{
#ifdef DEBUG_OPEN_SPACE
		Log1( "Create view of file for memory access failed at %p", (POINTER)address );
#endif
		CloseHandle( hMem );
		if( hFile != INVALID_HANDLE_VALUE )
			CloseHandle( hFile );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = 0;
#endif
		return NULL;
	}
	else
	{
		if( bCreated && !(*bCreated) && ((*dwSize) == 0) )
		{
			MEMORY_BASIC_INFORMATION meminfo;
			VirtualQuery( pMem, &meminfo, sizeof( meminfo ) );
			(*dwSize) = meminfo.RegionSize;
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "Fixup memory size to %ld %s:%s(reported by system on view opened)"
					, *dwSize, pWhat?pWhat:"ANON", pWhere?pWhere:"ANON" );
#endif
		}
	}
	// store information about this
	// external to the space - do NOT
	// modify content of memory opened!
	AddSpace( NULL, hFile, hMem, pMem, *dwSize, TRUE );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		LeaveCriticalSecNoWake( &cs );
	}
#else
      bOpening = 0;
#endif
	return pMem;
#else
	if( bCreated )
		(*bCreated) = 1;
	return malloc( *dwSize );
#endif
#endif
	}
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpaceEx
 POINTER  OpenSpaceEx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize )
{
	uint32_t bCreated;
	return OpenSpaceExx( pWhat, pWhere, address, dwSize, &bCreated );
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpace
 POINTER  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize )
{
	return OpenSpaceEx( pWhat, pWhere, 0, dwSize );
}
#endif
//------------------------------------------------------------------------------------------------------
 int  InitHeap( PMEM pMem, uintptr_t dwSize )
{
	//pMem->dwSize = *dwSize - MEM_SIZE;
	// size of the PMEM block is all inclusive (from pMem(0) to pMem(dwSize))
	// do NOT need to substract the size of the tracking header
	// otherwise we would be working from &pMem->pRoot + dwSize
	if( pMem->dwSize )
	{
		if( pMem->dwHeapID != 0xbab1f1ea )
		{
			ll_lprintf( "Memory has content, and is NOT a heap!" );
			return FALSE;
		}
		ll_lprintf( "Memory was already initialized as a heap?" );
		return FALSE;
	}
#ifndef __NO_MMAP__
	if( !FindSpace( pMem ) )
	{
		//ll_lprintf( "space for heap has not been tracked yet...." );
		// a heap must be in the valid space pool.
		// it may not have come from a file, and will not have
		// a file or memory handle.
		AddSpace( NULL, 0, 0, pMem, dwSize, TRUE );
	}
#endif
	// the size passed is the full size of the memory, so we need to remove sizeof(MEM)
	// so there is room to track heap info at the start of the heap.
	dwSize -= sizeof( MEM );
	pMem->dwSize = dwSize;
	pMem->dwHeapID = 0xbab1f1ea;
	pMem->pFirstFree = NULL;
	pMem->dwFlags = 0;
	LinkThing( pMem->pFirstFree, pMem->pRoot );
	InitializeCriticalSec( &pMem->cs );
	pMem->pRoot[0].dwSize = dwSize - MEM_SIZE - CHUNK_SIZE;
	pMem->pRoot[0].dwPad = MAGIC_SIZE;
	pMem->pRoot[0].dwOwners = 0;
	pMem->pRoot[0].pRoot  = pMem;
	pMem->pRoot[0].pPrior = NULL;
#ifdef _DEBUG
	if( !g.bDisableDebug )
	{
#ifdef VERBOSE_LOGGING
		ll_lprintf( "Initializing %p %d"
				, pMem->pRoot[0].byData
				, pMem->pRoot[0].dwSize );
#endif
		MemSet( pMem->pRoot[0].byData, 0x1BADCAFE, pMem->pRoot[0].dwSize );
		BLOCK_TAG( pMem->pRoot ) = BLOCK_TAG_ID;
	}
	{
		pMem->pRoot[0].dwPad += 2*MAGIC_SIZE;
		BLOCK_FILE( pMem->pRoot ) = __FILE__;
		BLOCK_LINE( pMem->pRoot ) = __LINE__;
	}
#endif
	return TRUE;
}
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
PMEM DigSpace( TEXTSTR pWhat, TEXTSTR pWhere, uintptr_t *dwSize )
{
	PMEM pMem = (PMEM)OpenSpace( pWhat, pWhere, dwSize );
	if( !pMem )
	{
		// did reference BASE_MEMORY...
		ll_lprintf( "Create view of file for memory access failed at %p %p", pWhat, pWhere );
		CloseSpace( (POINTER)pMem );
		return NULL;
	}
#ifdef VERBOSE_LOGGING
	Log( "Go to init the heap..." );
#endif
	pMem->dwSize = 0;
#if USE_CUSTOM_ALLOCER
	InitHeap( pMem, *dwSize );
#endif
	return pMem;
}
//------------------------------------------------------------------------------------------------------
int ExpandSpace( PMEM pHeap, uintptr_t dwAmount )
{
	PSPACE pspace = FindSpace( (POINTER)pHeap ), pnewspace;
	PMEM pExtend;
	//ll_lprintf( "Expanding by %d %d", dwAmount );
	pExtend = DigSpace( NULL, NULL, &dwAmount );
	if( !pExtend )
	{
		ll_lprintf( "Failed to expand space by %" _PTRSZVALfs, dwAmount );
		return FALSE;
	}
	pnewspace = FindSpace( pExtend );
	if( pnewspace )
	{
		while( pspace && pspace->next )
			pspace = pspace->next;
		if( ( pspace->next = pnewspace ) )
		{
			pnewspace->me = &pspace->next;
		}
	}
	return TRUE;
}
#endif
//------------------------------------------------------------------------------------------------------
static PMEM InitMemory( void ) {
	uintptr_t MinSize = SYSTEM_CAPACITY;
	// generic internal memory, unnamed, unshared, unsaved
#ifndef __NO_MMAP__
	g.pMemInstance = DigSpace( NULL, NULL, &MinSize );
	if( !g.pMemInstance )
	{
		g.bMemInstanced = FALSE;
		ODS( "Failed to allocate memory - assuming fatailty at Allocation service level." );
		return NULL;
	}
#endif
	return g.pMemInstance;
}
//------------------------------------------------------------------------------------------------------
static PMEM GrabMemEx( PMEM pMem DBG_PASS )
#define GrabMem(m) GrabMemEx( m DBG_SRC )
{
	if( !pMem )
	{
		// use default heap...
		if( !XCHG( &g.bMemInstanced, TRUE ) )
			pMem = InitMemory();
		else
			return 0;
	}
	//ll_lprintf( "grabbing memory %p", pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		while( !TryEnterCriticalSection( &pMem->cs ) )
		{
			Relinquish();
		}
#else
		while( EnterCriticalSecNoWaitEx( &pMem->cs, NULL DBG_RELAY ) <= 0 )
		{
			Relinquish();
		}
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
	return pMem;
}
//------------------------------------------------------------------------------------------------------
static void DropMemEx( PMEM pMem DBG_PASS )
#define DropMem(m) DropMemEx( m DBG_SRC)
{
	if( !pMem )
		return;
	//ll_lprintf( "dropping memory %p", pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSection( &pMem->cs );
#else
		LeaveCriticalSecNoWakeEx( &pMem->cs DBG_RELAY );
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateAlignedEx( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS )
{
   // if a heap is passed, it's a private heap, and allocation is as normal...
	uint32_t dwAlignPad = 0;
	if( alignment ) {
		dwSize += (alignment - 1);
		dwAlignPad = (alignment - 1);
	}
	if( !pHeap && !USE_CUSTOM_ALLOCER )
	{
		PMALLOC_CHUNK pc;
		uintptr_t mask;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + alignment + dwSize + sizeof( pc->LeadProtect ) );
		if( !pc )
			DebugBreak();
		MemSet( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) );
		MemSet( pc->byData + dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) );
#else
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + dwSize );
#endif
		pc->dwOwners = 1;
		pc->dwSize = dwSize;
		pc->dwPad = dwAlignPad;
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate )
		{
			ll__lprintf(DBG_RELAY)( "alloc %p(%p) %" _PTRSZVALfs, pc, pc->byData, dwSize );
		}
#  endif
#endif
		if( alignment > (sizeof( masks ) / sizeof( masks[0] )) )
			mask = (~((uintptr_t)(alignment-1)));
		else
			mask = masks[alignment];
		if( alignment && ( (uintptr_t)pc->byData & ~mask) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & mask);
			//pc->dwPad = (uint16_t)( dwAlignPad - sizeof(uintptr_t) );
			// to_chunk_start is the last thing in chunk, so it's pre-allocated space
 /*pc->alignemnt = */
			((uint16_t*)(retval - sizeof(uint32_t)))[0] =alignment;
 /*pc->to_chunk_start = */
			((uint16_t*)(retval - sizeof(uint32_t)))[1] =(uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & mask) - (uintptr_t)pc->byData);
 //-V773
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
#if USE_CUSTOM_ALLOCER
	else
	{
		PHEAP_CHUNK pc;
		PMEM pMem, pCurMem = NULL;
		PSPACE pMemSpace;
		uint32_t dwPad = 0;
		uint32_t dwMin = 0;
		//ll__lprintf(DBG_RELAY)( "..." );
#ifdef _DEBUG
		if( !g.bDisableAutoCheck )
			GetHeapMemStatsEx(pHeap, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
 // no size is NO space!
		if( !dwSize )
		{
			return NULL;
		}
		// if memstats is used - memory could have been initialized there...
		// so wait til now to grab g.pMemInstance.
		if( !pHeap )
			pHeap = g.pMemInstance;
		pMem = GrabMem( pHeap );
#ifdef __64__
		dwPad = (((dwSize + 7) & 0xFFFFFFFFFFFFFFF8) - dwSize);
 // fix size to allocate at least _32s which
		dwSize += 7;
		dwSize &= 0xFFFFFFFFFFFFFFF8;
#else
		dwPad = (((dwSize + 3) & 0xFFFFFFFC) -dwSize);
 // fix size to allocate at least _32s which
		dwSize += 3;
		dwSize &= 0xFFFFFFFC;
#endif
#ifdef _DEBUG
		if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
		{
			dwPad += MAGIC_SIZE * 2;
 // pFile, nLine per block...
			dwSize += MAGIC_SIZE * 2;
									  //ll_lprintf( "Adding 8 bytes to block size..." );
		}
		if( !g.bDisableDebug )
		{
			dwPad += MAGIC_SIZE;
  // add a uint32_t at end to mark, and check for application overflow...
			dwSize += MAGIC_SIZE;
		}
		dwMin = dwPad;
#endif
		// re-search for memory should step long back...
	search_for_free_memory:
		for( pc = NULL, pMemSpace = FindSpace( pMem ); !pc && pMemSpace; pMemSpace = pMemSpace->next )
		{
			// grab the new memory (might be old, is ok)
			GrabMem( (PMEM)pMemSpace->pMem );
			// then drop old memory, don't need that anymore.
 // first time through, there is no current.
			if( pCurMem )
				DropMem( pCurMem );
			// then mark that this block is our current block.
			pCurMem = (PMEM)pMemSpace->pMem;
			//ll_lprintf( "region %p is now owned.", pCurMem );
			for( pc = pCurMem->pFirstFree; pc; pc = pc->next )
			{
 // if free block size is big enough...
				if( pc->dwSize >= dwSize )
				{
					// split block
 // must allocate it all.
					if( ( pc->dwSize - dwSize ) <= ( dwMin + CHUNK_SIZE + g.nMinAllocateSize ) )
					{
						pc->dwPad = (uint16_t)(dwPad + ( pc->dwSize - dwSize ));
						UnlinkThing( pc );
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
					else
					{
  // cleared, NEW, uninitialized block...
						PHEAP_CHUNK pNew;
						PHEAP_CHUNK next;
						next = (PHEAP_CHUNK)( pc->byData + pc->dwSize );
						pNew = (PHEAP_CHUNK)(pc->byData + dwSize);
						pNew->dwPad = 0;
						pNew->dwSize = ((pc->dwSize - CHUNK_SIZE) - dwSize);
#ifdef _DEBUG
						if( pNew->dwSize > 0x80000000 )
							DebugBreak();
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							pNew->dwPad += MAGIC_SIZE * 2;
						}
						if( !g.bDisableDebug )
						{
							pNew->dwPad += MAGIC_SIZE;
							BLOCK_TAG( pNew ) = BLOCK_TAG_ID;
						}
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							BLOCK_FILE( pNew ) = pFile;
							BLOCK_LINE( pNew ) = nLine;
						}
#endif
						pc->dwPad = (uint16_t)dwPad;
 // set old size?  this can wait until we have the block.
						pc->dwSize = dwSize;
						if( pc->dwSize & 0x80000000 )
							DebugBreak();
  // not beyond end of memory...
						if( (uintptr_t)next - (uintptr_t)pCurMem < (uintptr_t)pCurMem->dwSize )
							next->pPrior = pNew;
						pNew->dwOwners = 0;
						pNew->pRoot = pc->pRoot;
						pNew->pPrior = pc;
						// copy link...
						if( ( pNew->next = pc->next ) )
							pNew->next->me = &pNew->next;
						*( pNew->me = pc->me ) = pNew;
  // set owned block.
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
				}
			}
		}
		if( !pc )
		{
			if( dwSize < SYSTEM_CAPACITY )
			{
				if( ExpandSpace( pMem, SYSTEM_CAPACITY ) )
					goto search_for_free_memory;
			}
			else
			{
				// after 1 allocation, need a free chunk at end...
				// and let's just have a couple more to spaere.
				if( ExpandSpace( pMem, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE ) )
				{
#ifndef NO_LOGGING
					//ll__lprintf(DBG_RELAY)( "Creating a new expanded space... %" _size_fs, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE );
#endif
					goto search_for_free_memory;
				}
			}
			DropMem( pCurMem );
			pCurMem = NULL;
#ifdef _DEBUG
			if( !g.bDisableDebug )
				ODS( "Remaining space in memory block is insufficient.  Please EXPAND block.");
#endif
			DropMem( pMem );
			return NULL;
		}
 //|| !defined( __NO_WIN32API__ )
#if defined( _DEBUG )
		if( !g.bDisableDebug )
		{
			// set end of block tag(s).
			// without disabling memory entirely, blocks are
			// still tagged and trashed in debug mode.
			MemSet( pc->byData, CLEAR_MEMORY_TAG, pc->dwSize );
			BLOCK_TAG(pc) = BLOCK_TAG_ID;
		}
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			if( pc->dwPad < 16 )
				DebugBreak();
			BLOCK_FILE(pc) = pFile;
			BLOCK_LINE(pc) = nLine;
		}
#endif
		DropMem( pCurMem );
		DropMem( pMem );
		//#if DBG_AVAILABLE
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate && g.allowLogging )
		{
			_xlprintf( 2 DBG_RELAY )("Allocate : %p(%p) - %" _PTRSZVALfs " bytes", pc->byData, pc, pc->dwSize);
		}
#  endif
#endif
		//#endif
		if( alignment && ((uintptr_t)pc->byData & ~masks[alignment]) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]);
 /*pc->alignemnt =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[0] = alignment;
 /*pc->to_chunk_start =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[1] = (uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
#endif
	return NULL;
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateEx( PMEM pHeap, uintptr_t dwSize DBG_PASS ) {
	return HeapAllocateAlignedEx( pHeap, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
#undef AllocateEx
POINTER  AllocateEx ( uintptr_t dwSize DBG_PASS )
{
	return HeapAllocateAlignedEx( g.pMemInstance, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( dest, source, minSize );
		if( minSize < size )
			MemSet( ((uint8_t*)dest) + minSize, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( pHeap, source, size, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapPreallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( (uint8_t*)dest + (size-minSize), source, minSize );
		if( minSize < size )
			MemSet( dest, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
POINTER  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS ){
	return HeapPreallocateAlignedEx( pHeap, source, size, AlignOfMemBlock(source) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  HeapMoveEx( PMEM pNewHeap, POINTER source DBG_PASS )
{
	return HeapReallocateAlignedEx( pNewHeap, source, SizeOfMemBlock( source ), AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  ReallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  PreallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapPreallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
static void Bubble( PMEM pMem )
{
	// handle sorting free memory to be least signficant first...
	PCHUNK temp, next;
	PCHUNK *prior;
	prior = &pMem->pFirstFree;
	temp = *prior;
	if( !temp )
		return;
	next = temp->next;
	while( temp && next )
	{
		if( (uintptr_t)next < (uintptr_t)temp )
		{
			UnlinkThing( temp );
			UnlinkThing( next );
			LinkThing( *prior, next );
			LinkThing( next->next, temp );
			prior = &next->next;
			temp = *prior;
			next = temp->next;
		}
		else
		{
			prior = &temp->next;
			temp = *prior;
#ifdef _DEBUG
			if( temp->next == temp )
			{
				ll_lprintf( "OOps this block is way bad... how'd that happen? %s(%d)", BLOCK_FILE( temp ), BLOCK_LINE( temp ) );
				DebugBreak();
			}
#endif
			next = temp->next;
		}
	}
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  SizeOfMemBlock ( CPOINTER pData )
{
	if( pData )
	{
		if( USE_CUSTOM_ALLOCER )
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
			return pc->dwSize - pc->dwPad;
		}
		else
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData));
			return pc->dwSize - pc->dwPad;
		}
	}
	return 0;
}
//------------------------------------------------------------------------------------------------------
uint16_t  AlignOfMemBlock( CPOINTER pData )
{
	if( pData )
	{
		return (((uint16_t*)pData)[-2]);
	}
	return 0;
 }
//------------------------------------------------------------------------------------------------------
 POINTER  MemDupEx ( CPOINTER thing DBG_PASS )
{
	uintptr_t size = SizeOfMemBlock( thing );
	POINTER result;
	result = HeapAllocateAlignedEx( g.pMemInstance, size, AlignOfMemBlock( thing ) DBG_RELAY );
	MemCpy( result, thing, size );
	return result;
}
#undef MemDup
 POINTER  MemDup (CPOINTER thing )
{
	return MemDupEx( thing DBG_SRC );
}
//------------------------------------------------------------------------------------------------------
POINTER ReleaseEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
#ifndef __NO_MMAP__
		// how to figure if it's a CHUNK or a HEAP_CHUNK?
		if( !( ((uintptr_t)pData) & 0x3FF ) )
		{
			// system allocated blocks ( OpenSpace ) will be tracked as spaces...
			// and they will be aligned on large memory blocks (4096 probably)
			PSPACE ps = FindSpace( pData );
			if( ps )
			{
				DoCloseSpace( ps, TRUE );
				return NULL;
			}
		}
#endif
		if( !USE_CUSTOM_ALLOCER )
		{
			//PMEM pMem = (PMEM)(pData - offsetof( MEM, pRoot ));
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData) );
			pc->dwOwners--;
			if( !pc->dwOwners )
			{
				extern int  MemChk ( POINTER p, uintptr_t val, size_t sz );
#ifndef NO_LOGGING
#  ifdef _DEBUG
				if( g.bLogAllocate )
				{
					ll__lprintf(DBG_RELAY)( "Release %p(%p)", pc, pc->byData );
				}
#  endif
#endif
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
				if( !MemChk( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) ) ||
					!MemChk( pc->byData + pc->dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) ) )
				{
					ll_lprintf( "overflow block (%p) %p", pData, pc );
					DebugBreak();
				}
#endif
				free( pc );
				return NULL;
			}
			else
			{
#ifndef NO_LOGGING
				if( g.bLogAllocate && g.bLogAllocateWithHold )
				{
					ll__lprintf(DBG_RELAY)( "Release(holding) %p(%p)", pc, pc->byData );
				}
#endif
			}
			return pData;
		}
#if USE_CUSTOM_ALLOCER
		else
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - ( ( (uint16_t*)pData)[-1] +
													offsetof( CHUNK, byData ) ) );
			PMEM pMem, pCurMem;
			PSPACE pMemSpace;
			// Allow a simple release() to close a shared memory file mapping
			// this is a slight performance hit for all deallocations
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
#ifndef NO_LOGGING
#  ifdef _DEBUG
			if( g.bLogAllocate )
			{
				if( !g.bDisableDebug )
					_xlprintf( 2 DBG_RELAY )("Release  : %p(%p) - %" _PTRSZVALfs " bytes %s(%d)", pc->byData, pc, pc->dwSize, BLOCK_FILE( pc ), BLOCK_LINE( pc ));
				else
					_xlprintf( 2 DBG_RELAY )("Release  : %p(%p) - %" _PTRSZVALfs " bytes", pc->byData, pc, pc->dwSize);
			}
#  endif
#endif
			pMem = GrabMem( pc->pRoot );
			if( !pMem )
			{
#ifndef NO_LOGGING
				ll__lprintf( DBG_RELAY )( "ERROR: Chunk to free does not reference a heap!" );
#endif
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
			}
			pMemSpace = FindSpace( pMem );
			while( pMemSpace && ( ( pCurMem = (PMEM)pMemSpace->pMem ),
										(	( (uintptr_t)pData < (uintptr_t)pCurMem )
										||  ( (uintptr_t)pData > ( (uintptr_t)pCurMem + pCurMem->dwSize ) ) )
									 )
				 )
			{
				Log( "ERROR: This block should have immediatly referenced it's correct heap!" );
				pMemSpace = pMemSpace->next;
			}
			if( !pMemSpace )
			{
#ifndef NO_LOGGING
#  ifdef _DEBUG
				ll__lprintf( DBG_RELAY )( "This Block is NOT within the managed heap! : %p", pData );
#  endif
#endif
				ll_lprintf( "this may not be an error.  This could be an old block from not using customallocer..." );
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
				DropMem( pMem );
				return NULL;
			}
			pCurMem = (PMEM)pMemSpace->pMem;
			if( pData && pc )
			{
				if( !pc->dwOwners )
				{
#ifndef NO_LOGGING
#  ifdef _DEBUG
					if( !g.bDisableDebug &&
						!(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
						_xlprintf( 2
									, BLOCK_FILE(pc)
									, BLOCK_LINE(pc)
									)( "Block is already Free! %p "
									, pc );
					else
#  endif
						// CRITICAL ERROR!
						_xlprintf( 2 DBG_RELAY)( "Block is already Free! %p ", pc );
#endif
					DropMem( pMem );
					return pData;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug )
					if( BLOCK_TAG( pc ) != BLOCK_TAG_ID )
					{
						ll_lprintf( "Application overflowed memory:%p", pc->byData );
						DebugDumpHeapMemEx( pc->pRoot, 1 );
						DebugBreak();
					}
#endif
				pc->dwOwners--;
				if( pc->dwOwners )
				{
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
#endif
					DropMem( pMem );
					return pData;
				}
				else
				{
					LOGICAL bCollapsed = FALSE;
					PCHUNK next, nextNext, pPrior;
					uintptr_t nNext;
					// fill memory with a known value...
					// this will allow me to check usage after release....
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
					if( !g.bDisableDebug )
					{
						BLOCK_TAG(pc)=BLOCK_TAG_ID;
						MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
					}
#endif
					next = (PCHUNK)(pc->byData + pc->dwSize);
					if( (nNext = (uintptr_t)next - (uintptr_t)pCurMem) >= pCurMem->dwSize )
					{
						// if next is NOT within valid memory...
						next = NULL;
					}
 // is not root chunk...
					if( ( pPrior = pc->pPrior ) )
					{
 // prior physical is free
						if( !pPrior->dwOwners )
						{
 // add this header plus size
							pPrior->dwSize += CHUNK_SIZE + pc->dwSize;
#ifdef _DEBUG
							//if( bLogAllocate )
							{
								//ll_lprintf( "Collapsing freed block with prior block...%p %p", pc, pPrior );
							}
							if( !g.bDisableDebug )
							{
								pPrior->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
								BLOCK_TAG( pPrior ) = BLOCK_TAG_ID;
								MemSet( pPrior->byData, FREE_MEMORY_TAG, pPrior->dwSize - pPrior->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pPrior->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
#endif
							}
							if( pPrior->dwSize & 0x80000000 )
								DebugBreak();
 // use prior block as base ....
							pc = pPrior;
							if( next )
								next->pPrior = pPrior;
							bCollapsed = TRUE;
						}
					}
					// begin checking NEXT physical memory block for conglomerating
					if( next )
					{
						if( !next->dwOwners )
						{
							pc->dwSize += CHUNK_SIZE + next->dwSize;
							if( bCollapsed )
							{
								// pc is already in free list...
								UnlinkThing( next );
							}
							else
							{
								// otherwise need to use next's link spot
								// for this pc...
								if( (pc->next = next->next) )
									pc->next->me = &pc->next;
								*( pc->me = next->me ) = pc;
								bCollapsed = TRUE;
							}
#ifdef _DEBUG
							//if( bLogAllocate )
								//ll_lprintf( "Collapsing freed block with next block...%p %p", pc, next );
							if( !g.bDisableDebug )
							{
								pc->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
								BLOCK_TAG( pc ) = BLOCK_TAG_ID;
								MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pc->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
#endif
							}
							if( pc->dwSize & 0x80000000 )
								DebugBreak();
							nextNext = (PCHUNK)(pc->byData + pc->dwSize );
							if( (((uintptr_t)nextNext) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
							{
								nextNext->pPrior = pc;
							}
						}
					}
 // no block near this one was free...
					if( !bCollapsed )
					{
						LinkThing( pc->pRoot->pFirstFree, pc );
					}
				}
			}
			Bubble( pMem );
			DropMem( pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pMem, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
#endif
	}
	return NULL;
}
		//------------------------------------------------------------------------------------------------------
 POINTER  HoldEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
		if( !USE_CUSTOM_ALLOCER )
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)((uintptr_t)pData - MALLOC_CHUNK_SIZE(pData));
			//ll__lprintf( DBG_RELAY )( "holding block %p", pc );
#ifndef NO_LOGGING
			if( g.bLogAllocate && g.bLogAllocateWithHold )
				_xlprintf( 2 DBG_RELAY)( "Hold	 : %p - %" _PTRSZVALfs " bytes",pc, pc->dwSize );
#endif
			pc->dwOwners++;
		}
		else
		{
			PCHUNK pc = (PCHUNK)((char*)pData - CHUNK_SIZE);
			PMEM pMem = GrabMem( pc->pRoot );
#ifndef NO_LOGGING
			if( g.bLogAllocate )
			{
				_xlprintf( 2 DBG_RELAY)( "Hold	 : %p - %" _PTRSZVALfs " bytes",pc, pc->dwSize );
			}
#endif
			if( !pc->dwOwners )
			{
				ll_lprintf( "Held block has already been released!  too late to hold it!" );
				DebugBreak();
				DropMem( pMem );
				return pData;
			}
			pc->dwOwners++;
			DropMem(pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
	}
	return pData;
}
//------------------------------------------------------------------------------------------------------
 POINTER  GetFirstUsedBlock ( PMEM pHeap )
{
	return pHeap->pRoot[0].byData;
}
//------------------------------------------------------------------------------------------------------
void  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose )
{
#if USE_CUSTOM_ALLOCER
	if( USE_CUSTOM_ALLOCER )
	{
		PCHUNK pc, _pc;
		uintptr_t nTotalFree = 0;
		uintptr_t nChunks = 0;
		uintptr_t nTotalUsed = 0;
		PSPACE pMemSpace;
		PMEM pMem = GrabMem( pHeap ), pCurMem;
		pc = pMem->pRoot;
		ll_lprintf(" ------ Memory Dump ------- " );
		{
			xlprintf(LOG_ALWAYS)( "FirstFree : %p",
										pMem->pFirstFree );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
#ifndef __LINUX__
 // allow debug log to work... (OutputDebugString() Win32, also network streams may require)
				Relinquish();
#endif
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( "Free at %p size: %" _PTRSZVALfs "(%" _PTRSZVALfx ") Prior:%p NF:%p",
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior,
																 pc->next );
					}
#endif
				}
				else
				{
					nTotalUsed += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( "Used at %p size: %" _PTRSZVALfs "(%" _PTRSZVALfx ") Prior:%p",
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior );
					}
#endif
				}
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
					ll_lprintf( "Next block is the current block..." );
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		xlprintf(LOG_ALWAYS)( "Total Free: %" _PTRSZVALfs "  TotalUsed: %" _PTRSZVALfs "  TotalChunks: %" _PTRSZVALfs " TotalMemory:%" _PTRSZVALfs,
									nTotalFree, nTotalUsed, nChunks,
									(nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		DropMem( pMem );
	}
	else
#endif
		xlprintf(LOG_ALWAYS)( "Cannot log chunks allocated that are not using custom allocer." );
}
	//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemEx ( LOGICAL bVerbose )
{
	DebugDumpHeapMemEx( g.pMemInstance, bVerbose );
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename )
{
#if USE_CUSTOM_ALLOCER
	FILE *file;
#endif
	if( !USE_CUSTOM_ALLOCER )
		return;
#if USE_CUSTOM_ALLOCER
	Fopen( file, pFilename, "wt" );
	if( file )
	{
		PCHUNK pc, _pc;
		PMEM pMem, pCurMem;
		PSPACE pMemSpace;
		size_t nTotalFree = 0;
		size_t nChunks = 0;
		size_t nTotalUsed = 0;
		char byDebug[256];
		pMem = GrabMem( pHeap );
		fprintf( file, " ------ Memory Dump ------- \n" );
		{
			char  byDebug[256];
			snprintf( byDebug, sizeof( byDebug ), "FirstFree : %p",
						pMem->pFirstFree );
			byDebug[255] = 0;
			fprintf( file, "%s\n", byDebug );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
				//Relinquish(); // allow debug log to work...
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p NF:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior,
						pc->next );
					byDebug[255] = 0;
				}
				else
				{
					nTotalUsed += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Used at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior );
					byDebug[255] = 0;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug && !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
#endif
					fprintf( file, "%s\n", byDebug );
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		fprintf( file, "--------------- FREE MEMORY LIST --------------------\n" );
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pFirstFree;
 // while PC not off end of memory
			while( pc )
			{
				snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" c_size_fs "(%" c_size_fx ") ",
							pc, pc->dwSize, pc->dwSize );
				byDebug[255] = 0;
	#ifdef _DEBUG
 /*!g.bDisableDebug && */
				if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					const char * pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?CStrDup(BLOCK_FILE(pc))
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
	#endif
					fprintf( file, "%s\n", byDebug );
				pc = pc->next;
			}
		}
		snprintf( byDebug, sizeof(byDebug), "Total Free: %" c_size_f "  TotalUsed: %" c_size_f "  TotalChunks: %" c_size_f " TotalMemory:%" c_size_f
					, nTotalFree, nTotalUsed, nChunks
					, (nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		byDebug[255] = 0;
		fprintf( file, "%s\n", byDebug );
		//Relinquish();
		DropMem( pMem );
		 fclose( file );
	}
#endif
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemFile ( CTEXTSTR pFilename )
{
	DebugDumpHeapMemFile( g.pMemInstance, pFilename );
}
//------------------------------------------------------------------------------------------------------
 // returns true/false, updates pointer
 LOGICAL  Defragment ( POINTER *ppMemory )
{
	// this is broken... needs
	// to fixup BLOCK_TAG, BLOCK_FILE, etc...
#if 1
	return FALSE;
#else
	// pass an array of allocated memory... for all memory blocks in list,
	// check to see if they can be reallocated lower, and or just moved to
	// a memory space lower than they are now.
	PCHUNK pc, pPrior;
	PMEM pMem;
	if( !ppMemory || !*ppMemory)
		return FALSE;
	pc = (PCHUNK)(((uintptr_t)(*ppMemory)) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
	pMem = GrabMem( pc->pRoot );
		// check if prior block is free... if so - then...
		// move this data down, and reallocate the freeness at the end
		// this reallocation may move the free next to another free, which
		// should be collapsed into this one...
	pPrior = pc->pPrior;
 // not HELD by others... no way to update their pointers
	if( ( pc->dwOwners == 1 ) &&
		pPrior &&
		!pPrior->dwOwners )
	{
		CHUNK Free = *pPrior;
		CHUNK Allocated, *pNew;
 // save this chunk...
		Allocated = *pc;
		MemCpy( pPrior->byData, pc->byData, Allocated.dwSize );
		pNew = (PCHUNK)(pPrior->byData + Allocated.dwSize);
		pNew->dwSize = Free.dwSize;
		pNew->dwOwners = 0;
 // now pAllocated...
		pNew->pPrior = pPrior;
		pNew->pRoot = Free.pRoot;
		if( ( pNew->next = Free.next ) )
			pNew->next->me = &pNew->next;
		if( ( pNew->me = Free.me ) )
			(*pNew->me) = pNew;
#ifdef _DEBUG
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			BLOCK_FILE(pNew) = BLOCK_FILE(&Free);
			BLOCK_LINE(pNew) = BLOCK_LINE(&Free);
		}
#endif
		pPrior->dwSize = Allocated.dwSize;
		pPrior->dwOwners = 1;
		pPrior->next = NULL;
		pPrior->me = NULL;
		// update NEXT NEXT real block...
		{
			PCHUNK next;
			next = (PCHUNK)( pNew->byData + pNew->dwSize );
			if( (((uintptr_t)next) - ((uintptr_t)pMem)) < (uintptr_t)pMem->dwSize )
			{
 // if next is free.....
				if( !next->dwOwners )
				{
					// consolidate...
					if( (pNew->next = next->next) )
						pNew->next->me = &pNew->next;
					*( pNew->me = next->me ) = pNew;
					pNew->dwSize += next->dwSize + CHUNK_SIZE;
					next = (PCHUNK)( pNew->byData + pNew->dwSize );
					if( (uint32_t)(((char *)next) - ((char *)pMem)) < pMem->dwSize )
					{
						next->pPrior = pNew;
					}
				}
				else
					next->pPrior = pNew;
			}
		}
		*ppMemory = pPrior->byData;
		DropMem( pMem );
		GetHeapMemStats( g.pMemInstance, NULL, NULL, NULL, NULL );
		return TRUE;
	}
	DropMem( pMem );
	return FALSE;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS )
{
#if USE_CUSTOM_ALLOCER
	int nChunks = 0, nFreeChunks = 0, nSpaces = 0;
	uintptr_t nFree = 0, nUsed = 0;
	PCHUNK pc, _pc;
	PMEM pMem;
	PSPACE pMemSpace;
#endif
	if( !USE_CUSTOM_ALLOCER )
      return;
#if USE_CUSTOM_ALLOCER
	if( !pHeap )
		pHeap = g.pMemInstance;
	pMem = GrabMem( pHeap );
	pMemSpace = FindSpace( pMem );
	while( pMemSpace )
	{
		PMEM pMemCheck = ((PMEM)pMemSpace->pMem);
		pc = pMemCheck->pRoot;
		GrabMem( pMemCheck );
 // while PC not off end of memory
		while( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize )
		{
			nChunks++;
			if( !pc->dwOwners )
			{
				nFree += pc->dwSize;
				nFreeChunks++;
			}
			else
			{
				nUsed += pc->dwSize;
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					if( pc->dwSize > pMemCheck->dwSize )
					{
						ll_lprintf( "Memory block %p has a corrupt size.", pc->byData );
						DebugBreak();
					}
					else
					{
						int minPad = MAGIC_SIZE;
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
							minPad += MAGIC_SIZE * 2;
						if( ( pc->dwPad >= minPad ) && ( BLOCK_TAG(pc) != BLOCK_TAG_ID ) )
						{
#ifndef NO_LOGGING
							ll_lprintf( "memory block: %p(%p) %08" TAG_FORMAT_MODIFIER "x instead of %08" TAG_FORMAT_MODIFIER "x", pc, pc->byData, BLOCK_TAG(pc), BLOCK_TAG_ID );
							if( !(pMemCheck->dwFlags & HEAP_FLAG_NO_DEBUG ) )
							{
								CTEXTSTR file = BLOCK_FILE(pc);
#  ifdef _WIN32
								if( IsBadReadPtr( file, 4 ) )
									file = "(corrupt)";
#  endif
								_xlprintf( 2, file, BLOCK_LINE(pc) )( "Application overflowed allocated memory." );
							}
							else
								ODS( "Application overflowed allocated memory." );
#endif
							DebugDumpHeapMemEx( pHeap, 1 );
							DebugBreak();
						}
					}
				}
#endif
			}
			_pc = pc;
			pc = (PCHUNK)(pc->byData + pc->dwSize );
			if( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize  )
			{
				if( pc == _pc )
				{
					Log( "Current block is the same as the last block we checked!" );
					DebugDumpHeapMemEx( pHeap, 1 );
 // broken memory chain
					DebugBreak();
					break;
				}
				if( pc->pPrior != _pc )
				{
					ll_lprintf( "Block's prior is not the last block we checked! prior %p sz: %" _PTRSZVALfs " current: %p currentprior: %p"
						, _pc
						, _pc->dwSize
						, pc
						, pc->pPrior );
					DebugDumpHeapMemEx( pHeap, 1 );
					DebugBreak();
					break;
				}
			}
		}
		_pc = NULL;
		pc = pMemCheck->pFirstFree;
		while( pc )
		{
			if( pc->dwOwners )
  // owned block is in free memory chain ! ?
			{
				ll_lprintf( "Owned block %p is in free memory chain!", pc );
				DebugBreak();
				break;
			}
			_pc = pc;
			pc = pc->next;
		}
		nSpaces++;
		pMemSpace = pMemSpace->next;
		DropMem( pMemCheck );
	}
	DropMem( pMem );
	if( pFree )
		*pFree = (uint32_t)nFree;
	if( pUsed )
		*pUsed = (uint32_t)nUsed;
	if( pChunks )
		*pChunks = nChunks;
	if( pFreeChunks )
		*pFreeChunks = nFreeChunks;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStats( g.pMemInstance, pFree, pUsed, pChunks, pFreeChunks );
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateLogging ( LOGICAL bTrueFalse )
{
	LOGICAL prior = g.bLogAllocate;
	g.bLogAllocate = bTrueFalse;
	return prior;
}
//------------------------------------------------------------------------------------------------------
 int  SetCriticalLogging ( LOGICAL bTrueFalse )
{
#ifdef _DEBUG
	int prior = g.bLogCritical;
	g.bLogCritical = bTrueFalse;
	return prior;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateDebug ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableDebug;
	g.bDisableDebug = !bDisable;
	g.bDisableAutoCheck = !bDisable;
	return save;
#else
	return 1;
#endif
}
 int  SetManualAllocateCheck ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableAutoCheck;
	g.bDisableAutoCheck = bDisable;
	return save;
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  SetMinAllocate ( size_t nSize )
{
	g.nMinAllocateSize = nSize;
}
//------------------------------------------------------------------------------------------------------
 void  SetHeapUnit ( size_t dwSize )
{
	g.dwSystemCapacity = dwSize;
}
//------------------------------------------------------------------------------------------------------
#undef GetHeapMemStats
 void  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStatsEx( pHeap, pFree, pUsed, pChunks, pFreeChunks DBG_SRC );
}
#if 0
#  ifdef _MSC_VER
//>= 900
_CRT_ALLOC_HOOK prior_hook;
int allocHook(int allocType, void *userData, size_t size, int
blockType, long requestNumber, const unsigned char *filename, int
lineNumber)
{
	static int logging;
	if( logging )
		return TRUE;
	logging = 1;
	switch( allocType )
	{
	case _HOOK_ALLOC:
		ll_lprintf( "CRT Alloc: %d bytes %s(%d)"
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_REALLOC:
		ll_lprintf( "CRT Realloc: %d bytes %s(%d)"
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_FREE:
		ll_lprintf( ( "CRT Free: %p[%" _PTRSZVALfs "](%d) %s(%d)" )
			, userData
			, (uintptr_t)userData
			, size
			, filename, lineNumber
			);
		break;
	default:
		DebugBreak();
	}
	logging = 0;
	if( prior_hook )
		return prior_hook( allocType, userData, size, blockType, requestNumber, filename, lineNumber );
	return TRUE;
}
//int handle_program_memory_depletion( size_t )
//{
   // Your code
//}
PRELOAD( ShareMemToVSAllocHook )
{
	//_CRT_ALLOC_HOOK allocHook;
	//allocHook = 0 ;
	/* this is about useless... the free doesn't report the correct address
	* the allocate doesn't report the block
	* the free doesn't reprot the size
	* there is no way to relate what is freed with what is allocated
	*/
	//prior_hook = _CrtSetAllocHook(	allocHook );
	//_set_new_handler( pn );
}
#  endif
#endif
#ifdef __cplusplus
//namespace sack {
}
//	namespace memory {
}
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
SACK_MEMORY_NAMESPACE
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#if defined( __GNUC__ )
#  pragma GCC push_options
#  pragma GCC optimize ("O0")
#endif
void  MemSet ( POINTER p, uintptr_t n, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
#  if defined( _WIN64 )
	//__asm cld;
	__stosq( (uint64_t*)p, n, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#  else
#    ifdef __64__
	__stosq( (uint64_t*)p, n, sz / 4 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    else
	__stosd( (DWORD*)p, n, sz / 4 );
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    endif
#  endif
#elif defined( __GNUC__ )
	{
      uintptr_t tmp = (uintptr_t)p;
#  ifdef __64__
		{
			int m; int len = sz/8;
			for( m = 0; m < len; m++ ) {
				((uint64_t*)tmp)[0] = n;
				tmp += 8;
			}
		}
		if( sz & 4 )
			(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  else
		{
			int m; int len = sz/4;
			for( m = 0; m < len; m++ ) {
				((uint32_t*)tmp)[0] = n;
				tmp += 4;
			}
		}
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  endif
	}
#else
   memset( p, n, sz );
#endif
}
#if defined( __GNUC__ )
#  pragma GCC pop_options
#endif
int  MemChk ( POINTER p, uintptr_t val, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
	size_t n;
	uintptr_t *data = (uintptr_t*)p;
	for( n = 0; n < sz/sizeof(uintptr_t); n++, data++ )
		if( data[0] != val )
			return 0;
   return 1;
#else
	//   memset( p, n, sz );
   return 1;
#endif
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 void  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ )&& !defined( UNDER_CE )
#  ifdef _WIN64
	__movsq( (uint64_t*)pTo, (uint64_t*)pFrom, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)pTo) + sz - (sz&7) ) ) = (*(uint32_t*)( ((uintptr_t)pFrom) + sz - (sz&7) ) );
#  else
	__movsd( (DWORD*)pTo, (DWORD*)pFrom, sz/4 );
#  endif
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)pTo) + sz - (sz&3) ) ) = (*(uint16_t*)( ((uintptr_t)pFrom) + sz - (sz&3) ) );
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)pTo) + sz - (sz&1) ) ) = (*(uint8_t*)( ((uintptr_t)pFrom) + sz - (sz&1) ) );
#else
	memcpy( pTo, pFrom, sz );
#endif
}
int  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz )
{
   // zero byte comparison, always same.
	if( !sz )
      return 0;
	if( !pOne && !pTwo )
		return 0;
	if( !pOne )
 // NULL < "anything"
		return -1;
	if( !pTwo )
  // "anything" > NULL
		return 1;
	return memcmp( pOne, pTwo, sz );
}
TEXTSTR StrCpyEx( TEXTSTR s1, CTEXTSTR s2, size_t n )
{
	size_t x;
	if( !s1 ) return s1;
	if( !s2 ) { if( s1 ) { s1[0] = 0; return s1; } }
	for( x = 0; x < n && (s1[x]=s2[x]); x++ );
	if( n )
		s1[n-1] = 0;
	return s1;
}
#undef StrCpy
TEXTSTR StrCpy( TEXTSTR s1, CTEXTSTR s2 )
{
	int x;
	for( x = 0; (s1[x]=s2[x]); x++ );
	return s1;
}
CTEXTSTR StrChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
CTEXTSTR StrRChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
TEXTSTR StrRChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#endif
CTEXTSTR StrCaseStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] ||
         (p1[0] == '/' && p2[0] == '\\' ) ||
         (p1[0] == '\\' && p2[0] == '/' ) ||
			(((p1[0] >='a' && p1[0] <='z' )?p1[0]-('a'-'A'):p1[0])
			 == ((p2[0] >='a' && p2[0] <='z' )?p2[0]-('a'-'A'):p2[0]) ))
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
CTEXTSTR StrStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrStr( TEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	TEXTSTR p1, began_at;
	CTEXTSTR p2;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
 // set began_at here too..
	began_at = p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#endif
//------------------------------------------------------------------------------------------------------
// result in 0(equal), 1 above, or -1 below
// *r contains the position of difference
 int  CmpMem8 ( void *s1, void *s2, unsigned long n, unsigned long *r )
{
	int t1, t2;
	uint32_t pos;
	{
		pos = 0;
		while( pos < n )
		{
			t1 = *(unsigned char*)s1;
			t2 = *(unsigned char*)s2;
			if( ( t1 ) == ( t2 ) ) {
				(pos)++;
				s1 = (void*)(((uintptr_t)s1) + 1);
				s2 = (void*)(((uintptr_t)s2) + 1);
			} else if( t1 > t2 ) {
				if( r )
					*r = pos;
				return 1;
			} else {
				if( r )
					*r = pos;
				return -1;
			}
		}
	}
	if( r )
		*r = pos;
	return 0;
}
//------------------------------------------------------------------------------------------------------
 TEXTSTR  StrDupEx ( CTEXTSTR original DBG_PASS )
{
	if( original )
	{
		uintptr_t len = (uintptr_t)StrLen( original ) + 1;
		TEXTCHAR *result;
		result = (TEXTCHAR*)AllocateEx( sizeof(TEXTCHAR)*len  DBG_RELAY );
		MemCpy( result, original, sizeof(TEXTCHAR)*len );
		return result;
	}
	return NULL;
}
size_t StrLen( CTEXTSTR s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++, s++);
	return l;
}
size_t CStrLen( char const* s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++,s++);
	return l;
}
#ifdef _UNICODE
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	return WcharConvertEx( original DBG_RELAY );
}
TEXTSTR  DupCStrEx ( const char * original DBG_PASS )
{
	if( original )
		return CharWConvertEx( original DBG_RELAY );
	return NULL;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	if( original )
		return CharWConvertExx( original, chars DBG_RELAY );
	return NULL;
}
#else
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	INDEX len;
	char *result;
	if( !original )
		return NULL;
	for( len = 0; original[len]; len++ );
	result = (char*)AllocateEx( (len+1) * sizeof( result[0] ) DBG_RELAY );
	len = 0;
	while( ( result[len] = original[len] ) != 0 ) len++;
	return result;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	size_t len = 0;
	TEXTSTR result, _result;
	if( !original )
		return NULL;
// (TEXTSTR)AllocateEx( (len + 1) * sizeof( result[0] )  DBG_RELAY );
	_result = result = NewArray( TEXTCHAR, chars + 1 );
	len = 0;
	while( len < chars ) ((*result++) = (*original++)), len++;
	result[0] = 0;
	return _result;
}
TEXTSTR  DupCStrEx( const char * original DBG_PASS )
{
	size_t len = 0;
	const char *_original;
	if( !original )
		return NULL;
	_original = original;
	while( (*original++) ) len++;
	return DupCStrLenEx( _original, len DBG_RELAY );
}
#endif
wchar_t *   DupTextToWideEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return CharWConvertEx( original DBG_RELAY );
#endif
}
char *     DupTextToCharEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return WcharConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupWideToTextEx( const wchar_t * original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return WcharConvertEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupCharToTextEx( const char * original DBG_PASS )
{
#ifdef _UNICODE
   return CharWConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
 int  StrCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ); s1++, s2++ );
	return s1[0] - s2[0];
}
 int  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) );
		  s1++, s2++ );
	return tolower(s1[0]) - tolower(s2[0]);
}
 int  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ) && maxlen; s1++, s2++, maxlen-- );
	if( maxlen )
		return s1[0] - s2[0];
	return 0;
}
 int  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
 int  StriCmp ( CTEXTSTR pOne, CTEXTSTR pTwo )
{
   return -1;
}
SACK_MEMORY_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *	(c) Freedom Collective 2000-2006++
 *
 *	code to drive standard containers, lists, stacks, queues
 *	auto expanding, auto tracking, threadsafe containers...
 *
 *  standardized to never use int.
 *
 * see also - include/typelib.h
 *
 */
 // offsetof
 // Sleep
#define MY_OFFSETOF( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
#ifndef USE_CUSTOM_ALLOCER
#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
// this has to be a compile option (option from cmake)
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#define USE_CUSTOM_ALLOCER 1
#else
#define USE_CUSTOM_ALLOCER 0
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace containers {
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace list {
#endif
static struct list_local_data
{
	volatile uint32_t lock;
} s_list_local, *_list_local;
#ifdef __STATIC_GLOBALS__
#  define list_local  (s_list_local)
#  define list_local_lock (&s_list_local.lock)
#else
#  define list_local  ((_list_local)?(*_list_local):(s_list_local))
#  define list_local_lock ((_list_local)?(&_list_local->lock):(&s_list_local.lock))
#endif
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
PLIST  CreateListEx ( DBG_VOIDPASS )
{
	PLIST pl;
	INDEX size;
	pl = (PLIST)AllocateEx( ( size = (INDEX)offsetof( LIST, pNode[0] ) ) DBG_RELAY );
	MemSet( pl, 0, size );
	return pl;
}
//--------------------------------------------------------------------------
PLIST  DeleteListEx ( PLIST *pList DBG_PASS )
{
	PLIST ppList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( pList &&
		( ppList = (PLIST)LockedExchangePtrSzVal( (uintptr_t*)pList, 0 ) )
	  )
	{
		ReleaseEx( ppList DBG_RELAY );
	}
	list_local_lock[0] = 0;
	return NULL;
}
//--------------------------------------------------------------------------
static PLIST ExpandListEx( PLIST *pList, INDEX amount DBG_PASS )
{
 //-V595
	PLIST old_list = (*pList);
	PLIST pl;
	uintptr_t size;
	uintptr_t old_size;
	if( !pList )
		return NULL;
	if( *pList )
	{
		old_size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt])) - ((uintptr_t)(*pList));
		size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt+amount])) - ((uintptr_t)(*pList));
		//old_size = offsetof( LIST, pNode[(*pList)->Cnt]));
		pl = (PLIST)AllocateEx( size DBG_RELAY );
	}
	else
	{
		old_size = 0;
		pl = (PLIST)AllocateEx( size = MY_OFFSETOF( pList, pNode[amount] ) DBG_RELAY );
		pl->Cnt = 0;
	}
	if( old_list )
	{
		// copy old list to new list
		MemCpy( pl, *pList, old_size );
		if( amount == 1 )
			pl->pNode[pl->Cnt++] = NULL;
		else
		{
			// clear the new additions to the list
			MemSet( pl->pNode + pl->Cnt, 0, size - old_size );
			pl->Cnt += amount;
		}
		// set the new list before releasing the old one.
		(*pList) = pl;
		// remove the old list...
		ReleaseEx( old_list DBG_RELAY );
	}
	else
	{
 // clear whole structure on creation...
		MemSet( pl, 0, size );
  // one more ( always a free )
		pl->Cnt = amount;
		// brand new list.
		*pList = pl;
	}
	return pl;
}
//--------------------------------------------------------------------------
 PLIST  AddLinkEx ( PLIST *pList, POINTER p DBG_PASS )
{
	INDEX i;
	if( !pList )
		return NULL;
	if( !(*pList ) )
	{
	retry1:
		ExpandListEx( pList, 8 DBG_RELAY );
	}
	else
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		// cannot trust that the list will exist all the time
		// we may start calling this function and have the
		// list re-allocated.
		if( !(*pList) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	for( i = 0; i < (*pList)->Cnt; i++ )
	{
		if( !(*pList)->pNode[i] )
		{
			(*pList)->pNode[i] = p;
			break;
		}
	}
	if( i == (*pList)->Cnt )
  // pList->Cnt changes - don't test in WHILE
		goto retry1;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 PLIST  SetLinkEx ( PLIST *pList, INDEX idx, POINTER p DBG_PASS )
{
	INDEX sz;
	if( !pList )
		return NULL;
	if( *pList )
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		if( !(*pList ) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	if( idx == INVALID_INDEX )
	{
		list_local_lock[0] = 0;
 // not set...
		return *pList;
	}
	sz = 0;
	while( !(*pList) || ( sz = (*pList)->Cnt ) <= idx )
		ExpandListEx( pList, (idx - sz) + 1 DBG_RELAY );
	(*pList)->pNode[idx] = p;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 POINTER  GetLink ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return pList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( !(*pList ) )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	if( (*pList)->Cnt <= idx )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	p = (*pList)->pNode[idx];
	list_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 POINTER*  GetLinkAddress ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER *p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return NULL;
	if( (*pList)->Cnt <= idx )
	{
		return NULL;
	}
	p = (*pList)->pNode + idx;
	return p;
}
//--------------------------------------------------------------------------
 uintptr_t  ForAllLinks ( PLIST *pList, ForProc func, uintptr_t user )
{
	INDEX i;
	uintptr_t result = 0;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	 if( pList && *pList )
	{
		for( i=0; i < ((*pList)->Cnt); i++ )
		{
			if( (*pList)->pNode[i] )
			{
				result = func( user, i, (*pList)->pNode + i );
				if( result )
					break;
			}
		}
	}
	list_local_lock[0] = 0;
	return result;
}
 //--------------------------------------------------------------------------
 INDEX GetLinkCount( PLIST pList ) {
	 INDEX i;
	 POINTER p;
	 INDEX count = 0;
	 LIST_FORALL( pList, i, POINTER, p ) {
		 count++;
	 }
	 return count;
 }
 //--------------------------------------------------------------------------
static uintptr_t CPROC IsLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
 // 0 might be value so add one to make it non zero
		return i+1;
	return 0;
}
//--------------------------------------------------------------------------
 INDEX  FindLink ( PLIST *pList, POINTER value )
{
	if( !pList || !(*pList ) )
		return INVALID_INDEX;
	return ForAllLinks( pList, IsLink, (uintptr_t)value ) - 1;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC KillLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
	{
		(*link) = NULL;
 // stop searching
		return 1;
	}
	return 0;
}
LOGICAL  DeleteLink( PLIST *pList, CPOINTER value )
{
	if( ForAllLinks( pList, KillLink, (uintptr_t)value ) )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC RemoveItem( uintptr_t value, INDEX i, POINTER *link )
{
	*link = NULL;
	return 0;
}
void EmptyList( PLIST *pList )
{
	ForAllLinks( pList, RemoveItem, 0 );
}
#ifdef __cplusplus
//		namespace list {
		};
namespace data_list {
#endif
static struct data_list_local_data
{
	uint32_t lock;
} s_data_list_local, *_data_list_local;
#ifdef __STATIC_GLOBALS__
#  define data_list_local  ((s_data_list_local))
#  define data_list_local_lock  ((&s_data_list_local.lock))
#else
#  define data_list_local  ((_data_list_local)?(*_data_list_local):(s_data_list_local))
#  define data_list_local_lock  ((_data_list_local)?(&_data_list_local->lock):(&s_data_list_local.lock))
#endif
//--------------------------------------------------------------------------
PDATALIST ExpandDataListEx( PDATALIST *ppdl, INDEX entries DBG_PASS )
{
 //-V595
	PDATALIST pdl = (*ppdl);
	PDATALIST pNewList;
	if( !ppdl || !*ppdl )
 // can't expand - was not created (no data size)
		return NULL;
	if( (*ppdl) )
		entries += (*ppdl)->Avail;
	pNewList = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( (*ppdl)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewList->data, (*ppdl)->data, (*ppdl)->Avail * (*ppdl)->Size );
	pNewList->Cnt = (*ppdl)->Cnt;
	pNewList->Avail = entries;
	pNewList->Size = (*ppdl)->Size;
	// set the new list int he pointer
	*ppdl = pNewList;
	ReleaseEx( pdl DBG_RELAY );
	return pNewList;
}
//--------------------------------------------------------------------------
 PDATALIST  CreateDataListEx ( uintptr_t nSize DBG_PASS )
{
	PDATALIST pdl = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( nSize * 8 ) - 1 DBG_RELAY );
	pdl->Cnt = 0;
	pdl->Avail = 8;
	pdl->Size = nSize;
	return pdl;
}
//--------------------------------------------------------------------------
 void  DeleteDataListEx ( PDATALIST *ppdl DBG_PASS )
{
	if( ppdl )
	{
		if( *ppdl )
		{
			ReleaseEx( *ppdl DBG_RELAY );
			*ppdl = NULL;
		}
	}
}
//--------------------------------------------------------------------------
POINTER SetDataItemEx( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS )
{
	POINTER p = NULL;
	if( !ppdl || !(*ppdl) || idx > 0x100000 )
		return NULL;
	if( idx >= (*ppdl)->Avail )
	{
		ExpandDataListEx( ppdl, (idx-(*ppdl)->Avail)+32 DBG_RELAY );
	}
	p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	MemCpy( p, data, (*ppdl)->Size );
	if( idx >= (*ppdl)->Cnt )
		(*ppdl)->Cnt = idx+1;
	return p;
}
//--------------------------------------------------------------------------
POINTER AddDataItemEx( PDATALIST *ppdl, POINTER data DBG_PASS )
{
	if( ppdl && *ppdl )
		return SetDataItemEx( ppdl, (*ppdl)->Cnt+1, data DBG_RELAY );
	if( ppdl )
		return SetDataItemEx( ppdl, 0, data DBG_RELAY );
	return NULL;
}
void EmptyDataList( PDATALIST *ppdl )
{
	if( ppdl && (*ppdl) )
		(*ppdl)->Cnt = 0;
}
//--------------------------------------------------------------------------
void DeleteDataItem( PDATALIST *ppdl, INDEX idx )
{
	if( ppdl && *ppdl )
	{
		if( idx < ( (*ppdl)->Cnt - 1 ) )
			MemCpy( (*ppdl)->data + ((*ppdl)->Size * idx )
					, (*ppdl)->data + ((*ppdl)->Size * (idx + 1) )
					, (*ppdl)->Size );
		(*ppdl)->Cnt--;
	}
}
//--------------------------------------------------------------------------
POINTER GetDataItem( PDATALIST *ppdl, INDEX idx )
{
	POINTER p = NULL;
	if( ppdl && *ppdl && ( idx < (*ppdl)->Cnt ) )
		p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	return p;
}
//--------------------------------------------------------------------------
#ifdef __cplusplus
//		namespace data_list {
		};
namespace link_stack {
#endif
 PLINKSTACK		CreateLinkStackLimitedEx		  ( int max_entries  DBG_PASS )
{
	PLINKSTACK pls;
	pls = (PLINKSTACK)AllocateEx( sizeof( LINKSTACK ) DBG_RELAY );
	pls->Top = 0;
	pls->Cnt = 0;
	pls->Max = max_entries;
	return pls;
}
//--------------------------------------------------------------------------
 PLINKSTACK  CreateLinkStackEx ( DBG_VOIDPASS )
{
	return CreateLinkStackLimitedEx( 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 void  DeleteLinkStackEx ( PLINKSTACK *pls DBG_PASS )
{
	if( pls && *pls )
	{
		ReleaseEx( *pls DBG_RELAY );
		*pls = 0;
	}
}
//--------------------------------------------------------------------------
POINTER  PeekLinkEx ( PLINKSTACK *pls, INDEX n )
{
	// should lock - but it's fast enough?
	POINTER p = NULL;
	if( pls && *pls && ((*pls)->Top > n) )
		p = (*pls)->pNode[(*pls)->Top - (n + 1)];
	return p;
}
//--------------------------------------------------------------------------
POINTER  PeekLink ( PLINKSTACK *pls )
{
	return PeekLinkEx( pls, 0 );
}
//--------------------------------------------------------------------------
POINTER  PopLink ( PLINKSTACK *pls )
{
	if( pls && *pls && (*pls)->Top )
		return (*pls)->pNode[--(*pls)->Top];
	return NULL;
}
//--------------------------------------------------------------------------
static PLINKSTACK ExpandStackEx( PLINKSTACK *stack, INDEX entries DBG_PASS )
{
	PLINKSTACK pNewStack;
	if( *stack )
		entries += (*stack)->Cnt;
 //-V595
	pNewStack = (PLINKSTACK)AllocateEx( my_offsetof( stack, pNode[entries] ) DBG_RELAY );
	if( *stack )
	{
		PLINKSTACK pls = (*stack);
		MemCpy( pNewStack->pNode, (*stack)->pNode, (*stack)->Cnt * sizeof(POINTER) );
		pNewStack->Top = (*stack)->Top;
		pNewStack->Max = (*stack)->Max;
		*stack = pNewStack;
		ReleaseEx( pls DBG_RELAY );
	}
	else
	{
		pNewStack->Top = 0;
		pNewStack->Max = 0;
		*stack = pNewStack;
	}
	pNewStack->Cnt = entries;
	return pNewStack;
}
//--------------------------------------------------------------------------
 PLINKSTACK  PushLinkEx ( PLINKSTACK *pls, POINTER p DBG_PASS )
{
	if( !pls )
		return NULL;
	// should lock this thing :)
	if( !*pls ||
		 (*pls)->Top == (*pls)->Cnt )
	{
		ExpandStackEx( pls, ((*pls)?((*pls)->Max):0)+8 DBG_RELAY );
	}
	if( (*pls)->Max )
		if( ((*pls)->Top) >= (*pls)->Max )
		{
			MemCpy( (*pls)->pNode, (*pls)->pNode + 1, (*pls)->Top - 1 );
			(*pls)->Top--;
		}
	(*pls)->pNode[(*pls)->Top] = p;
	(*pls)->Top++;
	return (*pls);
}
#ifdef __cplusplus
//namespace link_stack
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
 POINTER  PopData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( (pds) && (*pds) && (*pds)->Top )
	{
		 (*pds)->Top--;
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top) );
	}
	return p;
}
//--------------------------------------------------------------------------
static PDATASTACK ExpandDataStackEx( PDATASTACK *ppds, INDEX entries DBG_PASS )
{
	PDATASTACK pNewStack;
	PDATASTACK pds = (*ppds);
	if( !pds )
		return NULL;
	entries += pds->Cnt;
	pNewStack = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( (*ppds)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewStack->data, (*ppds)->data, (*ppds)->Cnt * (*ppds)->Size );
	pNewStack->Cnt = entries;
	pNewStack->Size = (*ppds)->Size;
	pNewStack->Top = (*ppds)->Top;
	(*ppds) = pNewStack;
	ReleaseEx( pds DBG_RELAY );
	return pNewStack;
}
//--------------------------------------------------------------------------
 PDATASTACK  PushDataEx ( PDATASTACK *pds, POINTER pdata DBG_PASS )
{
	if( pds && *pds )
	{
		if( (*pds)->Top == (*pds)->Cnt )
		{
			ExpandDataStackEx( pds, 1 DBG_RELAY );
		}
		if( (*pds)->Max )
			if( ((*pds)->Top) >= (*pds)->Max )
			{
				MemCpy( (*pds)->data, (*pds)->data + (*pds)->Size, ( (*pds)->Top - 1 ) * (*pds)->Size );
				(*pds)->Top--;
			}
		MemCpy( (*pds)->data + ((*pds)->Top * (*pds)->Size ), pdata, (*pds)->Size );
		(*pds)->Top++;
		return (*pds);
	}
	if( pds )
		return *pds;
	return NULL;
}
//--------------------------------------------------------------------------
 POINTER  PeekDataEx ( PDATASTACK *pds, INDEX nBack )
{
	POINTER p = NULL;
	nBack++;
	if( !(*pds) )
		return NULL;
	if( ( (int)((*pds)->Top) - (int)nBack ) >= 0 )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top - nBack) );
	return p;
}
//--------------------------------------------------------------------------
 POINTER  PeekData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( pds && *pds && (*pds)->Top )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top-1) );
	return p;
}
//--------------------------------------------------------------------------
void  EmptyDataStack( PDATASTACK *pds )
{
	if( pds && *pds )
		(*pds)->Top = 0;
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackEx ( size_t size DBG_PASS )
{
	return CreateDataStackLimitedEx( size, 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackLimitedEx ( size_t size, INDEX max_items DBG_PASS )
{
	PDATASTACK pds;
	pds = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( 10 * size ) DBG_RELAY );
	pds->Cnt = 10;
	pds->Top = 0;
	pds->Size = size;
	pds->Max = max_items;
	return pds;
}
//--------------------------------------------------------------------------
void DeleteDataStackEx( PDATASTACK *pds DBG_PASS )
{
	ReleaseEx( *pds DBG_RELAY );
	*pds = NULL;
}
#ifdef __cplusplus
//		namespace data_stack {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace queue {
#endif
static struct link_queue_local_data
{
	volatile uint32_t lock;
//#if !USE_CUSTOM_ALLOCER
	volatile PTHREAD thread;
//#endif
} s_link_queue_local, *_link_queue_local;
#ifdef __STATIC_GLOBALS__
#  define link_queue_local  ((s_link_queue_local))
#  define link_queue_local_thread  ((s_link_queue_local.thread))
#  define link_queue_local_lock  ((&s_link_queue_local.lock))
#else
#  define link_queue_local  ((_link_queue_local)?(*_link_queue_local):(s_link_queue_local))
#  define link_queue_local_thread  ((_link_queue_local)?(*_link_queue_local).thread:(s_link_queue_local.thread))
#  define link_queue_local_lock  ((_link_queue_local)?(&_link_queue_local->lock):(&s_link_queue_local.lock))
#endif
PLINKQUEUE CreateLinkQueueEx( DBG_VOIDPASS )
{
	PLINKQUEUE plq = 0;
 //-V557
	plq = (PLINKQUEUE)AllocateEx( MY_OFFSETOF( &plq, pNode[8] ) DBG_RELAY );
#if USE_CUSTOM_ALLOCER
	plq->Lock     = 0;
#endif
	plq->Top      = 0;
	plq->Bottom   = 0;
	plq->Cnt      = 8;
	plq->pNode[0] = NULL;
 // shrug
	plq->pNode[1] = NULL;
	return plq;
}
//--------------------------------------------------------------------------
void DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS )
{
	if( !pplq )
		return;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
#endif
	link_queue_local_lock[0] = 0;
	if( pplq )
	{
		if( *pplq )
			ReleaseEx( *pplq DBG_RELAY );
		*pplq = NULL;
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
#endif
	//link_queue_local_lock[0] = 0;
}
//--------------------------------------------------------------------------
static PLINKQUEUE ExpandLinkQueueEx( PLINKQUEUE *pplq, INDEX entries DBG_PASS )
{
	PLINKQUEUE plqNew = NULL;
#if USE_CUSTOM_ALLOCER
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
#endif
	if( pplq )
	{
		PLINKQUEUE plq = *pplq;
		INDEX size;
		int prior_logging;
		size = MY_OFFSETOF( pplq, pNode[plq->Cnt + entries] );
		prior_logging = SetAllocateLogging( FALSE );
		plqNew = (PLINKQUEUE)AllocateEx( size DBG_RELAY );
		plqNew->Cnt = plq->Cnt + entries;
		plqNew->Bottom = 0;
		if( plq->Bottom > plq->Top )
		{
			INDEX bottom_half;
			plqNew->Top = (bottom_half = plq->Cnt - plq->Bottom ) + plq->Top;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*bottom_half );
			MemCpy( plqNew->pNode + bottom_half, plq->pNode, sizeof(POINTER)*plq->Top );
		}
		else
		{
			plqNew->Top = plq->Top - plq->Bottom;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*plqNew->Top );
		}
		//need to make sure plq is always valid; can be trying to get a lock
		(*pplq) = plqNew;
		Release( plq );
		SetAllocateLogging( prior_logging );
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
	link_queue_local_lock[0] = 0;
#endif
	return plqNew;
}
//--------------------------------------------------------------------------
 PLINKQUEUE  EnqueLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
#if USE_CUSTOM_ALLOCER
	int keep_lock = 0;
#endif
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
#if USE_CUSTOM_ALLOCER
		if( link_queue_local_thread == MakeThread() )
		{
			keep_lock = 1;
			break;
		}
#endif
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		return (*pplq);
	}
	if( (*pplq)->Lock )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	if( !keep_lock )
	{
		if( _link_queue_local )
			_link_queue_local->thread = NULL;
		link_queue_local_lock[0] = 0;
	}
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	//else
	//	s_link_queue_local.thread = MakeThread();
	if( link )
	{
		tmp = plq->Top + 1;
		if( tmp >= plq->Cnt )
			tmp -= plq->Cnt;
 // collided with self...
		if( tmp == plq->Bottom )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Top + 1;
		}
		plq->pNode[plq->Top] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
void EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS )
 {
	INDEX tmp, t, c;
	PLINKQUEUE plq;
	if( !pplq )
		return;
	if( !( *pplq ) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
	plq = *pplq;
	if( link )
	{
		tmp = (t=plq->Top) + 1;
		if( tmp >= ( c = plq->Cnt ) )
			tmp -= c;
 // collided with self...
		if( tmp == ( plq->Bottom ) )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = (t=plq->Top) + 1;
		}
		plq->pNode[t] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
 }
 //--------------------------------------------------------------------------
 PLINKQUEUE  PrequeLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
		Relinquish();
#if USE_CUSTOM_ALLOCER
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return NULL;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	link_queue_local_lock[0] = 0;
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	if( link )
	{
		tmp = plq->Bottom - 1;
		if( tmp & 0x80000000 )
			tmp += plq->Cnt;
 // collided with self...
		if( tmp == plq->Top )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Cnt - 1;
		}
		plq->pNode[tmp] = link;
		plq->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsQueueEmpty ( PLINKQUEUE *pplq  )
{
	if( !pplq || !(*pplq) ||
		(*pplq)->Bottom == (*pplq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 INDEX  GetQueueLength ( PLINKQUEUE plq )
{
	INDEX used = 0;
	if( plq )
	{
		used = plq->Top - plq->Bottom;
		if( plq->Top < plq->Bottom )
			used += plq->Cnt;
	}
	return used;
}
//--------------------------------------------------------------------------
POINTER  PeekQueueEx	 ( PLINKQUEUE plq, int idx )
{
	size_t top;
	if( !plq )
		return NULL;
	if( idx < 0 )
	{
		idx++;
		for( top = plq->Top?(plq->Top - 1):(plq->Cnt-1)
			 ; idx && top != plq->Bottom
			  ; )
		{
			idx++;
			if( !top ) top = plq->Cnt - 1;
			else top--;
		}
		if( idx == 0 )
		{
			if( plq->Top == plq->Bottom )
				return NULL;
			return plq->pNode[top];
		}
	}
	else
	{
		for( top = plq->Bottom
			 ; idx != -1 && top != plq->Top
			  ; )
		{
			if( idx ) {
				top++;
				if( top >= plq->Cnt )
					top-=plq->Cnt;
				idx--;
			}else { idx = -1; break; }
		}
		if( idx == -1 )
			return plq->pNode[top];
	}
	return NULL;
}
POINTER  PeekQueue ( PLINKQUEUE plq )
{
	return PeekQueueEx( plq, 0 );
}
//--------------------------------------------------------------------------
POINTER  DequeLink ( PLINKQUEUE *pplq )
{
	POINTER p;
	INDEX tmp;
	if( pplq && *pplq )
	{
#if USE_CUSTOM_ALLOCER
		int keep_lock = 0;
#endif
		uint32_t priorline;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
		while( ( priorline = LockedExchange( link_queue_local_lock, __LINE__ ) ) )
		{
#if USE_CUSTOM_ALLOCER
			if( link_queue_local_thread == MakeThread() )
			{
				keep_lock = 1;
				break;
			}
#endif
			Relinquish();
		}
#if USE_CUSTOM_ALLOCER
		if( !pplq )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			return NULL;
		}
		if( (*pplq)->Lock )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			Relinquish();
			goto retry_lock;
		}
		(*pplq)->Lock = 1;
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
#else
		if( !(*pplq) )
		{
			//it could have been deallocated
			link_queue_local_lock[0] = 0;
			return (*pplq);
		}
#endif
	}
	else
		return NULL;
	p = NULL;
	if( (*pplq)->Bottom != (*pplq)->Top )
	{
		tmp = (*pplq)->Bottom + 1;
		if( tmp >= (*pplq)->Cnt )
			tmp -= (*pplq)->Cnt;
		p = (*pplq)->pNode[(*pplq)->Bottom];
		(*pplq)->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	(*pplq)->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return p;
}
POINTER  DequeLinkNL( PLINKQUEUE *pplq )
{
	INDEX b, t, c, tmp;
	POINTER p;
	if( !pplq || !*pplq )
		return NULL;
	p = NULL;
	if( (b=( *pplq )->Bottom) != (t=( *pplq )->Top) )
	{
		tmp = b + 1;
		if( tmp >= ( c = ( *pplq )->Cnt ) )
			tmp -= c;
		p = ( *pplq )->pNode[b];
		( *pplq )->Bottom = tmp;
	}
	return p;
}
#ifdef __cplusplus
//		namespace queue {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_queue {
#endif
static struct data_queue_local_data
{
	volatile uint32_t lock;
} s_data_queue_local, *_data_queue_local;
#ifdef __STATIC_GLOBALS__
#  define data_queue_local  ((s_data_queue_local))
#  define data_queue_local_lock ((&s_data_queue_local.lock))
#else
#  define data_queue_local  ((_data_queue_local)?(*_data_queue_local):(s_data_queue_local))
#  define data_queue_local_lock ((_data_queue_local)?(&_data_queue_local->lock):(&s_data_queue_local.lock))
#endif
PDATAQUEUE CreateDataQueueEx( INDEX size DBG_PASS )
{
	PDATAQUEUE pdq;
	pdq = (PDATAQUEUE)AllocateEx( ( ( sizeof( DATAQUEUE ) + (2*size) ) - 1 ) DBG_RELAY );
	pdq->Top      = 0;
	pdq->Bottom	  = 0;
	pdq->ExpandBy = 16;
	pdq->Size     = size;
	pdq->Cnt      = 2;
	return pdq;
}
//--------------------------------------------------------------------------
void DeleteDataQueueEx( PDATAQUEUE *ppdq DBG_PASS )
{
	if( ppdq )
	{
		if( *ppdq )
			ReleaseEx( *ppdq DBG_RELAY );
		*ppdq = NULL;
	}
}
//--------------------------------------------------------------------------
static PDATAQUEUE ExpandDataQueueEx( PDATAQUEUE *ppdq, INDEX entries DBG_PASS )
{
	PDATAQUEUE pdqNew = NULL;
	if( ppdq )
	{
		PDATAQUEUE pdq = *ppdq;
		//pdq->Cnt += entries;
		pdqNew = (PDATAQUEUE)AllocateEx( (uint32_t)offsetof( DATAQUEUE, data[0] ) + ((pdq->Cnt+entries)  * pdq->Size) DBG_RELAY );
		pdqNew->Cnt = pdq->Cnt + entries;
		pdqNew->ExpandBy = pdq->ExpandBy;
		pdqNew->Bottom = 0;
		pdqNew->Size = pdq->Size;
		if( pdq->Bottom > pdq->Top )
		{
			INDEX bottom_half;
			/* if you see '- entries' in a diff... it was decided to not add it to the original queue above, instead */
			pdqNew->Top = (bottom_half = ( pdq->Cnt ) - pdq->Bottom ) + pdq->Top;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * bottom_half );
			MemCpy( pdqNew->data + ( bottom_half * pdq->Size )
				, pdq->data
				, pdq->Size * pdq->Top );
		}
		else
		{
			pdqNew->Top = pdq->Top - pdq->Bottom;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * pdqNew->Top );
		}
		(*ppdq) = pdqNew;
		Release( pdq );
	}
	return pdqNew;
}
PDATAQUEUE  CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS )
{
	PDATAQUEUE pdq = CreateDataQueueEx( size DBG_RELAY );
	pdq->ExpandBy = expand;
	ExpandDataQueueEx( &pdq, entries DBG_RELAY );
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  EnqueDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Top + 1;
		if( tmp >= pdq->Cnt )
			tmp -= pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Bottom )
		{
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Top + 1;
		}
		MemCpy( pdq->data + ( pdq->Top * pdq->Size ), link, pdq->Size );
		pdq->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  PrequeDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Bottom - 1;
		if( tmp > 0x80000000 )
			tmp += pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Top )
		{
			// expand re-aligns queue elements so bottom is 0 and top is N
			// so the bottom will always wrap when we try to add to the beginning...
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Cnt - 1;
		}
		MemCpy( pdq->data + ( tmp * pdq->Size ), link, pdq->Size );
		pdq->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsDataQueueEmpty ( PDATAQUEUE *ppdq  )
{
	if( !ppdq || !(*ppdq) ||
		(*ppdq)->Bottom == (*ppdq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 LOGICAL  DequeData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Bottom + 1;
		if( tmp >= (*ppdq)->Cnt )
			tmp -= (*ppdq)->Cnt;
		if( result )
			MemCpy( result
					, (*ppdq)->data + (*ppdq)->Bottom * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 LOGICAL  UnqueData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Top;
		if( tmp )
			tmp--;
		else
			tmp = ((*ppdq)->Cnt)-1;
		if( result )
			MemCpy( result
					, (*ppdq)->data + tmp * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
// zero is the first,
#undef PeekDataQueueEx
 LOGICAL  PeekDataQueueEx ( PDATAQUEUE *ppdq, POINTER result, INDEX idx )
{
	INDEX top;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	// cannot get invalid id.
	if( idx != INVALID_INDEX )
	{
		for( top = (*ppdq)->Bottom;
			 idx != INVALID_INDEX && top != (*ppdq)->Top
			 ; )
		{
			idx--;
			if( idx != INVALID_INDEX )
			{
				top++;
				if( (top) >= (*ppdq)->Cnt )
					top = top-(*ppdq)->Cnt;
			}
		}
		if( idx == INVALID_INDEX )
		{
			MemCpy( result, (*ppdq)->data + top * (*ppdq)->Size, (*ppdq)->Size );
			data_queue_local_lock[0] = 0;
			return 1;
			//return (*ppdq)->pNode + top;
		}
	}
	data_queue_local_lock[0] = 0;
	return 0;
}
#undef PeekDataQueue
 LOGICAL  PeekDataQueue ( PDATAQUEUE *ppdq, POINTER result )
{
	return PeekDataQueueEx( ppdq, result, 0 );
}
void  EmptyDataQueue ( PDATAQUEUE *ppdq )
{
	if( ppdq && *ppdq )
	{
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
		(*ppdq)->Bottom = (*ppdq)->Top = 0;
		data_queue_local_lock[0] = 0;
	}
}
#ifdef __cplusplus
//		namespace data_queue {
};
#endif
#ifndef __STATIC_GLOBALS__
PRIORITY_PRELOAD( InitLocals, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
#  ifdef __cplusplus
	RegisterAndCreateGlobal((POINTER*)&list::_list_local, sizeof( *list::_list_local ), "_list_local" );
	RegisterAndCreateGlobal((POINTER*)&data_list::_data_list_local, sizeof( *data_list::_data_list_local ), "_data_list_local" );
	RegisterAndCreateGlobal((POINTER*)&queue::_link_queue_local, sizeof( *queue::_link_queue_local ), "_link_queue_local" );
	RegisterAndCreateGlobal((POINTER*)&data_queue::_data_queue_local, sizeof( *data_queue::_data_queue_local ), "_data_queue_local" );
#  else
	SimpleRegisterAndCreateGlobal( _list_local );
	SimpleRegisterAndCreateGlobal( _data_list_local );
	SimpleRegisterAndCreateGlobal( _link_queue_local );
	SimpleRegisterAndCreateGlobal( _data_queue_local );
#  endif
}
#endif
#ifdef __cplusplus
 //namespace sack {
}
 //	namespace containers {
}
#endif
//--------------------------------------------------------------
// $Log: typecode.c,v $
// Revision 1.47  2005/05/25 16:50:30  d3x0r
// Synch with working repository.
//
// Revision 1.56  2005/05/20 23:15:13  jim
// Remove a noisy logging statement
//
// Revision 1.55  2005/05/16 23:18:22  jim
// Allocate the correct amount of space for the message queue - it's a MSGQUEUE not a DATAQUEUE.  Also implement DequeMessage() in such a way that the waited for message ID can change.
//
// Revision 1.54  2005/05/02 17:02:58  jim
// Moved the process-wait information to a seperate queue... does not work inline with normal messages...
//
// Revision 1.53  2005/04/20 23:38:20  jim
// Fixed leaving the critical section under a loop condition that resulted in error.
//
// Revision 1.52  2005/04/18 15:55:59  jim
// Much logging added to sack's implementation of SYSV msgq communications.
//
// Revision 1.51  2005/03/22 12:33:50  panther
// Restore disabled message queue logging
//
// Revision 1.50  2005/03/17 02:23:53  panther
// Checkpoint - working on message server abstraction interface... some of this seems to work quite well, some of this is still broken very badly...
//
// Revision 1.49  2005/03/14 16:04:03  panther
// If someone is waiting for any message, then they are definatly waiting for the currently enquing message.
//
// Revision 1.48  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.47  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.46  2004/10/25 10:40:00  d3x0r
// Linux compilation cleaning requirements...
//
// Revision 1.45  2004/10/02 19:49:57  d3x0r
// Fix logging... trying to track down multiple update display issues.... keys are queued, events are locally queued...
//
// Revision 1.44  2004/09/30 22:02:43  d3x0r
// checkpoing
//
// Revision 1.43  2004/09/30 09:42:52  d3x0r
// Fixed message queues for single app, all wraps, and nearly for two apps, but when removing logging, lost stability :(
//
// Revision 1.42  2004/09/30 01:14:48  d3x0r
// Cleaned up consistancy of PID and thread ID... extended message service a bit to supply event PID both ways.
//
// Revision 1.41  2004/09/29 16:43:03  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.40  2004/09/29 00:49:00  d3x0r
// Store waiting thread IDs IN the message queue... need to figure out how to shuffle these around.
//
// Revision 1.39  2004/09/24 08:09:49  d3x0r
// Test tial meeting the head...
//
// Revision 1.38  2004/09/23 11:07:33  d3x0r
// Minor adjustments...
//
// Revision 1.37  2004/09/23 00:36:55  d3x0r
// Fix result code when error no message and no wait... fix test for read messages and end of queue messages.
//
// Revision 1.36  2004/08/16 06:32:10  d3x0r
// Fix message queue routines... protect against no handle
//
// Revision 1.35  2004/07/13 04:17:49  d3x0r
// clean some warnings, and fix definiton of PRELOAD to be compiler friendly.
//
// Revision 1.34  2004/06/12 09:09:41  d3x0r
// ug - if queue is empty peek must be NULL...
//
// Revision 1.33  2004/05/24 16:40:29  d3x0r
// Add PeekQueue and GetQUeueLength
//
// Revision 1.32  2003/11/28 20:21:35  panther
// Add and fix EmptyList
//
// Revision 1.31  2003/10/31 02:24:53  panther
// Modified test to take variable msg count.
//
// Revision 1.30  2003/10/26 23:40:46  panther
// minor type fixes
//
// Revision 1.29  2003/10/26 23:32:17  panther
// Looks like most issues with simple message queuing are done.
//
// Revision 1.28  2003/10/22 10:45:40  panther
// Handle null lists in find
//
// Revision 1.27  2003/10/21 01:39:37  panther
// Fixed some issues with new perma-wait critical sections...
//
// Revision 1.26  2003/10/20 03:01:21  panther
// Fix getmythreadid - split depending if getpid returns ppid or pid.
// Fix memory allocator to init region correctly...
// fix initial status of found thred to reflect sleeping
// in /proc/#/status
//
// Revision 1.25  2003/10/20 00:04:21  panther
// Extend OpenSpace in SharedMem
// revise msgqueue operations to more resemble sysVipc msgq
//
// Revision 1.24  2003/10/18 23:41:04  panther
// Checkpoint... probably defuct
//
// Revision 1.23  2003/10/18 04:43:00  panther
// Quick patch...
//
// Revision 1.22  2003/10/17 00:56:05  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.21  2003/08/20 08:07:13  panther
// some fixes to blot scaled... fixed to makefiles test projects... fixes to export containters lib funcs
//
// Revision 1.20  2003/07/25 10:21:57  panther
// Fix callback for foralllinks
//
// Revision 1.19  2003/05/12 01:31:52  panther
// Fix return
//
// Revision 1.18  2003/05/02 01:11:26  panther
// Many minor fixes, tweaks....
//
// Revision 1.17  2003/04/21 11:46:52  panther
// Ug - forgot a commit somewhere... return pointer at set data item
//
// Revision 1.16  2003/04/20 08:14:07  panther
// *** empty log message ***
//
// Revision 1.15  2003/04/12 20:52:46  panther
// Added new type contrainer - data list.
//
// Revision 1.14  2003/03/31 01:11:28  panther
// Tweaks to work better under service application
//
// Revision 1.13  2003/03/30 21:15:57  panther
// Added EX functions to pass application source to DataStack allocations
//
// Revision 1.12  2003/03/30 00:14:36  panther
// fix pop stack data function
//
// Revision 1.11  2003/01/28 16:37:48  panther
// More logging extended logging
//
// Revision 1.10  2003/01/27 09:20:34  panther
// Error in passing debug argument to create queue
//
// Revision 1.9  2003/01/22 17:10:09  panther
// Added forwarding in EnqueLink To CreateQueue
//
// Revision 1.8  2002/11/06 09:49:17  panther
// Fixed data-queue allocation/copy.
//
// Revision 1.7  2002/11/04 09:29:50  panther
// Added container class - DATAQUEUE.
//
//
//  - Added DataQueue to compliment LinkQueue  (datastack/linkstack)
//  - Added EmptyDataStack method to quickly remove all items on stack.
// Revision 1.6  2002/07/15 08:28:56  panther
// Fixed some debug passing to allocate.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   code to provide a robust text class for C
 *   Parsing, text substitution, replacment, phrase splitting
 *   options for paired parsing of almost all pairable symbols
 *   used in common language.
 *
 *
 * see also - include/typelib.h
 *
 */
#define NO_UNICODE_C
 // derefecing NULL pointers; the function wouldn't be called with a NULL.
 // and partial expressions in lower precision
// and NULL math because never NULL.
#pragma warning( disable:6011 26451 28182)
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace text {
	using namespace sack::memory;
	using namespace sack::logging;
	using namespace sack::containers::queue;
#endif
#pragma warning( disable:26451 )
typedef PTEXT (CPROC*GetTextOfProc)( uintptr_t, POINTER );
typedef struct text_exension_tag {
	uint32_t bits;
	GetTextOfProc TextOf;
	uintptr_t psvData;
}  TEXT_EXTENSION, *PTEXT_EXTENSION;
typedef struct vartext_tag {
	TEXTSTR collect_text;
	size_t collect_used;
	size_t collect_avail;
	size_t expand_by;
	PTEXT collect;
	PTEXT commit;
} VARTEXT;
//#ifdef __cplusplus
static PTEXT newline;
static PTEXT blank;
PRELOAD( AllocateDefaults )
{
	newline = (PTEXT)SegCreateFromText( "" );
	blank = (PTEXT)SegCreateFromText( " " );
}
//#define newline (*newline)
//#define blank	(*blank)
//#else
//__declspec( dllexport ) TEXT newline = { TF_STATIC, NULL, NULL, {1,1},{0,""}};
//__declspec( dllexport ) TEXT blank = { TF_STATIC, NULL, NULL, {1,1},{1," "}};
//#endif
static PLIST pTextExtensions;
//---------------------------------------------------------------------------
PTEXT SegCreateEx( size_t size DBG_PASS )
{
	PTEXT pTemp;
#if defined( _MSC_VER )
	//if( size > 0x8000 )
	//	_asm int 3;
#endif
	pTemp = (PTEXT)AllocateEx( sizeof(TEXT) + (size
#ifdef _MSC_VER
		+ 1
#endif
		)*sizeof(TEXTCHAR)
 // good thing [1] is already counted.
		DBG_RELAY );
	MemSet( pTemp, 0, sizeof(TEXT) + (size*sizeof(TEXTCHAR)) );
	pTemp->format.flags.prior_background = 1;
	pTemp->format.flags.prior_foreground = 1;
 // physical space IS one more....
	pTemp->data.size = size;
	return pTemp;
}
//---------------------------------------------------------------------------
PTEXT GetIndirect(PTEXT segment )
{
	if( !segment )
		return NULL;
	if( (segment->flags&TF_APPLICATION) )
	{
		INDEX idx;
		PTEXT_EXTENSION pte;
		LIST_FORALL( pTextExtensions, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->bits & segment->flags )
			{
				// size is used as a pointer...
				segment = pte->TextOf( pte->psvData, (POINTER)segment->data.size );
				break;
			}
		}
		if( !pte )
			return NULL;
		return segment;
	}
	// if it's not indirect... don't result..
	if( !(segment->flags&TF_INDIRECT) )
		return NULL;
	return (PTEXT)(segment->data.size);
}
//---------------------------------------------------------------------------
TEXTSTR GetText( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			return segment->data.data;
	}
	return NULL;
}
//---------------------------------------------------------------------------
size_t GetTextSize( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			if( !segment->data.size )
			{
				if( segment->flags & IS_DATA_FLAGS )
				{
					//lprintf( "Is Data falgs returns 2. %08x", segment->flags & IS_DATA_FLAGS );
 // is data even if is not acurate....
					return segment->data.size;
				}
				break;
			}
			else
				return segment->data.size;
	}
	return 0;
}
//---------------------------------------------------------------------------
uint32_t GetTextFlags( PTEXT segment )
{
	if( !segment )
		return 0;
	if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		return GetTextFlags( GetIndirect( segment ) );
	return segment->flags;
}
//---------------------------------------------------------------------------
void SegCopyFormat( PTEXT to_this, PTEXT copy_this )
{
	if( to_this && copy_this )
	{
		if( copy_this && !( copy_this->flags & TF_FORMATPOS ) )
		{
			to_this->format.position.offset.tabs = copy_this->format.position.offset.tabs;
			to_this->format.position.offset.spaces = copy_this->format.position.offset.spaces;
		}
		else
		{
			// copy absolute positioning...
		}
	}
}
//---------------------------------------------------------------------------
PTEXT SegDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT t;
	size_t n;
	if( pText )
	{
		if( pText->flags & TF_APPLICATION )
		{
			t = SegCreateIndirect( (PTEXT)pText->data.size );
			t->format = pText->format;
			t->flags = pText->flags;
		}
		else if( pText->flags & TF_INDIRECT )
		{
			t = SegCreateIndirectEx( SegDuplicateEx( GetIndirect( pText ) DBG_RELAY ) DBG_RELAY );
			t->format = pText->format;
			// some other mask needs to be here.. the getindirect
			// will have other flags...
			t->flags = pText->flags;
		}
		else
		{
			t = SegCreateEx( n = GetTextSize( pText ) DBG_RELAY );
			t->format = pText->format;
			MemCpy( GetText(t), GetText(pText), sizeof( TEXTCHAR ) * ( n + 1 ) );
			t->flags = pText->flags;
		}
		t->flags &= ~(TF_DEEP|TF_STATIC);
		return t;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT LineDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT pt;
	pt = pText;
	while( pt )
	{
		if( !(pt->flags&TF_STATIC) )
			HoldEx( (uint8_t*)pt DBG_RELAY  );
		if( (pt->flags & TF_INDIRECT ) || (pt->flags&TF_APPLICATION) )
			LineDuplicateEx( GetIndirect( pt ) DBG_RELAY );
		pt = NEXTLINE( pt );
	}
	return pText;
}
//---------------------------------------------------------------------------
PTEXT TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS )
{
	PTEXT pt;
	PTEXT pDup = NULL, pNew;
	pt = pText;
	while( pt )
	{
		if( (pt->flags & TF_INDIRECT ) && !(pt->flags&TF_APPLICATION) )
		{
			pNew = SegCreateIndirectEx(
			            TextDuplicateEx(
			                  GetIndirect( pt ), bSingle DBG_RELAY ) DBG_RELAY );
			pNew->format.position = pt->format.position;
			pNew->flags |= pt->flags&(IS_DATA_FLAGS);
			pNew->flags |= TF_DEEP;
		}
		else
			pNew = SegDuplicateEx( pt DBG_RELAY );
		pDup = SegAppend( pDup, pNew );
		if( bSingle )
			break;
		pt = NEXTLINE( pt );
	}
	return pDup;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromTextEx( CTEXTSTR text DBG_PASS )
{
	PTEXT pTemp;
	size_t nSize;
	if( text )
	{
		pTemp = SegCreateEx( nSize = StrLen( text ) DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
		pTemp = SegCreateEx( len DBG_RELAY );
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( len + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharEx( const char *text DBG_PASS )
{
	return SegCreateFromCharLenEx( text, strlen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideLenEx( const wchar_t *text, size_t nSize DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
		TEXTSTR text_string = WcharConvertLen( text, nSize );
		int outlen;
		for( outlen = 0; text_string[outlen]; outlen++ );
		pTemp = SegCreateEx( outlen DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( outlen + 1 ) );
		Deallocate( TEXTSTR, text_string );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideEx( const wchar_t *text DBG_PASS )
{
	return SegCreateFromWideLenEx( text, wcslen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromIntEx( int value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 12 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 12, "%d", value );
	pResult->data.data[11] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFrom_64Ex( int64_t value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 32, "%" _64f, value );
pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromFloatEx( float value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 32, "%f", value );
	pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateIndirectEx( PTEXT pText DBG_PASS )
{
	PTEXT pSeg;
 // no data content for indirect...
	pSeg = SegCreateEx( -1 DBG_RELAY );
	pSeg->flags |= TF_INDIRECT;
	pSeg->data.size = (uintptr_t)pText;
	return pSeg;
}
//---------------------------------------------------------------------------
  // remove leading segments.
PTEXT SegBreak(PTEXT segment)
	 // return leading segments!  might be ORPHANED if not handled.
{
	PTEXT temp;
	if( !segment )
		return NULL;
	if((temp=PRIORLINE(segment)))
		SETNEXTLINE(temp,NULL);
	SETPRIORLINE(segment,NULL);
	return(temp);
}
INDEX  GetSegmentSpaceEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs)
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < nTabs && (INDEX)position > tabs[n]; n++ );
			if( n < nTabs )
				// now position is before the first tab... such that
				for( ; n < nTabs && n < segment->format.position.offset.tabs; n++ )
				{
					total += tabs[n]-position;
					position = tabs[n];
				}
			//lprintf( "Adding %d spaces", segment->format.position.offset.spaces );
			total += segment->format.position.offset.spaces;
		}
	}
	while( segment && (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize )
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < segment->format.position.offset.tabs; n++ )
			{
				if( !total )
					// I think this is wrong.  need to validate this equation.
					total += (position % nTabSize) + 1;
				else
					total += nTabSize;
			}
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLengthEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpaceEx( segment, position, nTabs, tabs ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLength ( PTEXT segment, size_t position, int nTabSize )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpace( segment, position, nTabSize ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
PTEXT SegAppend(PTEXT source,PTEXT other)
{
	PTEXT temp=source;
	if( temp )
	{
		if( other )
		{
			SetEnd(temp);
			SETNEXTLINE(temp,other);
			SETPRIORLINE(other,temp);
		}
	}
	else
	{
  // nothing was before...
		source=other;
	}
	return(source);
}
//---------------------------------------------------------------------------
void SegReleaseEx( PTEXT seg DBG_PASS)
{
	if( seg )
		ReleaseEx( seg DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegExpandEx(PTEXT source, INDEX nSize DBG_PASS)
{
	PTEXT temp;
	//Log1( "SegExpand...%d", nSize );
	temp = SegCreateEx( GetTextSize( source ) + nSize  DBG_RELAY );
	if( source )
	{
		MemCpy( temp->data.data, source->data.data, sizeof( TEXTCHAR)*(GetTextSize( source ) + 1) );
		temp->flags = source->flags;
		temp->format = source->format;
		SegSubst( temp, source );
		SegRelease( source );
	}
	return temp;
}
//---------------------------------------------------------------------------
void LineReleaseEx(PTEXT line DBG_PASS )
{
	PTEXT temp;
	if( !line )
		return;
	SetStart(line);
	while(line)
	{
		temp=NEXTLINE(line);
		if( !(line->flags&TF_STATIC) )
		{
			if( (( line->flags & (TF_INDIRECT|TF_DEEP) ) == (TF_INDIRECT|TF_DEEP) ) )
 // if indirect, don't want to release application content
				if( !(line->flags & TF_APPLICATION) )
					LineReleaseEx( GetIndirect( line ) DBG_RELAY );
			ReleaseEx( line DBG_RELAY );
		}
		line=temp;
	}
}
//---------------------------------------------------------------------------
PTEXT SegConcatEx(PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS )
{
	size_t idx=0;
	size_t len=0;
	PTEXT newseg;
	SegAppend( output, newseg = SegCreateEx( length DBG_RELAY ) );
	output = newseg;
	//output=SegExpandEx(output, length DBG_RELAY); /* add 1 for a null */
	GetText(output)[0]=0;
	while (input&&idx<length)
	{
		//#define min(a,b) (((a)<(b))?(a):(b))
		if( ( GetTextSize( input ) - offset ) < ( length-idx  ) )
			len = GetTextSize( input ) - offset;
		else
         len = length - idx;
		MemCpy( GetText(output) + idx,
				  GetText(input) + offset,
				  sizeof( TEXTCHAR ) * ( len + 1 ) );
		idx += len;
		offset = 0;
		input=NEXTLINE(input);
	}
	GetText(output)[idx]=0;
	return(output);
}
//---------------------------------------------------------------------------
PTEXT SegUnlink(PTEXT segment)
{
	PTEXT temp;
	if (segment)
	{
		if( ( temp = PRIORLINE(segment) ) )
			SETNEXTLINE(temp,NEXTLINE(segment));
		if( ( temp = NEXTLINE(segment) ) )
			SETPRIORLINE(temp,PRIORLINE(segment));
		SETPRIORLINE(segment, NULL);
		SETNEXTLINE(segment, NULL);
	}
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegGrab( PTEXT segment )
{
	SegUnlink( segment );
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegDelete( PTEXT segment )
{
	LineReleaseEx( SegGrab( segment ) DBG_SRC );
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegInsert( PTEXT what, PTEXT before )
{
	PTEXT that_start = what ,
			that_end= what;
	SetStart( that_start );
	SetEnd( that_end );
	if( before )
	{
		if( ( that_start->Prior = before->Prior) )
			that_start->Prior->Next = that_start;
		if( ( that_end->Next = before ) )
			that_end->Next->Prior = that_end;
	}
	return what;
}
//---------------------------------------------------------------------------
PTEXT SegSubst( PTEXT _this, PTEXT that )
{
	PTEXT that_start = that ,
			that_end= that;
	SetStart( that_start );
	SetEnd( that_end );
	if( ( that_end->Next = _this->Next ) )
		that_end->Next->Prior = that_end;
	if( ( that_start->Prior = _this->Prior) )
		that_start->Prior->Next = that_start;
	_this->Next = NULL;
	_this->Prior = NULL;
	return _this;
}
//---------------------------------------------------------------------------
PTEXT SegSplitEx( PTEXT *pLine, INDEX nPos  DBG_PASS)
{
	// there includes the character at nPos - so all calculations
	// on there are +1...
	PTEXT here, there;
	size_t nLen;
	nLen = GetTextSize( *pLine );
	if( nPos > nLen )
	{
		return NULL;
	}
	if( nPos == nLen )
		return *pLine;
	here = SegCreateEx( nPos DBG_RELAY );
 //-V595
	here->flags  = (*pLine)->flags;
	here->format = (*pLine)->format;
	there = SegCreateEx( (nLen - nPos) DBG_RELAY );
 //-V595
	there->flags  = (*pLine)->flags;
	there->format = (*pLine)->format;
 // was two characters presumably...
	there->format.position.offset.spaces = 0;
	there->format.position.offset.tabs = 0;
	MemCpy( GetText( here ), GetText( *pLine ), sizeof(TEXTCHAR)*nPos );
	GetText( here )[nPos] = 0;
	if( nLen - nPos )
	{
		MemCpy( GetText( there ), GetText( *pLine ) + nPos, sizeof(TEXTCHAR)*(nLen - nPos) );
		GetText( there )[nLen-nPos] = 0;
	}
	SETNEXTLINE( PRIORLINE( *pLine ), here );
	SETPRIORLINE( here, PRIORLINE( *pLine ) );
	SETNEXTLINE( here, there );
	SETPRIORLINE( there, here );
	SETNEXTLINE( there, NEXTLINE( *pLine ) );
	SETPRIORLINE( NEXTLINE( *pLine ), there );
	SETNEXTLINE( *pLine, NULL );
	SETPRIORLINE( *pLine, NULL );
	LineReleaseEx( *pLine DBG_RELAY );
	*pLine = here;
	return here;
}
//----------------------------------------------------------------------
TEXTCHAR NextCharEx( PTEXT input, size_t idx )
{
	if( ( ++idx ) >= input->data.size )
	{
		idx -= input->data.size;
		input = NEXTLINE( input );
	}
	if( input )
		return input->data.data[idx];
	return 0;
}
#define NextChar() NextCharEx( input, index )
//----------------------------------------------------------------------
// In this final implementation - it was decided that for a general
// library, that expressions, escapes of expressions, apostrophes
// were of no consequence, and without expressions, there is no excess
// so this simply is text stream in, text stream out.
// these are just shortcuts - these bits of code were used repeatedly....
#define SET_SPACES() do {		word->format.position.offset.spaces = (uint16_t)spaces;		 word->format.position.offset.tabs = (uint16_t)tabs;		                             spaces = 0;		                                                         tabs = 0; } while(0)
//static CTEXTSTR normal_punctuation="\'\"\\({[<>]}):@%/,;!?=*&$^~#`";
//static CTEXTSTR not_punctuation;
PTEXT TextParse( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_space, int bTabs, int bSpaces  DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
	   burst into its block pieces.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
	      word;
	TEXTSTR tempText;
	int has_minus = -1;
	int has_plus = -1;
	uint32_t index;
	INDEX size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
	   spaces = 0, tabs = 0;
        // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, TextParse( GetIndirect( input ), punctuation, filter_space, bTabs, bSpaces DBG_RELAY ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( "Assuming %d spaces... ", spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
                   (index < size); index++)
                                         // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( "VarTextGet Failed to result." );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
		if( StrChr( filter_space, character ) )
		{
			goto is_a_space;
		}
		else if( StrChr( punctuation, character ) )
		{
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
				outdata = SegAppend( outdata, word );
				SET_SPACES();
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				outdata = SegAppend( outdata, word );
			}
			else
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		else switch(character)
		{
		case '\n':
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
					SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
 // add a line-break packet
			outdata = SegAppend( outdata, SegCreate( 0 ) );
			break;
		case ' ':
			if( bSpaces )
			{
			is_a_space:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			}
 //-V517
				if(0) {
		case '\t':
					if( bTabs )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							SET_SPACES();
							outdata = SegAppend( outdata, word );
						}
						if( spaces )
						{
						//lprintf( "Input stream has mangled spaces and tabs." );
 // assume that the tab takes care of appropriate spacing
							spaces = 0;
						}
						tabs++;
						break;
					}
 //-V517
				} else if(0) {
 // a space space character...
		case '\r':
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					break;
 //-V517
				} else if(0) {
 // handle multiple periods grouped (elipses)
		case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
						  ( c = NextChar() ) &&
						  ( c == '.' ) ) )
						{
							if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
							{
								outdata = SegAppend( outdata, word );
								SET_SPACES();
							}
							VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
							elipses = TRUE;
							break;
						}
						if( ( c = NextChar() ) &&
							( c >= '0' && c <= '9' ) )
						{
							// gather together as a floating point number...
							VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
							break;
						}
					}
				} else if(0) {
  // work seperations flaming-long-sword
				case '-':
					if( has_minus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_minus = 1;
						else
							has_minus = 0;
					}
					if( !has_minus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
				case '+':
				{
					int c;
					if( has_plus == -1 ) {
						if( !punctuation || StrChr( punctuation, '+' ) )
							has_plus = 1;
						else
							has_plus = 0;
					}
					if( !has_plus )
					{
						VarTextAddCharacterEx( &out, '+' DBG_OVERRIDE );
						break;
					}
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
							// gather together as a sign indication on a number.
						}
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
				}
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
PTEXT burstEx( PTEXT input DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
//#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
		burst into its block pieces.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
			word;
	TEXTSTR tempText;
	uint32_t index;
	size_t size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
		spaces = 0, tabs = 0;
		  // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, burst( GetIndirect( input ) ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( "Assuming %d spaces... ", spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
		             (index < size); index++)
		                                      // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( "VarTextGet Failed to result." );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
			switch(character)
			{
			case '\n':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
 // add a line-break packet
				outdata = SegAppend( outdata, SegCreate( 0 ) );
				break;
			case ' ':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			case '\t':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				if( spaces )
				{
				//lprintf( "Input stream has mangled spaces and tabs." );
					spaces = 0;
				}
				tabs++;
				break;
 // a space space character...
			case '\r':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
 // handle multiple periods grouped (elipses)
			case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
							( c = NextChar() ) &&
							( c == '.' ) ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
						elipses = TRUE;
						break;
					}
					if( ( c = NextChar() ) &&
						 ( c >= '0' && c <= '9' ) )
					{
						// gather together as a floating point number...
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
  // work seperations flaming-long-sword
			case '-':
			case '+':
				{
					int c;
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						// gather together as a sign indication on a number.
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
 // single quote bound
			case '\'':
 // double quote bound
			case '\"':
 // escape next thingy... unusable in c processor
			case '\\':
 // expression bounders
			case '(':
			case '{':
			case '[':
			case '<':
 // expression closers
			case ')':
			case '}':
			case ']':
			case '>':
  // internet addresses
			case ':':
  // email addresses
			case '@':
			case '%':
			case '/':
			case ',':
			case ';':
			case '!':
			case '?':
			case '=':
			case '*':
			case '&':
			case '$':
			case '^':
			case '~':
			case '#':
			case '`':
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
//---------------------------------------------------------------------------
#undef LineLengthExx
size_t LineLengthExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL )
{
	return LineLengthExEx( pt, bSingle, 8, pEOL );
}
size_t LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL )
{
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	size_t length = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		if( !(pt->flags & ( IS_DATA_FLAGS | TF_INDIRECT)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
				length += pEOL->data.size;
			else
 // full binary \r\n insertion assumed
				length += 2;
		}
		else
		{
			if( skipspaces )
				skipspaces = FALSE;
			else
			{
				if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
 // not-including NULL.
					length += GetSegmentSpace( pt, length, nTabsize );
			}
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top seg.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
 // not-including NULL.
				length += GetTextSize( pt );
stack_resume:
			if( pt->flags&TF_TAG )
				length += 2;
			if( pt->flags&TF_PAREN )
				length += 2;
			if( pt->flags&TF_BRACE )
				length += 2;
			if( pt->flags&TF_BRACKET )
				length += 2;
			if( pt->flags&TF_QUOTE )
				length += 2;
			if( pt->flags&TF_SQUOTE )
				length += 2;
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
//	if( length > 60000 )
//		_asm int 3;
	return length;
}
#undef LineLengthEx
INDEX LineLengthEx( PTEXT pt, LOGICAL bSingle )
{
	return LineLengthExx( pt, bSingle, NULL );
}
//---------------------------------------------------------------------------
// attempts to build a solitary line segment from the text passed
// however, if there are color changes, or absolute position changes
// this cannot work... and it must provide multiple pieces...
#undef BuildLineExx
PTEXT BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS )
{
	return BuildLineExEx( pt, bSingle, 8, pEOL DBG_RELAY );
}
PTEXT BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS )
{
	TEXTSTR buf;
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack, firstadded;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	PTEXT pOut;
	uintptr_t ofs;
	{
		INDEX len;
		len = LineLengthExx( pt,bSingle,pEOL );
		if( !len )
			return NULL;
		pOut = SegCreateEx( len DBG_RELAY );
		firstadded = TRUE;
		buf = GetText( pOut );
	}
	ofs = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		// test color fields vs PRIOR_COLOR
		// if either the color IS the prior color - OR the value IS PRIOR_COLOR
		// then they can still be collapsed... DEFAULT_COLOR MAY be prior color
		// but there's no real telling... default is more like after a
		// attribute reset occurs...
		if( firstadded )
		{
			pOut->format.flags.foreground = pt->format.flags.foreground;
			pOut->format.flags.background = pt->format.flags.background;
			firstadded = FALSE;
		}
		else
		{
			if( ( !pt->format.flags.prior_foreground &&
				  !pt->format.flags.default_foreground &&
					pt->format.flags.foreground != pOut->format.flags.foreground ) ||
				 ( !pt->format.flags.prior_background &&
				  !pt->format.flags.default_background &&
					pt->format.flags.background != pOut->format.flags.background )
			  )
			{
				PTEXT pSplit;
				// ofs is the next valid character position....
				//Log( "Changing segment's color..." );
				if( ofs )
				{
					pSplit = SegSplitEx( &pOut, ofs DBG_RELAY );
					if( !pSplit )
					{
						lprintf( "Line was shorter than offset: %" _size_f " vs %" _PTRSZVALfs "", GetTextSize( pOut ), ofs );
					}
					pOut = NEXTLINE( pSplit );
					// new segments takes on the new attributes...
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
						//Log2( "Split at %d result %d", ofs, GetTextSize( pOut ) );
						buf = GetText( pOut );
					ofs = 0;
				}
				else
				{
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
				}
			}
		}
		if( !(pt->flags& (TF_INDIRECT|IS_DATA_FLAGS)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
			{
				MemCpy( buf + ofs, pEOL->data.data, sizeof( TEXTCHAR )*(pEOL->data.size + 1) );
				ofs += pEOL->data.size;
			}
			else
			{
				buf[ofs++] = '\r';
				buf[ofs++] = '\n';
			}
		}
		else
		{
			if( skipspaces )
			{
				skipspaces = FALSE;
			}
			else if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
			{
				size_t spaces = GetSegmentSpace( pt, ofs, nTabsize );
				// else we cannot collapse into single line (similar to colors.)
				while( spaces-- )
				{
					buf[ofs++] = ' ';
				}
			}
			// at this point spaces before tags, and after tags
			// which used to be expression level parsed are not
			// reconstructed correctly...
			if( pt->flags&TF_TAG )
				buf[ofs++] = '<';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = '(';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '{';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = '[';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
			{
				size_t len;
				MemCpy( buf+ofs, GetText( pt ), sizeof( TEXTCHAR) * (len = GetTextSize( pt ))+1 );
					ofs += len;
			}
stack_resume:
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = ']';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '}';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = ')';
			if( pt->flags&TF_TAG )
				buf[ofs++] = '>';
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
 // have to return length instead of new text seg...
	if( !pOut )
		return (PTEXT)ofs;
 // if formatting was inserted into the stream...
	SetStart( pOut );
	return pOut;
}
#undef BuildLineEx
PTEXT BuildLineEx( PTEXT pt, int bSingle DBG_PASS )
{
	return BuildLineExx( pt, bSingle, FALSE DBG_RELAY );
}
PTEXT FlattenLine( PTEXT pLine )
{
	 PTEXT pCur, p;
	 pCur = pLine;
	 // all indirected segments get promoted to
	 // the first level...
	 while( pCur )
	 {
		  if( pCur->flags & TF_STATIC )
		  {
			  p = SegDuplicate( pCur );
			  if( p )
			  {
				  SegSubst( pCur, p );
				  if( pCur == pLine )
					  pLine = p;
				  LineReleaseEx( pCur DBG_SRC );
				  pCur = p;
			  }
			  else
			  {
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
					continue;
			  }
		  }
		  if( pCur->flags & TF_INDIRECT )
		  {
				if( pCur->flags & TF_DEEP )
				{
					 p = FlattenLine( GetIndirect( pCur ) );
					 pCur->flags &= ~TF_DEEP;
				}
				else
				{
					 p = TextDuplicate( GetIndirect( pCur ), FALSE );
				}
				if( p )
				{
					SegSubst( pCur, p );
					if( pCur == pLine )
						pLine = p;
					p->flags |= pCur->flags & (~(TF_INDIRECT|TF_DEEP));
					LineReleaseEx( pCur DBG_SRC );
					pCur = p;
				}
				else
				{
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
				}
				continue;
		  }
		  pCur = NEXTLINE( pCur );
	 }
	 return pLine;
}
//----------------------------------------------------------------------------
POINTER GetApplicationPointer( PTEXT text )
{
	// okay indirects up to application data are okay.
	while( ( text->flags & TF_INDIRECT ) && !(text->flags & TF_APPLICATION) )
		return GetApplicationPointer( (PTEXT)text->data.size );
	if( text->flags & TF_APPLICATION )
		return (POINTER)text->data.size;
	return NULL;
}
//----------------------------------------------------------------------------
void SetApplicationPointer( PTEXT text, POINTER p)
{
	// sets only this segment.
	if( text )
	{
		text->flags |= TF_APPLICATION;
		text->data.size = (uintptr_t)p;
	}
}
//----------------------------------------------------------------------------
void RegisterTextExtension( uint32_t flags, PTEXT(CPROC*TextOf)(uintptr_t,POINTER), uintptr_t psvData)
{
	PTEXT_EXTENSION pte = (PTEXT_EXTENSION)Allocate( sizeof( TEXT_EXTENSION ) );
	pte->bits = flags;
	pte->TextOf = TextOf;
	pte->psvData = psvData;
	AddLink( &pTextExtensions, pte );
#if 0
	if( text && ( text->flags & TF_APPLICATION ) )
	{
		INDEX idx;
		PTEXT_EXENSTION pte;
		LIST_FORALL( pTextExtension, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->flags & text->flags )
			{
				text = pte->TextOf( text );
				break;
			}
		}
	}
#endif
	return;
}
//---------------------------------------------------------------------------
int TextIs( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextLike( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCaseCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextSimilar( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
	{
		size_t len1 = data ? StrLen( data ) : 0;
		size_t len2 = string ? StrLen( string ) : 0;
		return !StrCaseCmpEx( data, string, textmin( len1, len2 ) );
	}
	return 0;
}
//---------------------------------------------------------------------------
int SameText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	CTEXTSTR d2 = GetText( l2 );
	if( d1 && d2 )
		return StrCmp( d1, d2 );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int LikeText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	size_t len1 = d1 ? StrLen( d1 ) : 0;
	CTEXTSTR d2 = GetText( l2 );
	size_t len2 = d2 ? StrLen( d2 ) : 0;
	if( d1 && d2 )
		return StrCaseCmpEx( d1, d2, textmin( len1, len2 ) );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int CompareStrings( PTEXT pt1, int single1
                  , PTEXT pt2, int single2
                  , int bExact )
{
	while( pt1 && pt2 )
	{
		while( pt1 &&
				 pt1->flags && ( pt1->flags & TF_BINARY ) )
			pt1 = NEXTLINE( pt1 );
		while( pt2 &&
				 pt2->flags && ( pt2->flags & TF_BINARY ) )
			pt2 = NEXTLINE( pt2 );
		if( !pt1 && pt2 )
			return FALSE;
		if( pt1 && !pt2 )
			return FALSE;
		if( bExact )
		{
			if( SameText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		else
		{
			// Like returns string compare function literal...
			if( LikeText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		if( !single1 )
		{
			pt1 = NEXTLINE( pt1 );
			if( pt1 &&
				 !GetTextSize( pt1 ) && !(pt1->flags & IS_DATA_FLAGS))
				pt1 = NULL;
		}
		else
			pt1 = NULL;
		if( !single2 )
		{
			pt2 = NEXTLINE( pt2 );
			if( pt2 &&
				 !GetTextSize( pt2 ) &&
				 !(pt2->flags & IS_DATA_FLAGS))
				pt2 = NULL;
		}
		else
			pt2 = NULL;
	}
	if( !pt1 && !pt2 )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromTextRef( CTEXTSTR *p_ )
{
	CTEXTSTR p = p_[0];
	int s;
	int begin;
	int64_t num;
	LOGICAL altBase = FALSE;
	LOGICAL altBase2 = FALSE;
	int64_t base = 10;
	if( !p )
		return 0;
	//if( pText->flags & TF_INDIRECT )
	//   return IntCreateFromSeg( GetIndirect( pText ) );
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '.' )
			break;
		else if( *p == '+' )
		{
		}
		else if( *p == '-' && begin)
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( !altBase2 ) {
				if( *p == 'x' ) { altBase2 = TRUE; base = 16; }
				else if( *p == 'o' ) { altBase2 = TRUE; base = 8; }
				else if( *p == 'b' ) { altBase2 = TRUE; base = 2; }
				else break;
			} else {
				if( base > 10 ) {
					if( *p >= 'a' && *p <= 'f' ) {
						num *= base;
						num += *p - 'a' + 10;
					}
					else if( *p >= 'A' && *p <= 'F' ) {
						num *= base;
						num += *p - 'A' + 10;
					}
					else break;
				}
				else break;
			}
		}
		else
		{
			if( ( !altBase ) && (*p == '0') ) { altBase = TRUE; base = 8; }
			else { if( (*p - '0') >= base ) { break; } altBase = TRUE; }
			num *= base;
			num += *p - '0';
		}
		begin = FALSE;
		p++;
	}
	p_[0] = p;
	if( s & 1 )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromText( CTEXTSTR p )
{
	return IntCreateFromTextRef( &p );
}
//--------------------------------------------------------------------------
int64_t IntCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !pText || !p )
		return FALSE;
	if( pText->flags & TF_INDIRECT )
		return IntCreateFromSeg( GetIndirect( pText ) );
	return IntCreateFromText( p );
}
//--------------------------------------------------------------------------
double FloatCreateFromText( CTEXTSTR p, CTEXTSTR *vp )
{
	return strtod( p, (char **)vp );
	int s, begin, bDec = FALSE;
	double num;
	double base = 1;
	double temp;
	if( !p )
	{
		if( vp )
			(*vp) = p;
		return 0;
	}
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '-' && begin )
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( *p == '.' )
			{
				bDec = TRUE;
				base = 0.1;
			}
			else
				break;
		}
		else
		{
			if( bDec )
			{
				temp = *p - '0';
				num += base * temp;
				base /= 10;
			}
			else
			{
				num *= 10;
				num += *p - '0';
			}
		}
		begin = FALSE;
		p++;
	}
	if( vp )
		(*vp) = p;
	if( s )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
double FloatCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !p )
		return FALSE;
	return FloatCreateFromText( p, NULL );
}
//--------------------------------------------------------------------------
// if bUseAll - all segments must be part of the number
// otherwise, only as many segments as are needed for the number are used...
int IsSegAnyNumberEx( PTEXT *ppText, double *fNumber, int64_t *iNumber, int *bIntNumber, int bUseAll )
{
	CTEXTSTR pCurrentCharacter = NULL;
	PTEXT pBegin;
	PTEXT pText = *ppText;
	int decimal_count, s, begin = TRUE, digits;
	// remember where we started...
	// if the first segment is indirect, collect it and only it
	// as the number... making indirects within a number what then?
	if( pText->flags & TF_INDIRECT )
	{
		int status;
		PTEXT pTemp = GetIndirect( pText );
		if( pTemp
			&& (status = IsSegAnyNumberEx( &pTemp, fNumber, iNumber, bIntNumber, TRUE )) )
		{
			// step to next token - so we toss just this
			// one indirect statement.
			if( fNumber || iNumber )
			{
				// if resulting with a number, then step the text...
				(*ppText) = NEXTLINE( pText );
			}
			return status;
		}
		// not a number....
		return FALSE;
	}
	pBegin = pText;
	decimal_count = 0;
	s = 0;
	digits = 0;
	while( pText )
	{
		// at this point... is this really valid?
		if( pText->flags & TF_INDIRECT )
		{
			lprintf( "Encountered indirect segment gathering number, stopping." );
			break;
		}
		if( !begin &&
			( pText->format.position.offset.spaces || pText->format.position.offset.tabs ) )
		{
			// had to continue with new segment, but it had spaces so stop now
			break;
		}
		pCurrentCharacter = GetText( pText );
		while( pCurrentCharacter && *pCurrentCharacter )
		{
			if( *pCurrentCharacter == '.' )
			{
				if( !decimal_count )
					decimal_count++;
				else
					break;
			}
			else if( ((*pCurrentCharacter) == '-') && begin)
			{
				s++;
			}
			else if( ((*pCurrentCharacter) < '0') || ((*pCurrentCharacter) > '9') )
			{
				if( digits && ( pCurrentCharacter == GetText( pText ) ) )
				{
					pCurrentCharacter = GetText( PRIORLINE( pText ) );
					while( pCurrentCharacter[0] )
					{
						// if the number ended in a decimal, it can qualify as an integer
						if( pCurrentCharacter[0] == '.' && !pCurrentCharacter[1] )
							decimal_count--;
						pCurrentCharacter++;
					}
					pText = NULL;
				}
				break;
			}
			else
				digits++;
			begin = FALSE;
			pCurrentCharacter++;
		}
		// invalid character - stop, we're to abort.
		if( *pCurrentCharacter )
			break;
		pText = NEXTLINE( pText );
 //while( pText );
	}
	if( bUseAll && pText )
		// it's not a number, cause we didn't use all segments to get one
		return FALSE;
	if( *pCurrentCharacter || ( decimal_count > 1 ) || !digits )
	{
		// didn't collect enough meaningful info to be a number..
		// or information in this state is
		return FALSE;
	}
	// yeah it was a number, update the incoming pointer...
	if( fNumber || iNumber )
	{
		// if resulting with a number, then step the text...
		(*ppText) = pText;
	}
	if( decimal_count == 1 )
	{
		if( fNumber )
			(*fNumber) = FloatCreateFromSeg( pBegin );
		if( bIntNumber )
			(*bIntNumber) = 0;
 // return specifically it's a floating point number
		return 2;
	}
	if( iNumber )
		(*iNumber) = IntCreateFromSeg( pBegin );
	if( bIntNumber )
		(*bIntNumber) = 1;
 // return yes, and it's an int number
	return 1;
}
//---------------------------------------------------------------------------
//#define VERBOSE_DEBUG_VARTEXT
//---------------------------------------------------------------------------
#define COLLECT_LEN 4096
void VarTextInitEx( PVARTEXT pvt DBG_PASS )
{
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( COLLECT_LEN DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log( "Resetting collect_used (init)" );
#endif
	pvt->collect_used = 0;
	pvt->collect_avail = COLLECT_LEN;
	pvt->expand_by = 0;
}
 PVARTEXT  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( initial DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_used = 0;
	pvt->collect_avail = initial;
	pvt->expand_by = expand;
	return pvt;
}
//---------------------------------------------------------------------------
PVARTEXT VarTextCreateEx( DBG_VOIDPASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	VarTextInitEx( pvt DBG_RELAY );
	return pvt;
}
//---------------------------------------------------------------------------
void VarTextDestroyEx( PVARTEXT *ppvt DBG_PASS )
{
	if( ppvt && *ppvt )
	{
		VarTextEmptyEx( *ppvt DBG_RELAY );
		ReleaseEx( (*ppvt) DBG_RELAY );
		*ppvt = NULL;
	}
}
//---------------------------------------------------------------------------
void VarTextEmptyEx( PVARTEXT pvt DBG_PASS )
{
	if( pvt )
	{
		size_t expand = pvt->expand_by;
		LineReleaseEx( pvt->collect DBG_RELAY );
		LineReleaseEx( pvt->commit DBG_RELAY );
		MemSet( pvt, 0, sizeof( VARTEXT ) );
		pvt->expand_by = expand;
	}
}
//---------------------------------------------------------------------------
void VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( "Adding character %c", c );
#endif
	if( c == '\b' )
	{
		if( pvt->collect_used )
		{
			pvt->collect_used--;
			pvt->collect_text[pvt->collect_used] = 0;
		}
	}
	else
	{
		pvt->collect_text[pvt->collect_used++] = c;
		if( pvt->collect_used >= pvt->collect_avail )
		{
			//lprintf( "Expanding segment to make sure we have room to extend...(old %d)", pvt->collect->data.size );
			pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 DBG_RELAY );
			pvt->collect_avail = pvt->collect->data.size;
			pvt->collect_text = GetText( pvt->collect );
		}
	}
}
void VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS )
{
	int chars;
	int n;
	char output[6];
	chars = ConvertToUTF8Ex( output, c, overlong );
	for( n = 0; n < chars; n++ )
		VarTextAddCharacterEx( pvt, output[n] DBG_RELAY );
}
//---------------------------------------------------------------------------
void VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( "Adding character %c", c );
#endif
	{
		uint32_t n;
		for( n = 0; n < length; n++ )
		{
			if( !block[n] && ( length == VARTEXT_ADD_DATA_NULTERM ) )
				break;
			pvt->collect_text[pvt->collect_used++] = block[n];
			if( pvt->collect_used >= pvt->collect_avail )
			{
				//lprintf( "Expanding segment to make sure we have room to extend...(old %d)", pvt->collect->data.size );
				pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 + COLLECT_LEN DBG_RELAY );
				pvt->collect_avail = pvt->collect->data.size;
				pvt->collect_text = GetText( pvt->collect );
			}
		}
	}
}
//---------------------------------------------------------------------------
LOGICAL VarTextEndEx( PVARTEXT pvt DBG_PASS )
{
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		PTEXT segs= SegSplitEx( &pvt->collect, pvt->collect_used DBG_RELAY );
		//lprintf( "End collect at %d %d", pvt->collect_used, segs?segs->data.size:pvt->collect->data.size );
		if( !segs )
		{
			segs = pvt->collect;
		}
		//Log1( "Breaking collection adding... %s", GetText( segs ) );
		// so now the remaining buffer( if any )
		// is assigned to collect into.
		// This results in...
		pvt->collect = NEXTLINE( segs );
 // used all of the line...
		if( !pvt->collect )
		{
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( "Starting with new buffers " );
#endif
			VarTextInitEx( pvt DBG_RELAY );
		}
		else
		{
			 //Log1( "Remaining buffer is %d", GetTextSize( pvt->collect ) );
			SegBreak( pvt->collect );
			pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( "resetting collect_used after split" );
#endif
			pvt->collect_avail -= pvt->collect_used;
			pvt->collect_used = 0;
		}
		pvt->commit = SegAppend( pvt->commit, segs );
		return 1;
	}
	if( pvt && pvt->commit )
		return 1;
	return 0;
}
//---------------------------------------------------------------------------
PTEXT VarTextGetEx( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
	{
#ifdef VERBOSE_DEBUG_VARTEXT
		lprintf( DBG_FILELINEFMT "Get Text failed - no PVT." DBG_RELAY );
#endif
		return NULL;
	}
#ifdef VERBOSE_DEBUG_VARTEXT
	lprintf( DBG_FILELINEFMT "Grabbing the text from %p..." DBG_RELAY, pvt );
#endif
	if( VarTextEndEx( pvt DBG_RELAY ) )
	{
		PTEXT result = pvt->commit;
		pvt->commit = NULL;
		return result;
	}
	return NULL;
}
//---------------------------------------------------------------------------
 PTEXT  VarTextPeekEx ( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
		return NULL;
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		SetTextSize( pvt->collect, pvt->collect_used );
		//VarTextAddCharacterEx( pvt, 0 DBG_RELAY );
		return pvt->collect;
	}
	return NULL;
}
//---------------------------------------------------------------------------
void VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS)
{
	pvt->collect = SegExpandEx( pvt->collect, size DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_avail += size;
}
//---------------------------------------------------------------------------
INDEX VarTextLength( PVARTEXT pvt )
{
	//Log1( "Length is : %d", pvt->collect_used );
	if( pvt )
		return pvt->collect_used;
	return 0;
}
//---------------------------------------------------------------------------
INDEX vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args )
{
	INDEX len;
// this might be unicode...
#if ( defined( UNDER_CE ) || defined( _WIN32 ) ) && !defined( MINGW_SUX )
#  ifdef USE_UCRT
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
							, args
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
		va_end( tmp_args );
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#ifdef VERBOSE_DEBUG_VARTEXT
		Log3( "Print Length: %d into %d after %s", len, pvt->collect_used, pvt->collect_text );
#endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#  else
	int tries = 0;
	while( 1 )
	{
		size_t destlen;
		if( pvt->collect_text )
		{
			len = StringCbVPrintf ( pvt->collect_text + pvt->collect_used
									, ((destlen = pvt->collect_avail - pvt->collect_used) * sizeof( TEXTCHAR ))
									, format, args );
		}
		else
			len = STRSAFE_E_INSUFFICIENT_BUFFER;
		if( len == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			tries++;
			if( tries == 100 )
			{
				lprintf( "Single buffer expanded more then %d", tries * ( (pvt->expand_by)?pvt->expand_by:(16384+pvt->expand_by) ) );
 // didn't add any
				return 0;
			}
			VarTextExpand( pvt, (pvt->expand_by)?pvt->expand_by:(16384)  );
			continue;
		}
		len = StrLen( pvt->collect_text + pvt->collect_used );
		pvt->collect_used += len;
		break;
	}
	return len;
#  endif
#elif defined( __GNUC__ ) && !defined( _WIN32 )
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
#  ifdef __GNUC__
							, tmp_args
#  else
							, args
#  endif
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
#  ifdef __GNUC__
		va_end( tmp_args );
#  endif
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#  ifdef VERBOSE_DEBUG_VARTEXT
		Log3( "Print Length: %d into %d after %s", len, pvt->collect_used, pvt->collect_text );
#  endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#elif defined( __WATCOMC__ )
	{
		int destlen;
		va_list _args;
		_args[0] = args[0];
		do {
#  ifdef VERBOSE_DEBUG_VARTEXT
			Log2( "Print Length: ofs %d after %s"
				 , pvt->collect_used
				 , pvt->collect_text );
#  endif
			args[0] = _args[0];
			//va_start( args, format );
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, destlen = pvt->collect_avail - pvt->collect_used
								, format, args );
 // nothign to add... we'll get stuck looping if this is not checked.
			if( !len )
				return 0;
#  ifdef VERBOSE_DEBUG_VARTEXT
			lprintf( "result of vsnprintf: %d(%d) \'%s\' (%s)"
					 , len, destlen
					 , pvt->collect_text
					 , format );
#  endif
			if( len >= destlen )
			{
				// vsnwprintf() for NULL and 0 length returns -1
				// so, make length be something larger than -1, and keep expanding by that much.
				if( len == -1 )
					len = 256;
				VarTextExpand( pvt, len + pvt->expand_by );
			}
		} while( len >= destlen );
	}
#else
	// uhmm not sure what state this is then...
	{
		do {
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, pvt->collect_avail - pvt->collect_used
								, format, args );
			if( len < 0 )
				VarTextExpand( pvt, pvt->expand_by?pvt->expand_by:4096 );
			//					 VarTextExpandEx( pvt, 32 DBG_SRC );
		} while( len < 0 );
		//Log1( "Print Length: %d", len );
	}
#endif
#ifdef VERBOSE_DEBUG_VARTEXT
	Log2( "used: %d plus %d", pvt->collect_used , len );
#endif
	pvt->collect_used += len;
	return len;
}
//---------------------------------------------------------------------------
INDEX vtprintfEx( PVARTEXT pvt , CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vvtprintf( pvt, format, args );
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//
// PTEXT DumpText( PTEXT somestring )
//	 PTExT (single data segment with full description \r in text)
//
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static CTEXTSTR Ops[] = {
	"FORMAT_OP_CLEAR_END_OF_LINE",
	"FORMAT_OP_CLEAR_START_OF_LINE",
	"FORMAT_OP_CLEAR_LINE ",
	"FORMAT_OP_CLEAR_END_OF_PAGE",
	"FORMAT_OP_CLEAR_START_OF_PAGE",
	"FORMAT_OP_CLEAR_PAGE",
	"FORMAT_OP_CONCEAL"
 // background is how many to delete.
	  , "FORMAT_OP_DELETE_CHARS"
 // format.x, y are start/end of region -1,-1 clears.
	  , "FORMAT_OP_SET_SCROLL_REGION"
 // this works as a transaction...
	  , "FORMAT_OP_GET_CURSOR"
 // responce to getcursor...
	  , "FORMAT_OP_SET_CURSOR"
 // clear page, home page... result in page break...
	  , "FORMAT_OP_PAGE_BREAK"
 // break between paragraphs - kinda same as lines...
	  , "FORMAT_OP_PARAGRAPH_BREAK"
};
//---------------------------------------------------------------------------
static void BuildTextFlags( PVARTEXT vt, PTEXT pSeg )
{
	vtprintf( vt, "Text Flags: ");
	if( pSeg->flags & TF_STATIC )
		vtprintf( vt, "static " );
	if( pSeg->flags & TF_QUOTE )
		vtprintf( vt, "\"\" " );
	if( pSeg->flags & TF_SQUOTE )
		vtprintf( vt, "\'\' " );
	if( pSeg->flags & TF_BRACKET )
		vtprintf( vt, "[] " );
	if( pSeg->flags & TF_BRACE )
		vtprintf( vt, "{} " );
	if( pSeg->flags & TF_PAREN )
		vtprintf( vt, "() " );
	if( pSeg->flags & TF_TAG )
		vtprintf( vt, "<> " );
	if( pSeg->flags & TF_INDIRECT )
		vtprintf( vt, "Indirect " );
	/*
	if( pSeg->flags & TF_SINGLE )
	vtprintf( vt, "single " );
	*/
	if( pSeg->flags & TF_FORMATREL )
		vtprintf( vt, "format x,y(REL) " );
	if( pSeg->flags & TF_FORMATABS )
		vtprintf( vt, "format x,y " );
	else
		vtprintf( vt, "format spaces " );
	if( pSeg->flags & TF_COMPLETE )
		vtprintf( vt, "complete " );
	if( pSeg->flags & TF_BINARY )
		vtprintf( vt, "binary " );
	if( pSeg->flags & TF_DEEP )
		vtprintf( vt, "deep " );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_ENTITY )
		vtprintf( vt, "entity " );
	if( pSeg->flags & TF_SENTIENT )
		vtprintf( vt, "sentient " );
#endif
	if( pSeg->flags & TF_NORETURN )
		vtprintf( vt, "NoReturn " );
	if( pSeg->flags & TF_LOWER )
		vtprintf( vt, "Lower " );
	if( pSeg->flags & TF_UPPER )
		vtprintf( vt, "Upper " );
	if( pSeg->flags & TF_EQUAL )
		vtprintf( vt, "Equal " );
	if( pSeg->flags & TF_TEMP )
		vtprintf( vt, "Temp " );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_PROMPT )
		vtprintf( vt, "Prompt " );
	if( pSeg->flags & TF_PLUGIN )
		vtprintf( vt, "Plugin=%02x ", (uint8_t)(( pSeg->flags >> 26 ) & 0x3f ) );
#endif
	if( (pSeg->flags & TF_FORMATABS ) )
		vtprintf( vt, "Pos:%d,%d "
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else if( (pSeg->flags & TF_FORMATREL ) )
		vtprintf( vt, "Rel:%d,%d "
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else
		vtprintf( vt, "%d tabs %d spaces"
				  , pSeg->format.position.offset.tabs
				  , pSeg->format.position.offset.spaces
				  );
	if( pSeg->flags & TF_FORMATEX )
		vtprintf( vt, "format extended(%s) length:%d"
					  , Ops[ pSeg->format.flags.format_op
							 - FORMAT_OP_CLEAR_END_OF_LINE ]
					  , GetTextSize( pSeg ) );
	else
		vtprintf( vt, "Fore:%d Back:%d length:%d"
					, pSeg->format.flags.foreground
					, pSeg->format.flags.background
					, GetTextSize( pSeg ) );
}
PTEXT DumpText( PTEXT text )
{
	if( text )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT textsave = text;
		while( text )
		{
			BuildTextFlags( pvt, text );
			vtprintf( pvt, "\n->%s\n", GetText( text ) );
			text = NEXTLINE( text );
		}
		textsave = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		return textsave;
	}
	return NULL;
}
//---------------------------------------------------------------------------
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertAsciiEbdic( TEXTSTR text, INDEX length )
{
	static unsigned char a2e[256] = {
		0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 37, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
		64, 79,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
		240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
		124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
		215,216,217,226,227,228,229,230,231,232,233, 74,224, 90, 95,109,
		121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
		151,152,153,162,163,164,165,166,167,168,169,192,106,208,161,  7,
		32, 33, 34, 35, 36, 21,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
		48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,225,
		65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
		88, 89, 98, 99,100,101,102,103,104,105,112,113,114,115,116,117,
		118,119,120,128,138,139,140,141,142,143,144,154,155,156,157,158,
		159,160,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
		184,185,186,187,188,189,190,191,202,203,204,205,206,207,218,219,
		220,221,222,223,234,235,236,237,238,239,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = a2e[(unsigned)text[n]];
		}
	}
	return text;
}
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertEbcdicAscii( TEXTSTR text, INDEX length )
{
	static unsigned char e2a[256] = {
		0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
		16, 17, 18, 19,157,133,  8,135, 24, 25,146,143, 28, 29, 30, 31,
		128,129,130,131,132, 10, 23, 27,136,137,138,139,140,  5,  6,  7,
		144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
		32,160,161,162,163,164,165,166,167,168, 91, 46, 60, 40, 43, 33,
		38,169,170,171,172,173,174,175,176,177, 93, 36, 42, 41, 59, 94,
		45, 47,178,179,180,181,182,183,184,185,124, 44, 37, 95, 62, 63,
		186,187,188,189,190,191,192,193,194, 96, 58, 35, 64, 39, 61, 34,
		195, 97, 98, 99,100,101,102,103,104,105,196,197,198,199,200,201,
		202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
		209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
		216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
		123, 65, 66, 67, 68, 69, 70, 71, 72, 73,232,233,234,235,236,237,
		125, 74, 75, 76, 77, 78, 79, 80, 81, 82,238,239,240,241,242,243,
		92,159, 83, 84, 85, 86, 87, 88, 89, 90,244,245,246,247,248,249,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = e2a[(unsigned)text[n]];
		}
	}
	return text;
}
//---------------------------------------------------------------------------
#define NUM_RESERVED (sizeof(reserved_uri)/sizeof(reserved_uri[0]))
static TEXTCHAR reserved_uri[] = {'!','*','\'','(',')',';',':','@','&','=','+','$',',','/','?','#','[',']'
												  ,'<','>','~','.','"','{','}','|','\\','-','`','_','^','%',' '
												  , 0 };
static const TEXTCHAR *translated[] = { "%21","%2A","%27","%28","%29","%3B","%3A"
												,"%40","%26","%3D","%2B","%24","%2C","%2F"
												 ,"%3F","%23","%5B","%5D"
												 ,"%3C","%3E","%7E","%2E","%22","%7B","%7D","%7C","%5C","%2D","%60","%5F","%5E","%25","%20"
};
static int MeasureTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
			out_length++;
		else if( StrChr( reserved_uri, text[i] ) )
			out_length += 3;
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	int target_len = MeasureTextURI( text, length, skip_slash );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	const TEXTCHAR *char_pos;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
		{
			out_pos[0] = text[i];
			out_pos++;
		}
		else if( ( char_pos = StrChr( reserved_uri, text[i] ) ) )
		{
#ifdef __cplusplus
			sack::memory::
#endif
			StrCpyEx( out_pos, translated[char_pos - reserved_uri], target_len - ( out_pos - target ) );
			out_pos += 3;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	return target;
}
static int MeasureURIText( CTEXTSTR text, INDEX length )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			i += 2;
			out_length++;
		}
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertURIText( CTEXTSTR text, INDEX length )
{
	int target_len = MeasureURIText( text, length );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			char char_byte;
			// A 41
			// a 61
			// 0 30
			char_byte = (((text[i+1] & 10)?(text[i+1]-0x30)
							  : (text[i+1] & 20)?(text[i+1]-'a'+10)
							  : (text[i+1]-'A'+10)) << 4 )
				| (((text[i+2] & 10)?(text[i+2]-0x30)
					 : (text[i+2] & 20)?(text[i+2]-'a'+10)
					 : (text[i+2]-'A'+10)) );
			out_pos[0] = char_byte;
			out_pos++;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	//out_pos++;
	return target;
}
//---------------------------------------------------------------------------
int ConvertToUTF16( wchar_t *output, TEXTRUNE rune )
{
	if( !( rune & 0xFFFF0000 ) )
	{
		if( rune < 0xD800 || rune >= 0xE000 )
		{
			output[0] = (wchar_t)rune;
			return 1;
		}
		else
 // invalid rune specified.
			return 0;
	}
	else
	{
		rune -= 0x10000;
		if( !( rune & 0xFFFFF ) )
		{
			output[0] = 0xD800 + (wchar_t)( ( rune & 0xFFC00 ) >> 10 );
			output[1] = 0xDC00 + (wchar_t)( ( rune & 0x003FF ) );
			return 2;
		}
	}
 // invalid rune.
	return 0;
}
int ConvertToUTF8( char *output, TEXTRUNE rune )
{
	int ch = 1;
	if( !( rune & 0xFFFFFF80 ) )
	{
		// 7 bits
		(*output++) = (char)rune;
		goto plus0;
	}
	else if( !( rune & 0xFFFFF800 ) )
	{
		// 11 bits
		(*output++) = 0xC0 | ( ( ( rune & 0x07C0 ) >> 6 ) & 0xFF );
		goto plus1;
	}
	else if( !( rune & 0xFFFF0000 ) )
	{
		// 16 bits
		(*output++) = 0xE0 | ( ( ( rune & 0xF000 ) >> 12 ) & 0xFF );
		goto plus2;
	}
	else if( !( rune & 0xFFE00000 ) )
	{
		// 21 bits
		(*output++) = 0xF0 | ( ( ( rune & 0x1C0000 ) >> 15 ) & 0xFF );
		goto plus3;
	}
	else if( !( rune & 0xFC000000 ) )
	{
		// 26 bits
		(*output++) = 0xF8 | ( ( ( rune & 0x3000000 ) >> 24 ) & 0xFF );
		goto plus4;
	}
	else if( !( rune & 0x80000000 ) )
	{
		// 31 bits
		(*output++) = 0xFC | ( ( ( rune & 0x40000000 ) >> 30 ) & 0xFF );
		//goto plus5;
	}
	// invalid rune (out of range)
//plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
plus0:
	return ch;
}
int ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong )
{
	int ch = 1;
	if( !overlong ) return ConvertToUTF8( output, rune );
	if( !(rune & 0xFFFFFF80) )
	{
		// 11 bits
		(*output++) = 0xC0 | (((rune & 0x07C0) >> 6) & 0xFF);
		goto plus1;
	}
	else if( !(rune & 0xFFFFF800) )
	{
		// 16 bits
		(*output++) = 0xE0 | (((rune & 0xF000) >> 12) & 0xFF);
		goto plus2;
	}
	else if( !(rune & 0xFFFF0000) )
	{
		// 21 bits
		(*output++) = 0xF0 | (((rune & 0x1C0000) >> 15) & 0xFF);
		goto plus3;
	}
	else if( !(rune & 0xFFE00000) )
	{
		// 26 bits
		(*output++) = 0xF8 | (((rune & 0x3000000) >> 24) & 0xFF);
		goto plus4;
	}
	else if( !(rune & 0xFC000000) )
	{
		// 31 bits
		(*output++) = 0xFC | (((rune & 0x40000000) >> 30) & 0xFF);
		goto plus5;
	}
	else if( !(rune & 0x80000000) ) {
		(*output++) = 0xFEU;
	}
	ch++; (*output++) = 0x80 | (((rune & 0xC0000000) >> 30) & 0xFF);
plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
//plus0:
	return ch;
}
char * WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS )
{
	// Conversion to char* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInBytes;
	char  tmp[2];
	char	 *ch;
	char	 *_ch;
	const wchar_t *_wch = wch;
 // start with 1 for the ending nul
	sizeInBytes = 1;
	_ch = ch = tmp;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "wch = %04x", wch[0] );
			if( !( wch[0] & 0xFF80 ) )
			{
				//lprintf( "1 byte encode..." );
				sizeInBytes++;
			}
			else if( !( wch[0] & 0xF800 ) )
			{
				//lprintf( "2 byte encode..." );
				sizeInBytes += 2;
			}
			else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
					   && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
					 && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
					   && ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
			{
				int longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
				//lprintf( "3 or 4 byte encode..." );
				if( !(longer_value & 0xFFFF0000 ) )
					sizeInBytes += 3;
 // hack a way to encode D800-DFFF
				else if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					sizeInBytes += 2;
				else
					sizeInBytes += 4;
				wch++;
			}
			else
			{
				// just encode the 16 bits as it is.
				//lprintf( " 3 byte encode?" );
				sizeInBytes+= 3;
			}
			wch++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( char, sizeInBytes);
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			{
				if( !( wch[0] & 0xFF80 ) )
				{
					(*ch++) = ((unsigned char*)wch)[0];
				}
				else if( !( wch[0] & 0xFF00 ) )
				{
					//(*ch++) = ((unsigned char*)wch)[0];
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( !( wch[0] & 0xF800 ) )
				{
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
							 && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
						  && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
								&& ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
				{
					uint32_t longer_value;
					longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
 // hack a way to encode D800-DFFF
					if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					{
						longer_value = ( longer_value - 0xF0000 ) + 0xD800;
						sizeInBytes += 2;
					}
					wch++;
					if( !(longer_value & 0xFFFF ) )
					{
						// 16 bit encoding (shouldn't be hit
						(*ch++) = 0xE0 | (char)( ( longer_value >> 12 ) & 0x0F );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					else if( !( longer_value & 0xFFE00000 ) )
					{
						// 21 bit encoding ...
						(*ch++) = 0xF0 | (char)( ( longer_value >> 18 ) & 0x07 );
						(*ch++) = 0x80 | (char)( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					/*  ** functionally removed from spec ..... surrogates cannot be this long.
					else if( !( longer_value & 0xFC000000 ) )
					{
						(*ch++) = 0xF8 | ( longer_value >> 24 );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					else  if( !( longer_value & 0x80000000 ) )
					{
						// 31 bit encode
						(*ch++) = 0xFC | ( longer_value >> 30 );
						(*ch++) = 0x80 | ( ( longer_value >> 24 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					*/
					else
					{
						// too long to encode.
					}
				}
				else
				{
					   //lprintf( " 3 byte encode?  16 bits" );
 // mask just in case of stupid compiles that tread wchar as signed?
						(*ch++) = 0xE0 | ( ( wch[0] >> 12 ) & 0x0F );
						(*ch++) = 0x80 | ( ( wch[0] >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( wch[0] >> 0 ) & 0x3f );
				}
			}
			wch++;
		}
	}
	(*ch) = 0;
	ch = _ch;
	return ch;
}
char * WcharConvertEx ( const wchar_t *wch DBG_PASS )
{
	size_t len;
	for( len = 0; wch[len]; len++ );
	return WcharConvertExx( wch, len DBG_RELAY );
}
wchar_t * CharWConvertExx ( const char *wch, size_t len DBG_PASS )
{
	// Conversion to wchar_t* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInChars = 0;
	const char *_wch = wch;
	wchar_t	*ch;
	wchar_t   *_ch;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( (wch[0] & 0xE0) == 0xC0 )
				wch += 2;
			else if( (wch[0] & 0xF0) == 0xE0 )
				wch += 3;
			else if( (wch[0] & 0xF0) == 0xF0 )
			{
				sizeInChars++;
				wch += 4;
			}
			else
				wch++;
			sizeInChars++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( wchar_t, sizeInChars + 1 );
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( ( wch[0] & 0xE0 ) == 0xC0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0x1F ) << 6 ) | ( (wchar_t)wch[1] & 0x3f );
				wch += 2;
			}
			else if( ( wch[0] & 0xF0 ) == 0xE0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0xF ) << 12 )
					| ( ( (wchar_t)wch[1] & 0x3F ) << 6 )
					| ( (wchar_t)wch[2] & 0x3f );
				wch += 3;
			}
			else if( ( wch[0] & 0xF0 ) == 0xF0 )
			{
				uint32_t literal_char =  ( ( (wchar_t)wch[0] & 0x7 ) << 18 )
				                 | ( ( (wchar_t)wch[1] & 0x3F ) << 12 )
				                 | ( (wchar_t)wch[2] & 0x3f ) << 6
				                 | ( (wchar_t)wch[3] & 0x3f );
				//lprintf( "literal char is %d (%08x", literal_char, literal_char );
// ((wchar_t*)&literal_char)[0];
				ch[0] = 0xD800 + ( ( ( literal_char - 0x10000 ) & 0xFFC00 ) >> 10 );
// ((wchar_t*)&literal_char)[1];
				ch[1] = 0xDC00 + ( ( literal_char - 0x10000 ) & 0x3ff );
				ch++;
				wch += 4;
			}
			else
			{
				ch[0] = wch[0] & 0x7f;
				wch++;
			}
			ch++;
		}
		ch[0] = 0;
	}
	return _ch;
}
wchar_t * CharWConvertEx ( const char *ch DBG_PASS )
{
	int len;
	for( len = 0; ch[len]; len++ );
	return CharWConvertExx( ch, len DBG_RELAY );
}
LOGICAL ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseStringVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (POINTER)(*pData) );
		}
		(*pData) = NewArray( CTEXTSTR, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			size_t len;
			start = end;
			end = StrChr( start, ',' );
			if( end )
			{
				end++;
				(*pData)[count] = NewArray( TEXTCHAR, len = end - start );
			}
			else
			{
				(*pData)[count] = NewArray( TEXTCHAR, len = StrLen( start ) + 1 );
			}
			StrCpyEx( (TEXTSTR)(*pData)[count], start, len );
			count++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfChar( const char * *from )
{
	TEXTRUNE result = (unsigned char)(*from)[0];
	//if( !result ) return result;
	if( (*from)[0] & 0x80 )
	{
		if( ( (*from)[0] & 0xE0 ) == 0xC0 )
		{
			if( ( (*from)[1] & 0xC0 ) == 0x80 )
			{
				result = ( ( (unsigned int)(*from)[0] & 0x1F ) << 6 ) | ( (unsigned int)(*from)[1] & 0x3f );
				(*from) += 2;
			}
			else
			{
				result = 0;
				//lprintf( "a 2 byte code with improper continuation encodings following it was found. %02x %02x"
				//		, (*from)[0]
				//		, (*from)[1]
				//		);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF0 ) == 0xE0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 ) )
			{
				result = ( ( (unsigned int)(*from)[0] & 0xF ) << 12 ) | ( ( (unsigned int)(*from)[1] & 0x3F ) << 6 ) | ( (unsigned int)(*from)[2] & 0x3f );
				(*from) += 3;
			}
			else
			{
				result = 0;
				//lprintf( "a 3 byte code with improper continuation encodings following it was found. %02x %02x %02x"
				//	, (*from)[0]
				//	, (*from)[1]
				//	, (*from)[2]
				//	);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF8 ) == 0xF0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 ) && ( ( (*from)[2] & 0xC0 ) == 0x80 ) && ( ( (*from)[3] & 0xC0 ) == 0x80 ) )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x7 ) << 18 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[2] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[3] & 0x3f );
				(*from) += 4;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFC ) == 0xF8 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x3 ) << 24 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[3] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[4] & 0x3f );
				(*from) += 5;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFE ) == 0xFC )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[5] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x1 ) << 30 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 24 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[3] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[4] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[5] & 0x3f );
				(*from) += 6;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xC0 ) == 0x80 )
		{
			// things like 0x9F, 0x9A is OK; is a single byte character, is a unicode application escape
			//lprintf( "a continuation encoding was found." );
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
		else
		{
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
	}
	else
	{
		result = (unsigned char)(*from)[0];
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexed( const char * pc, size_t *n, size_t length )
{
	if( length )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetUtfChar( &tmp );
		if( (size_t)( tmp - orig ) <= length ) {
			n[0] += tmp - orig;
			return result;
		}
		// if illformed character was at the end... return 0
	   // cap result to length.
		( *n ) = length;
	}
	return 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfChar( const char *start, const char * *from )
{
	TEXTRUNE result;
	if( (*from) == start ) return 0;
	result = (unsigned char)(*from)[-1];
	if( !result ) return result;
	if( (*from)[-1] & 0x80 )
	{
		CTEXTSTR end;
		while( (*from > start) && ( (*from)[-1] & 0xC0 ) == 0x80 )
			(*from)--;
		if( (*from > start) ) {
			(*from)--;
			end = (*from);
			result = GetUtfChar( from );
			(*from) = end;
		}
		else
			result = 0;
	}
	else
	{
		result = (unsigned char)(*from)[-1];
		(*from)--;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexed( const char *pc, size_t *n )
{
	if( *n )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetPriorUtfChar( pc, &tmp );
		if( tmp <= orig ) {
			n[0] -= orig - tmp;
			return result;
		}
	}
	return INVALID_RUNE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfCharW( const wchar_t * *from )
{
	TEXTRUNE result = (unsigned)(*from)[0];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexedW( const wchar_t* pc, size_t *n )
{
	const wchar_t * orig = pc + n[0];
	const wchar_t * tmp = orig;
	TEXTRUNE result = GetUtfCharW( &tmp );
	n[0] += tmp - orig;
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharW( const wchar_t*start, const wchar_t* *from )
{
	TEXTRUNE result = (unsigned)(*from)[-1];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexedW( const wchar_t *pc, size_t *n )
{
	if( *n )
	{
		const wchar_t * orig = pc + n[0];
		const wchar_t * tmp = orig;
		TEXTRUNE result = GetPriorUtfCharW( pc, &tmp );
		n[0] += tmp - orig;
		return result;
	}
	return 0;
}
//---------------------------------------------------------------------------
// Return the integer character from the string
// using utf-8 or utf-16 decoding appropriately.  No more extended-ascii.
static int Step( CTEXTSTR *pc, size_t *nLen )
{
	CTEXTSTR _pc = (*pc);
	int ch;
	//lprintf( "Step (%s[%*.*s])", (*pc), nLen,nLen, (*pc) );
	if( nLen && !*nLen )
		return 0;
	ch = GetUtfChar( pc );
	//if( ch & 0xFFE00000 )
	//	DebugBreak();
	if( nLen )
		(*nLen) -= (*pc) - _pc;
	_pc = (*pc);
	if( ch )
	{
		while( ch == '\x9F' )
		{
			while( ch && ( ch != '\x9C' ) )
			{
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
			// if the string ended...
			if( !ch )
			{
				// this is done.  There's nothing left... command with no data is bad form, but not illegal.
				return FALSE;
			}
  // pc is now on the stop command, advance one....
			else
			{
				// this is in a loop, and the next character may be another command....
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
		}
	}
	return ch;
}
size_t GetDisplayableCharacterBytes( CTEXTSTR string, size_t character_count )
{
	CTEXTSTR original = string;
	int ch;
	if( !string ) return 0;
	while( character_count &&
		( ch = Step( &string, NULL ) ) )
	{
		character_count--;
	}
	return string - original;
}
size_t GetDisplayableCharacterCount( CTEXTSTR string, size_t max_bytes )
{
	int ch;
	size_t count = 0;
	if( !string ) return 0;
	while( ( ch = Step( &string, &max_bytes ) ) )
	{
		count++;
	}
	return count;
}
CTEXTSTR GetDisplayableCharactersAtCount( CTEXTSTR string, size_t nLen )
{
	int ch;
	if( !string ) return 0;
	while( nLen > 0 &&
		 ( ch = Step( &string, NULL ) ) )
	{
		nLen--;
	}
	return string;
}
LOGICAL ParseIntVector( CTEXTSTR data, int **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseIntVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (*pData) );
		}
		(*pData) = NewArray( int, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			start = end;
			(void)sscanf( start, "%d", (*pData) + count );
			count++;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
const char encodings[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_";
const char encodings2[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static TEXTCHAR b64xor_table[256][256];
static TEXTCHAR u8xor_table[256][256];
static TEXTCHAR b64xor_table2[256][256];
static TEXTCHAR u8xor_table2[256][256];
PRELOAD( initTables ) {
	int n, m;
	for( n = 0; n < (sizeof( encodings )-1); n++ )
		for( m = 0; m < (sizeof( encodings )-1); m++ ) {
			b64xor_table[(uint8_t)encodings[n]][(uint8_t)encodings[m]] = encodings[n^m];
			u8xor_table[n][(uint8_t)encodings[m]] = n^m;
			b64xor_table2[(uint8_t)encodings2[n]][(uint8_t)encodings2[m]] = encodings2[n^m];
			u8xor_table2[n][(uint8_t)encodings2[m]] = n^m;
	}
	//LogBinary( (uint8_t*)u8xor_table[0], sizeof( u8xor_table ) );
	b64xor_table['=']['='] = '=';
}
char * b64xor( const char *a, const char *b ) {
	int n;
	char *out = NewArray( char, strlen(a) + 1);
	for( n = 0; a[n]; n++ ) {
		out[n] = b64xor_table[(uint8_t)a[n]][(uint8_t)b[n]];
	}
	out[n] = 0;
	return out;
}
char * u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs ) {
	size_t n;
	size_t keylen = blen-5;
	int o = ofs[0];
	size_t outlen;
	char *out = NewArray( char, (outlen=alen) + 1);
	char *_out = out;
	int l = 0;
	int _mask = 0x3f;
	for( n = 0; n < alen; n++ ) {
		char v = (*a++);
		int mask;
		mask = _mask;
		if( (v & 0x80) == 0x00 ) { if( l ) lprintf( "short utf8 sequence found" ); mask = 0x3f; _mask = 0x3f; }
		else if( (v & 0xC0) == 0x80 ) { if( !l ) lprintf( "invalid utf8 sequence" ); l--; _mask = 0x3f; }
		else if( (v & 0xE0) == 0xC0 ) { if( l )
  // 6 + 1 == 7 //-V640
			lprintf( "short utf8 sequence found" ); l = 1; mask = 0x1; _mask = 0x3f; }
		else if( (v & 0xF0) == 0xE0 ) { if( l )
  // 6 + 5 + 0 == 11 //-V640
			lprintf( "short utf8 sequence found" ); l = 2; mask = 0;  _mask = 0x1f; }
		else if( (v & 0xF8) == 0xF0 ) { if( l )
  // 6(2) + 4 + 0 == 16 //-V640
			lprintf( "short utf8 sequence found" ); l = 3; mask = 0;  _mask = 0x0f; }
		else if( (v & 0xFC) == 0xF8 ) { if( l )
  // 6(3) + 3 + 0 == 21 //-V640
			lprintf( "short utf8 sequence found" ); l = 4; mask = 0;  _mask = 0x07; }
		else if( (v & 0xFE) == 0xFC ) { if( l )
  // 6(4) + 2 + 0 == 26 //-V640
			lprintf( "short utf8 sequence found" ); l = 5; mask = 0;  _mask = 0x03; }
		char bchar = b[(n+o)%(keylen)];
		(*out) = (v & ~mask ) | ( u8xor_table[v & mask ][bchar] & mask );
		out++;
	}
	(*out) = 0;
	ofs[0] = (int)((ofs[0]+outlen)%keylen);
	return _out;
}
static const char * const _base642 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_=";
static const char * const _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static const char * _last_base64_set;
static char _base64_r[256];
static void encodeblock( unsigned char in[3], TEXTCHAR out[4], size_t len, const char *base64 )
{
	out[0] = base64[ in[0] >> 2 ];
	out[1] = base64[ ((in[0] & 0x03) << 4) | ( ( len > 0 ) ? ((in[1] & 0xf0) >> 4) : 0 ) ];
	out[2] = (len > 1 ? base64[ ((in[1] & 0x0f) << 2) | ( ( len > 2 ) ? ((in[2] & 0xc0) >> 6) : 0 ) ] : base64[64]);
	out[3] = (len > 2 ? base64[ in[2] & 0x3f ] : base64[64]);
}
static void decodeblock( const char in[4], uint8_t out[3], size_t len, const char *base64 )
{
	int index[4];
	size_t n;
	for( n = 0; n < len; n++ )
	{
		// propagate terminator.
		if( n && ( index[n - 1] == 64 ) ) index[n] = 0;
		else index[n] = _base64_r[in[n]];
	}
	for( ; n < 4; n++ )
		index[n] = 0;
	out[0] = (char)(( index[0] ) << 2 | ( index[1] ) >> 4);
	out[1] = (char)(( index[1] ) << 4 | ( ( ( index[2] ) >> 2 ) & 0x0f ));
	out[2] = (char)(( index[2] ) << 6 | ( ( index[3] ) & 0x3F ));
	//out[] = (len > 2 ? base64[ in[2] & 0x3f ] : 0);
}
TEXTCHAR *EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *base64 )
{
	size_t fake_outsize;
	TEXTCHAR * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	real_output = NewArray( TEXTCHAR, 1 + ( ( length * 4 + 2) / 3 ) + 1 + 1 + 1 );
	{
		size_t n;
		for( n = 0; n < (length+2)/3; n++ )
		{
			size_t blocklen;
			blocklen = length - n*3;
			if( blocklen > 3 )
				blocklen = 3;
			encodeblock( ((uint8_t*)buf) + n * 3, real_output + n*4, blocklen, base64 );
		}
 // don't include the NUL.
		(*outsize) = n*4;
		real_output[n*4] = 0;
	}
	return real_output;
}
static void setupDecodeBytes( const char *code ) {
	int n = 0;
	// default all of these, allow code to override them.
	// allow nul terminators (sortof)
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r[0] = 64;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['~'] = 64;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['='] = 64;
	// My JS Encoding $_ and = at the end.  allows most to be identifiers too.
	// 'standard' encoding +/
	// variants -/
	//          +,
	//          ._
	// variants -_
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['$'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['+'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['-'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['.'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['_'] = 63;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r['/'] = 63;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
	_base64_r[','] = 63;
	if( _last_base64_set != code ) {
		_last_base64_set = code;
		memset( _base64_r, 0, 256 );
		while( *code ) {
			_base64_r[*code] = n++;
			code++;
		}
	}
}
uint8_t *DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *base64 )
{
	static const char *useBase64;
	size_t fake_outsize;
	uint8_t * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	if( useBase64 != base64 ) {
		useBase64 = base64;
		setupDecodeBytes( base64 );
	}
	real_output = NewArray( uint8_t, ( ( ( length + 1 ) * 3 ) / 4 ) + 1 );
	{
		size_t n;
		for( n = 0; n < (length+3)/4; n++ )
		{
			size_t blocklen;
			blocklen = length - n*4;
			if( blocklen > 4 )
				blocklen = 4;
			decodeblock( buf + n * 4, real_output + n*3, blocklen, base64 );
		}
		if( length % 4 == 1 )
			(*outsize) = (((length + 3) / 4) * 3) - 3;
		else if( length % 4 == 2 )
			(*outsize) = (((length + 3) / 4) * 3) - 2;
		else if( length % 4 == 3 )
			(*outsize) = (((length + 3) / 4) * 3) - 1;
		else if( buf[length - 1] == '=' ) {
			if( buf[length - 2] == '=' ) {
				(*outsize) = (((length + 3) / 4) * 3) - 2;
			}
			else
				(*outsize) = (((length + 3) / 4) * 3) - 1;
		}
		else
			(*outsize) = (((length + 3) / 4) * 3);
		real_output[(*outsize)] = 0;
	}
	return real_output;
}
#ifdef __cplusplus
 //namespace text {
}
 //namespace containers {
}
 // namespace sack {
}
#endif
/*
 *
 *   Crafted by Jim Buckeyne
 *    Purpose: Provide slab allocated set objects
 *      things like points, lines, etc, are cheaper to store
 *      in sets of 128, 256, instead of one at a time, since the
 *      allocation tracking block is larger than the object itself.
 *      Secondarily, this can result in compact, indexable, arrays
 *      for saving data - these resemble a PDATALIST
 *
 *  (c)1999-2006++ Freedom Collective
 */
//#undef GetFromSet
//#undef GetArrayFromSet
//#undef DeleteFromSet
//#undef DeleteArrayFromSet
//#undef CountUsedInSet
//#undef GetLinearSetArray
//#undef ForAllInSet
//----------------------------------------------------------------------------
 // put into a global structure, and configure.
static int bLog;
#ifdef __cplusplus
namespace sack {
	namespace containers {
	namespace sets {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
#ifndef __NO_OPTIONS__
PRELOAD( InitSetLogging )
{
	bLog = SACK_GetProfileIntEx( "SACK", "type library/sets/Enable Logging", 0, TRUE );
}
#endif
void DeleteSet( GENERICSET **ppSet )
{
	GENERICSET *pSet;
	 if( !ppSet )
		 return;
	 pSet = *ppSet;
	if( bLog ) lprintf( "Deleted set %p", pSet );
	while( pSet )
	{
		GENERICSET *next;
		next = pSet->next;
		Release( pSet );
		pSet = next;
	}
	*ppSet = NULL;
}
//----------------------------------------------------------------------------
PGENERICSET GetFromSetPoolEx( GENERICSET **pSetSet, int setsetsizea, int setunitsize, int setmaxcnt
							 , GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS ){
	PGENERICSET set;
	uint32_t maxbias = 0;
	void *unit = NULL;
	uintptr_t ofs = ( ( ( maxcnt + 31 ) / 32 ) * 4 );
	//if( pSet && (*pSet) && ( (*pSet)->nBias > 1000 ))
	//	_lprintf( DBG_RELAY )("GetFromSet: %p", pSet );
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		if( pSetSet )
		{
			set = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
			set->nBias = 0;
		}
		else
		{
			set = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
			set->nBias = 0;
			//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
			MemSet( set, 0, setsizea );
		}
		*pSet = set;
	}
	{
		int n;
		set = *pSet;
ExtendSet:
		while( (size_t)set->nUsed == (size_t)maxcnt )
		{
			if( !set->next )
			{
				PGENERICSET newset;
				if( pSetSet )
				{
					newset = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
				else
				{
					newset = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
					//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
					MemSet( newset, 0, setsizea );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
#if 1
				if( ( newset->next = (*pSet) ) )
				{
					newset->next->me = &newset->next;
				}
				// insert newset at nead of list - then next time through
				// free ones are the first checked...
				(*(newset->me = pSet)) = newset;
#else
				set->next = newset;
				newset->me = &set->next;
#endif
				set = newset;
				// new, empty set, it's going to fail nUsed == maxcnt
				break;
			}
			else
			{
				if( set->nBias > maxbias )
					maxbias = set->nBias;
			}
			set = set->next;
		}
		while( !unit && set )
		{
			uintptr_t base = ( (uintptr_t)set->bUsed ) + ofs;
			// quick skip for 32 bit blocks of used members...
			n = 0;
			for( n = 0; n < maxcnt && ((maxcnt-n) >= 32) && AllUsed( set,n ); n+=32 );
			if( n == maxcnt )
			{
				// occastionally the 'nUsed' counter may not be in sync with actual usage.
				// this set, after inspecing the bitmasks is actually full.   Update
				// the usage counter and go back up to where the set gets extended.
				set->nUsed = n;
				goto ExtendSet;
			}
			for( n = n; n < maxcnt; n++ )
			{
				if( !IsUsed( set, n ) )
				{
 // go to the appropriate offset
					unit = (void*)( base + n * unitsize );
					SetUsed( set, n );
					return (PGENERICSET)unit;
				}
			}
			if( n == maxcnt )
			{
				if( !set->next ) {
					// synchronize this; obviusly every member IS used.
					set->nUsed = n;
 // for some reason didn't find anything; maybe it's a small set of less than 32 elements?
					goto ExtendSet;
				}
				set = set->next;
			}
		}
#ifdef Z_DEBUG
		if( bLog ) _lprintf( DBG_RELAY )( "Unit result: %p from %p %d %d %d %d", unit, set, unitsize, maxcnt, n, ( ( (maxcnt +31) / 32 ) * 4 )  );
#endif
	}
	return (PGENERICSET)unit;
}
//----------------------------------------------------------------------------
void *GetFromSetEx( GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS )
{
	return GetFromSetPoolEx( NULL, 0, 0, 0
								  , pSet, setsizea, unitsize, maxcnt DBG_RELAY );
}
static POINTER GetSetMemberExx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt, int *bUsed DBG_PASS )
{
	PGENERICSET set;
	uint32_t maxbias = 0;
	if( nMember == INVALID_INDEX )
		return NULL;
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		set = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
		//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
		MemSet( set, 0, setsize );
		set->nBias = 0;
		*pSet = set;
	}
	else
		set = (*pSet );
	while( 1 )
	{
		if( nMember >= set->nBias &&
			nMember < ( set->nBias + maxcnt ) )
		{
			nMember -= set->nBias;
			break;
		}
		if( !set->next )
		{
			PGENERICSET newset = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
			//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
			MemSet( newset, 0, setsize );
			if( set->nBias > maxbias )
				maxbias = set->nBias;
			newset->nBias = maxbias + maxcnt;
			set->next = newset;
			newset->me = &set->next;
		}
		else
		{
			if( set->nBias > maxbias )
				maxbias = set->nBias;
		}
		//nMember -= maxcnt;
		set = set->next;
	}
	if( !IsUsed( set, nMember ) )
		(*bUsed) = 0;
	else
		(*bUsed) = 1;
	if( bLog ) _lprintf(DBG_RELAY)( "Resulting unit %" _PTRSZVALfs,  ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
						+ nMember * unitsize );
	return (void*)( ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
 // go to the appropriate offset
						+ nMember * unitsize );
}
//----------------------------------------------------------------------------
POINTER GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		return NULL;
	return result;
}
//----------------------------------------------------------------------------
POINTER GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	if( nMember == INVALID_INDEX )
		return NULL;
	//if( nMember > 1000 )
	//	DebugBreak();
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		SetUsed( *pSet, nMember );
	return result;
}
//----------------------------------------------------------------------------
#undef GetMemberIndex
INDEX GetMemberIndex(GENERICSET **ppSet, POINTER unit, int unitsize, int max )
{
	GENERICSET *pSet = ppSet?*ppSet:NULL;
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	int base = 0;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %" _PTRSZVALfs " of %d", n % unitsize, unitsize );
				DebugBreak();
				return INVALID_INDEX;
			}
			n /= unitsize;
			return (INDEX)(n + pSet->nBias);
		}
		base += max;
		pSet = pSet->next;
	}
	return INVALID_INDEX;
}
//----------------------------------------------------------------------------
#undef MemberValidInSet
int MemberValidInSet( GENERICSET *pSet, void *unit, int unitsize, int max )
{
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %" _PTRSZVALfs " of %d", n % unitsize, unitsize );
				DebugBreak();
				return FALSE;
			}
			n /= unitsize;
			return IsUsed( pSet, n );
		}
		pSet = pSet->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void DeleteFromSetExx( GENERICSET *pSet, void *unit, int unitsize, int max DBG_PASS )
{
	uintptr_t nUnit = (uintptr_t)unit;
	uintptr_t ofs = ( ( max + 31 ) / 32) * 4;
	uintptr_t base;
	//if( bLog )
	//if( pSet && ((pSet)->nBias > 1000) )
	//	_lprintf(DBG_RELAY)( "Deleting from  %p of %p ", pSet, unit );
	while( pSet )
	{
		base = ( (uintptr_t)( pSet->bUsed ) + ofs );
		if( (nUnit >= base) &&
		    (nUnit < ( base + unitsize*max )) )
		{
			uintptr_t n = nUnit - base;
#ifdef Z_DEBUG
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %p %p %p  %d %"_PTRSZVALfs " %"_PTRSZVALfs " of %d"
						 , unit
						 , pSet
						 , &pSet->bUsed
						, ofs
						 , n, n % unitsize, unitsize );
				DebugBreak();
				return;
			}
#endif
			n /= unitsize;
			ClearUsed( pSet, n );
			break;
		}
		pSet = pSet->next;
	}
#ifdef Z_DEBUG
	if( !pSet )
		Log( "Failed to find node in set!" );
#endif
}
//----------------------------------------------------------------------------
void DeleteSetMemberEx( GENERICSET *pSet, INDEX iMember, uintptr_t unitsize, INDEX max )
{
	//Log2( "Deleting from  %08x of %08x ", pSet, iMember );
	while( pSet )
	{
		if( iMember >= max )
		{
			iMember -= max;
			pSet = pSet->next;
			continue;
		}
		break;
	}
	if( pSet )
	{
		if( !IsUsed( pSet, iMember ) )
		{
			DebugBreak();
			lprintf( "Deleting set member which is already released? not decrementing used counter" );
		}
		else
		{
			ClearUsed( pSet, iMember );
			//pSet->nUsed--; // one not used - quick reference counter
		}
	}
	else
		Log( "Failed to find node in set!" );
}
#undef DeleteSetMember
void DeleteSetMember( GENERICSET *pSet, INDEX iMember, int unitsize, int max )
{
	DeleteSetMemberEx( pSet, iMember, unitsize, max );
}
//----------------------------------------------------------------------------
int CountUsedInSetEx( GENERICSET *pSet, int max )
{
	int cnt = 0, n;
	while( pSet )
	{
		for( n = 0; n < max; n++ )
			if( IsUsed( pSet, n ) )
				cnt++;
		pSet = pSet->next;
	}
	return cnt;
}
//----------------------------------------------------------------------------
void **GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max )
{
	void  **array;
	int items, cnt, n, ofs;
	INDEX nMin, nNewMin;
	GENERICSET *pCur;
 // useless initialization.  nNewMin will be set if this is valid; and there was no error generated for using THAT uninitialized.
	GENERICSET *pNewMin = NULL;
	//Log2( "Building Array unit size: %d(%08x)", unitsize, unitsize );
	items = CountUsedInSetEx( pSet, max );
	if( pCount )
		*pCount = items;
	ofs = ( ( max + 31) / 32 ) * 4;
	array = (void**)Allocate( sizeof( void* ) * items );
 // 0
	nMin = 0;
	do
	{
		pCur = pSet;
 // 0xFFFFFFFF (max)
		nNewMin = INVALID_INDEX;
		while( pCur )
		{
			// maybe instead of ordering elements
			// by ID - order by physical memory?
			// that allows findinarray to work better...
			if( (uintptr_t)pCur->nBias < nNewMin &&
				 (uintptr_t)pCur->nBias >= nMin )
			{
				pNewMin = pCur;
				nNewMin = pCur->nBias;
			}
			pCur = pCur->next;
		}
		if( (uintptr_t)nNewMin != INVALID_INDEX )
		{
			cnt = 0;
			for( n = 0; n < max; n++ )
				if( IsUsed( pNewMin, n ) )
				{
					array[cnt] = (void*)( ((uintptr_t)(pNewMin->bUsed))
												  + ofs
												  + n * unitsize );
					cnt++;
				}
		}
		nMin = nNewMin+1;
	}while( nNewMin != INVALID_INDEX );
	return array;
}
//----------------------------------------------------------------------------
int FindInArray( void **pArray, int nArraySize, void *unit )
{
	//int32_t idx;
	if( pArray )
	{
		int i, j, m;
		uintptr_t psvUnit, psvArray;
		i = 0;
		j = nArraySize-1;
		psvUnit = (uintptr_t)unit;
		do
		{
			m = (i+j)/2;
			psvArray = (uintptr_t)pArray[m];
			if( psvUnit < psvArray )
				j = m - 1;
			else if( psvUnit > psvArray )
				i = m + 1;
			else
				break;
		}
		while( i <= j );
		if( i > j )
			return -1;
		return m;
	}
	return -1;
}
//----------------------------------------------------------------------------
uintptr_t _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv )
{
	//Log2( "Doing all in set - size: %d setsize: %d", unitsize, max );
	if( f )
	{
		int ofs, n;
		ofs = ( ( max + 31) / 32 ) * 4;
		while( pSet )
		{
			for( n = 0; n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					psvReturn = f( (void*)( ((uintptr_t)(pSet->bUsed))
											  + ofs
											  + n * unitsize ), psv );
					if( psvReturn )
					{
						//Log( "Return short? ");
						return psvReturn;
					}
				}
			pSet = pSet->next;
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
#undef ForEachSetMember
uintptr_t ForEachSetMember( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv )
{
	//Log2( "Doing all in set - size: %d setsize: %d", unitsize, max );
	if( f )
	{
		int total = 0;
		int n;
		while( pSet )
		{
			int nFound = 0;
			for( n = 0; nFound < (int)pSet->nUsed && n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					nFound++;
					psvReturn = f( total+n, psv );
					if( psvReturn )
					{
						//Log( "Return short? ");
						return psvReturn;
					}
				}
			total += n;
			pSet = pSet->next;
		}
	}
	return 0;
}
#ifdef __cplusplus
//	namespace sets {
	}
 //	namespace containers {
	}
 //namespace sack {
}
#endif
// $Log: sets.c,v $
// Revision 1.15  2005/05/20 21:47:10  jim
// Add base to get member index... so we don't get index of member in a set, but the actual index of the member in order... also fix a spot of set slab linking.  Also, fix resulting of the member for an index...
//
// Revision 1.14  2005/05/18 21:19:32  jim
// Define a method which will only get a valid set member from a set.
//
// Revision 1.13  2005/03/07 12:53:15  panther
// Only check what's used in a set instead of all memebers.
//
// Revision 1.12  2005/02/09 22:40:22  panther
// allow timers library to steal sets code....
//
// Revision 1.11  2005/02/04 19:25:30  panther
// Added iterator for sets that's a little different
//
// Revision 1.10  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.9  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.8  2004/10/04 03:56:26  d3x0r
// protect against null array passed to find_in_array
//
// Revision 1.7  2004/02/18 20:47:04  d3x0r
// Undef MemberInSet
//
// Revision 1.6  2004/02/14 01:19:04  d3x0r
// Extensions of Set structure in containers, C++ interface extension
//
// Revision 1.5  2003/04/11 16:03:53  panther
// Added  LogN for gcc.  Fixed set code to search for first available instead of add at end always.  Added MKCFLAGS MKLDFLAGS for lnx makes.
// Fixed target of APP_DEFAULT_DATA.
// Updated display to use a meta buffer between for soft cursors.
//
// Revision 1.4  2003/03/25 09:37:58  panther
// Fix file tails mangled by CVS logging
//
// Revision 1.3  2003/03/25 08:45:58  panther
// Added CVS logging tag
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree container storing a user pointer blob of some user defined structure
 *   and a uintptr_t key which is used to check for content matchin.
 *   Binary tree has algorithms to become balanced, if the input is known to be weighted,
 *   or if statistics are pulled that indicate that the tree should be balanced, this
 *   function is available on demand.  Also searching through the tree using
 *   Least, Greatest, lesser, and greater is available.
 *
 * see also - include/typelib.h
 *
 */
//#define DEFINE_BINARYLIST_PERF_COUNTERS
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
#endif
//#include <sack_types.h>
//#include <sharemem.h>
//#include <logging.h>
//#define DEBUG_STEPPING
#ifdef __cplusplus
namespace sack {
	namespace containers {
		namespace BinaryTree {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
// consider slab allocation... 32 bytes even.
struct treenode_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
	} flags;
	int depth;
  // required to know how many nodes are in the tree; especially with branch transplants.
	int children;
	CPOINTER userdata;
	uintptr_t key;
	struct treenode_tag *lesser;
	struct treenode_tag *greater;
	struct treenode_tag **me;
	struct treenode_tag *parent;
};
typedef struct treenode_tag TREENODE;
#define MAXTREENODESPERSET 4096
DeclareSet( TREENODE );
typedef struct treeroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // tree points to the real TREEROOT (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	int depth;
	int children;
	uint32_t lock;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	int maxHeights[30];
	int maxSwaps[10];
	int maxScans;
	int balancedFromLeft;
	int balancedFromRight;
#endif
	GenericDestroy Destroy;
	GenericCompare Compare;
	PTREENODE tree;
	PTREENODE prior, current, lastfound;
} TREEROOT;
static PTREENODESET TreeNodeSet;
//---------------------------------------------------------------------------
#define MAXTREEROOTSPERSET 128
DeclareSet( TREEROOT );
static PTREEROOTSET treepool;
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from );
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from );
//---------------------------------------------------------------------------
PTREEROOT FindTreeRoot( PTREENODE node )
{
	while( node && (!node->flags.bRoot) && node->parent )
	{
		node = node->parent;
	}
	return (PTREEROOT)node;
}
//---------------------------------------------------------------------------
int CPROC BinaryCompareInt( uintptr_t old, uintptr_t new_key )
{
	if( old > new_key )
		return 1;
	else if( old < new_key )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
void BalanceBinaryTree( PTREEROOT root )
{
#if SACK_BINARYLIST_USE_CHILD_COUNTS
	while( LockedExchange( &root->lock, 1 ) )
		Relinquish();
	while( BalanceBinaryBranch( root->tree ) > 1 && 0);
	root->lock = 0;
#endif
	//Log( "=========" );;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//static PTREENODE AVL_RotateToRight( PTREENODE node )
	                                                                                                              /* Perform rotation*/
	                                                                                                   /* Update heights */
#define AVL_RotateToRight(node)                                          {	                                                                        PTREENODE left = node->lesser;	                                   PTREENODE T2 = left->greater;	                                                                                                             node->children -= (left->children + 1);	                                                                                                   node->me[0] = left;	                                              left->me = node->me;	                                             left->parent = node->parent;	                                            left->greater = node;	                                            node->me = &left->greater;	                                       node->parent = left;	                                                                                                                      node->lesser = T2;	                                               if( T2 ) {		                                                       T2->me = &node->lesser;		                                  T2->parent = node;		                                       node->children += (left->greater->children + 1);		         left->children -= (left->greater->children + 1);	         }	                                                                left->children += (node->children + 1);	                                             {		                                                                int leftDepth, rightDepth;		                               leftDepth = node->lesser ? node->lesser->depth : 0;		      rightDepth = node->greater ? node->greater->depth : 0;		   if( leftDepth > rightDepth )			                             node->depth = leftDepth + 1;		                     else			                                                     node->depth = rightDepth + 1;		                                                                                             leftDepth = left->lesser ? left->lesser->depth : 0;		      rightDepth = left->greater ? left->greater->depth : 0;		   if( leftDepth > rightDepth ) {			                           left->depth = leftDepth + 1;		                     }		                                                        else			                                                     left->depth = rightDepth + 1;	                    }                                                                }
//---------------------------------------------------------------------------
//static PTREENODE AVL_RotateToLeft( PTREENODE node )
	                                                                                                             /* Perform rotation  */
	                         /*  Update heights */
#define AVL_RotateToLeft(node)                                           {	                                                                        PTREENODE right = node->greater;	                                 PTREENODE T2 = right->lesser;	                                                                                                             node->children -= (right->children + 1);	                                                                                                  node->me[0] = right;	                                             right->me = node->me;	                                            right->parent = node->parent;	                                          right->lesser = node;	                                            node->me = &right->lesser;	                                       node->parent = right;	                                            node->greater = T2;	                                              if( T2 ) {		                                                       T2->me = &node->greater;		                                 T2->parent = node;		                                       node->children += (right->lesser->children + 1);		         right->children -= (right->lesser->children + 1);	        }	                                                                right->children += (node->children + 1);	                                            {		                                                                int left, rightDepth;		                                    left = node->lesser ? node->lesser->depth : 0;		           rightDepth = node->greater ? node->greater->depth : 0;		   if( left > rightDepth )			                                  node->depth = left + 1;		                          else			                                                     node->depth = rightDepth + 1;		                                                                                             left = right->lesser ? right->lesser->depth : 0;		         rightDepth = right->greater ? right->greater->depth : 0;		 if( left > rightDepth )			                                  right->depth = left + 1;		                         else			                                                     right->depth = rightDepth + 1;	                   }                                                                }
//---------------------------------------------------------------------------
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
int zz;
PRIORITY_PRELOAD( InitReadyToLog, 999 ) {
	zz = 1;
}
#endif
static void AVLbalancer( PTREEROOT root, PTREENODE node ) {
	PTREENODE _x = NULL;
	PTREENODE _y = NULL;
	PTREENODE _z = NULL;
	PTREENODE tmp;
	int leftDepth;
	int rightDepth;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	int height = 0;
	int swaps = 0;
#endif
	_z = node;
	while( _z && !_z->flags.bRoot ) {
		int doBalance;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
		height++;
#endif
		doBalance = FALSE;
		if( tmp = _z->greater )
			rightDepth = tmp->depth;
		else
			rightDepth = 0;
		if( tmp = _z->lesser )
			leftDepth = tmp->depth;
		else
			leftDepth = 0;
		if( leftDepth > rightDepth ) {
			if( (1 + leftDepth) == _z->depth ) {
				//if( zz )
				//	lprintf( "Stopped checking: %d %d %d", height, leftDepth, rightDepth );
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
				root->balancedFromLeft++;
#endif
				break;
			}
			_z->depth = 1 + leftDepth;
			if( (leftDepth -rightDepth) > 1 ) {
				doBalance = TRUE;
			}
		} else {
			if( (1 + rightDepth) == _z->depth ) {
				//if(zz)
				//	lprintf( "Stopped checking: %d %d %d", height, leftDepth, rightDepth );
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
				root->balancedFromRight++;
#endif
				break;
			}
			_z->depth = 1 + rightDepth;
			if( (rightDepth- leftDepth) > 1 ) {
				doBalance = TRUE;
			}
		}
		if( doBalance ) {
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
			swaps++;
#endif
			if( _x ) {
				if( _x == _y->lesser ) {
					if( _y == _z->lesser ) {
						// left/left
						AVL_RotateToRight( _z );
					}
					else {
						//left/rightDepth
						AVL_RotateToRight( _y );
						AVL_RotateToLeft( _z );
					}
				}
				else {
					if( _y == _z->lesser ) {
						AVL_RotateToLeft( _y );
						AVL_RotateToRight( _z );
						// rightDepth.left
					}
					else {
						//rightDepth/rightDepth
						AVL_RotateToLeft( _z );
					}
				}
			}
			else {
				//lprintf( "Not deep enough for balancing." );
			}
		}
		_x = _y;
		_y = _z;
		_z = _z->parent;
	}
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	if( !node->parent->flags.bRoot
		&& node->parent->lesser != node
		&& node->parent->greater != node ) {
		*(int*)0 = 0;
	}
	if( height < 31 )
		root->maxHeights[height]++;
	else
		root->maxHeights[0]++;
	if( swaps < 10 )
		root->maxSwaps[swaps]++;
	else
		root->maxSwaps[0]++;
	if( !_z )
		root->maxScans++;
#endif
}
//---------------------------------------------------------------------------
int HangBinaryNode( PTREEROOT root, PTREENODE node )
{
	PTREENODE check;
	if( !node )
		return 0;
	root->children += ( node->children + 1 );
	if( !(root->tree) )
	{
		root->tree = node;
		node->me = &root->tree;
		node->parent = (PTREENODE)root;
		return 1;
	}
	 check = root->tree;
	 while( check )
	 {
		 int dir = root->Compare( node->key, check->key );
		check->children += (node->children + 1);
		 if( dir < 0 )
		 {
			 if( check->lesser )
			 {
				 check = check->lesser;
			 }
			else
			{
				check->lesser = node;
				node->me = &check->lesser;
				node->parent = check;
				break;
			}
		 }
		 else if( dir > 0 )
			 if( check->greater )
			 {
				 check = check->greater;
			 }
			else
			{
				check->greater = node;
				node->me = &check->greater;
				node->parent = check;
				break;
			}
		else if( root->flags.bNoDuplicate )
		{
			while( check && !check->flags.bRoot )
			{
				check->children -= (node->children + 1);
				check = check->parent;
			}
			if( check )
				check->children -= (node->children + 1);
			DeleteFromSet( TREENODE, TreeNodeSet, node );
			return 0;
		}
		else
		{
#if SACK_BINARYLIST_USE_CHILD_COUNTS
			int leftchildren = 0, rightchildren = 0;
			if( check->lesser )
				leftchildren = check->lesser->children;
			if( check->greater )
				rightchildren = check->greater->children;
			if( leftchildren <= rightchildren )
#else
			// allow duplicates; but link in as a near node, either left
			// or right... depending on the depth.
			int leftdepth = 0, rightdepth = 0;
			if( check->lesser )
				leftdepth = check->lesser->depth;
			if( check->greater )
				rightdepth = check->greater->depth;
			if( leftdepth < rightdepth )
#endif
			{
				if( check->lesser )
					check = check->lesser;
				else
				{
					check->lesser = node;
					node->me = &check->lesser;
					node->parent = check;
					break;
				}
			}
			else
			{
				if( check->greater )
					check = check->greater;
				else
				{
					check->greater = node;
					node->me = &check->greater;
					node->parent = check;
					break;
				}
			}
		}
	}
	if( node->parent->lesser != node && node->parent->greater != node ) {
		*(int*)0 = 0;
	}
	AVLbalancer( root, node );
	return 1;
}
//---------------------------------------------------------------------------
int AddBinaryNodeEx( PTREEROOT root
                   , CPOINTER userdata
                   , uintptr_t key DBG_PASS )
{
	PTREENODE node;
	if( !root )
		return 0;
//AllocateEx( sizeof( TREENODE ) DBG_RELAY );
	node = GetFromSet( TREENODE, &TreeNodeSet );
	node->lesser = NULL;
	node->greater = NULL;
	node->me = NULL;
	node->children = 0;
	node->depth = 0;
	node->userdata = userdata;
	node->key = key;
	node->flags.bUsed = 1;
	node->flags.bRoot = 0;
	return HangBinaryNode( root, node );
}
#undef AddBinaryNode
int AddBinaryNode( PTREEROOT root
                 , CPOINTER userdata
                 , uintptr_t key )
{
	return AddBinaryNodeEx( root, userdata, key DBG_SRC );
}
//---------------------------------------------------------------------------
static void NativeRemoveBinaryNode( PTREEROOT root, PTREENODE node )
{
	if( root )
	{
		CPOINTER userdata = node->userdata;
		uintptr_t userkey = node->key;
		LOGICAL no_children = FALSE;
		// lprintf( "Removing node from tree.. %p under %p", node, node->parent );
		if( !node->parent->flags.bRoot
			&& node->parent->lesser != node
			&& node->parent->greater != node ) {
			*(int*)0=0;
		}
		PTREENODE least = NULL;
		PTREENODE backtrack;
  // deepest node a change was made on.
		PTREENODE bottom;
		if( !node->lesser ) {
			if( node->greater ) {
				bottom = (*node->me) = node->greater;
				bottom->parent = node->parent;
			} else {
				(*node->me) = NULL;
				bottom = node;
				no_children = TRUE;
			}
		} else if( !node->greater ) {
			bottom = (*node->me) = node->lesser;
			bottom->parent = node->parent;
		} else {
			node->children--;
			// have a lesser and a greater.
			if( node->lesser->depth > node->greater->depth ) {
				least = node->lesser;
				while( least->greater ) least = least->greater;
				if( least->lesser ) {
					(*(least->lesser->me =least->me)) = least->lesser;
					least->lesser->parent  = least->parent;
					bottom = least->lesser;
				} else {
					(*(least->me)) = NULL;
					bottom = least->parent;
				}
			} else {
				least = node->greater;
				while( least->lesser ) least = least->lesser;
				if( least->greater ) {
					(*(least->greater->me = least->me)) = least->greater;
					least->greater->parent  = least->parent;
					bottom = least->greater;
				} else {
					(*(least->me)) = NULL;
					bottom = least->parent;
				}
			}
		}
		{
			backtrack = bottom;
			do {
				backtrack = backtrack->parent;
				while( backtrack && ( no_children || backtrack != node ) ) {
					backtrack->children--;
					if( backtrack->lesser )
						if( backtrack->greater ) {
							int tmp1, tmp2;
							if( (tmp1=backtrack->lesser->depth) > (tmp2=backtrack->greater->depth) )
								backtrack->depth = tmp1 + 1;
							else
								backtrack->depth = tmp2 + 1;
						} else
							backtrack->depth = backtrack->lesser->depth + 1;
					else
						if( backtrack->greater )
							backtrack->depth = backtrack->greater->depth + 1;
						else
							backtrack->depth = 0;
					backtrack = backtrack->parent;
				}
				if( least ) {
					node->userdata = least->userdata;
					node->key      = least->key;
					DeleteFromSet( TREENODE, TreeNodeSet, least );
					node   = NULL;
					least  = NULL;
				}
			} while( backtrack );
		}
		AVLbalancer( root, bottom );
		if( root->Destroy )
			root->Destroy( userdata, userkey );
		if( node )
			DeleteFromSet( TREENODE, TreeNodeSet, node );
		return;
	}
	lprintf( "Fatal RemoveBinaryNode could not find the root!" );
}
//---------------------------------------------------------------------------
 void  RemoveBinaryNode ( PTREEROOT root, POINTER data, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
		{
			if( node->userdata == data )
			{
				NativeRemoveBinaryNode( root, node );
				break;
			}
			else
			{
				// hmm same key different data...
				break;
			}
		}
	}
	return ;
}
//---------------------------------------------------------------------------
void ResetBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
}
//---------------------------------------------------------------------------
static void DestroyBinaryTreeNode( PTREEROOT root, PTREENODE node )
{
	if( node ) {
		if( node->lesser )
			DestroyBinaryTreeNode( root, node->lesser );
		if( node->greater )
			DestroyBinaryTreeNode( root, node->greater );
		NativeRemoveBinaryNode( root, node );
	}
}
void DestroyBinaryTree( PTREEROOT root )
{
	DestroyBinaryTreeNode( root, root->tree );
	DeleteFromSet( TREEROOT, treepool, root );
}
//---------------------------------------------------------------------------
PTREEROOT CreateBinaryTreeExtended( uint32_t flags
									  , GenericCompare Compare
									  , GenericDestroy Destroy DBG_PASS )
{
	PTREEROOT root;
//(PTREEROOT)AllocateEx( sizeof( TREEROOT ) DBG_RELAY );
	root = GetFromSet( TREEROOT, &treepool );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	if( flags & BT_OPT_NODUPLICATES  )
		root->flags.bNoDuplicate = 1;
	root->Destroy = Destroy;
	//root->return  = NULL; // upgoing... (return from rightDepth )
	if( Compare )
		root->Compare = Compare;
	else
		root->Compare = BinaryCompareInt;
	return root;
}
#undef CreateBinaryTreeEx
PTREEROOT CreateBinaryTreeEx( GenericCompare Compare
								    , GenericDestroy Destroy )
{
	return CreateBinaryTreeExx( 0, Compare, Destroy );
}
//---------------------------------------------------------------------------
int maxlevel = 0;
void DumpNode( PTREENODE node, int level, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
#endif
	int print;
	if( !node )
		return;
	if( level > maxlevel )
		maxlevel = level;
	DumpNode( node->lesser, level+1, DumpMethod );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print ) {
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
		snprintf( buf, 256, "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
		puts( buf );
#else
		lprintf( "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
#endif
	}
	DumpNode( node->greater, level+1, DumpMethod );
}
//---------------------------------------------------------------------------
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
PUBLIC( void, GetTreePerf )( PTREEROOT root, int **heights, int **swaps, int *maxScans, int*bfl, int *bfr ) {
	if( heights ) heights[0] = root->maxHeights;
	if( swaps ) swaps[0] = root->maxSwaps;
	if( maxScans ) maxScans[0] = root->maxScans;
	if( bfl ) bfl[0] = root->balancedFromLeft;
	if( bfr ) bfr[0] = root->balancedFromRight;
}
#endif
void DumpTree( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
	maxlevel = 0;
	if( !Dump ) {
		snprintf( buf, 256, "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
		puts( buf );
	}
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) {
		snprintf( buf, 256, "Tree had %d levels.", maxlevel );
		puts( buf );
	}
	fflush( stdout );
#else
	maxlevel = 0;
	if( !Dump ) {
		lprintf(  "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
	}
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) {
		lprintf( "Tree had %d levels.", maxlevel );
	}
#endif
}
//---------------------------------------------------------------------------
void DumpNodeInOrder( PLINKQUEUE *queue, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
	PTREENODE node;
	while( node = (PTREENODE)DequeLink( queue ) )
	{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
#endif
	int print;
	if( !node )
		return;
	if( node->lesser )
		EnqueLink( queue, node->lesser );
	if( node->greater )
		EnqueLink( queue, node->greater );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print ) {
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
		snprintf( buf, 256, "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
		puts( buf );
#else
		lprintf( "%p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
#endif
	}
	}
}
//---------------------------------------------------------------------------
void DumpInOrder( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
	PLINKQUEUE plq = CreateLinkQueue();
	EnqueLink( &plq, root->tree );
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
	if( !Dump ) {
		snprintf( buf, 256, "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
		puts( buf );
	}
	DumpNodeInOrder( &plq, root->tree, 1, Dump );
	fflush( stdout );
#else
	maxlevel = 0;
	if( !Dump ) {
		lprintf(  "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
	}
	DumpNodeInOrder( &plq, Dump );
#endif
}
//---------------------------------------------------------------------------
CPOINTER FindInBinaryTree( PTREEROOT root, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return 0;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
int CPROC TextMatchLocate( uintptr_t key1, uintptr_t key2 )
{
	size_t k1len = StrLen( (CTEXTSTR)key1 );
	size_t k2len = StrLen( (CTEXTSTR)key2 );
	//lprintf( "COmpare %s(%d) vs %s(%d)", key1, k1len, key2, k2len );
	if( k2len < k1len )
	{
		// cannot match this.... but should
		// try to choose a direction
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k2len );
		if( dir == 0 )
			return 101;
		if( dir > 0 )
			return 1;
		return -1;
	}
	else if( k2len > k1len )
	{
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k1len );
		// is exact match, but only part of key2
		if( dir == 0 )
			return 100;
		// I doubt these will really matter...
		// could compute distance...
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
	else
	{
		int dir = StrCaseCmp( (CTEXTSTR)key1, (CTEXTSTR)key2 );
		if( dir == 0 )
			return 0;
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
}
// the key value passed does not have to be the same as the key in the tree
// it can be an abstrat reference of a strucutre that contains a key for the tree
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
CPOINTER LocateInBinaryTree( PTREEROOT root, uintptr_t key
                           , int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key )
                           )
{
	PTREENODE node;
	node = root->tree;
	if( !fuzzy )
		fuzzy = TextMatchLocate;
	while( node )
	{
		int _dir;
		int dir = fuzzy( key, node->key );
		if( dir == 100 || dir == 101 )
		{
			PTREENODE one_up;
			PTREENODE one_down;
			// this matched, in an inexact length.
			// to be really careful we should match one up and one down.
			// well, we'll match better only if we had exact length
			// so - go up one node, until we find exact length
			//lprintf( " - Found a near match..." );
			one_up = node;
			one_down = node;
			_dir = dir;
			do
			{
				GetLesserNodeExx( root, &one_up );
				if( one_up )
				{
					dir = fuzzy( key, one_up->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_up;
						return (one_up->userdata);
					}
					else
						one_up = NULL;
				}
				GetGreaterNodeExx( root, &one_down );
				if( one_down )
				{
					dir = fuzzy( key, one_down->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_down;
						return (one_down->userdata);
					}
					else
						one_down = NULL;
				}
			}
			while( one_up || one_down );
			if( _dir == 101 )
			{
				node = NULL;
			}
			root->lastfound = node;
			if( node )
				return( node->userdata );
			return 0;
		}
		if( dir > 0 )
		{
			node = node->greater;
		}
		else if( dir < 0 )
		{
			node = node->lesser;
		}
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
CPOINTER GetCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return NULL;
	return (*(struct treenode_tag **)cursor)->userdata;
}
CPOINTER GetCurrentNode( PTREEROOT root )
{
	return GetCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
void RemoveLastFoundNode( PTREEROOT root )
{
	if( !root || !root->lastfound )
		return;
	NativeRemoveBinaryNode( root, root->lastfound );
}
//---------------------------------------------------------------------------
void RemoveCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return;
	NativeRemoveBinaryNode( root, (PTREENODE)(*cursor) );
	(*cursor) = NULL;
}
void RemoveCurrentNode( PTREEROOT root )
{
	RemoveCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->greater && !(*from)->lesser )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->greater )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->greater )
	{
		// right
		(*from) = (*from)->greater;
		while( (*from)->lesser )
		{
			// Left
			(*from) = (*from)->lesser;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->greater == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetGreaterNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetGreaterNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetGreaterNode( PTREEROOT root )
{
	return GetGreaterNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->lesser && !(*from)->greater )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->lesser )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->lesser )
	{
		// right
		(*from) = (*from)->lesser;
		while( (*from)->greater )
		{
			// Left
			(*from) = (*from)->greater;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->lesser == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetLesserNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetLesserNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetLesserNode( PTREEROOT root )
{
	return GetLesserNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLeastNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	(*(struct treenode_tag **)cursor) = root->tree;
	root->prior = NULL;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->lesser )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetLeastNode( PTREEROOT root )
{
	return GetLeastNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreatestNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->greater )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetGreatestNode( PTREEROOT root )
{
	return GetGreatestNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetRootNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetRootNode( PTREEROOT root )
{
	return GetRootNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetParentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( !(*(struct treenode_tag **)cursor)->parent->flags.bRoot )
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->parent;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetParentNode( PTREEROOT root )
{
	return GetParentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( direction < 0 )
		{
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
		}
		else
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetChildNode( PTREEROOT root, int direction )
{
	return GetChildNodeEx( root, (POINTER*)&root->current, direction );
}
//---------------------------------------------------------------------------
CPOINTER GetPriorNodeEx( PTREEROOT root, POINTER *cursor )
{
	PTREENODE cur;
	if( !root ) return 0;
	cur = (*(struct treenode_tag **)cursor);
	(*(struct treenode_tag **)cursor) = root->prior;
	root->prior = cur;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetPriorNode( PTREEROOT root )
{
	return GetPriorNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
int GetNodeCount( PTREEROOT root )
{
	return root->children;
}
//---------------------------------------------------------------------------
PTREEROOT ShadowBinaryTree( PTREEROOT Original )
{
	PTREEROOT root;
	Log( "Use of binary tree shadows is fraught with danger!" );
	root = (PTREEROOT)Allocate( sizeof( TREEROOT ) );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	root->flags.bShadow = 1;
	root->children = 0;
	root->depth = 0;
	root->Compare = Original->Compare;
	root->Destroy = Original->Destroy;
	root->tree = Original->tree;
	return root;
}
#ifdef __cplusplus
 // namespace BinaryTree {
}
 //namespace containers {
}
 //namespace sack {
}
#endif
